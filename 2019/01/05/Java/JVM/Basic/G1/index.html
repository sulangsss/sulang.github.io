<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="true">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Java,Basic,JVM,G1,">





  <link rel="alternate" href="/atom.xml" title="A Big Boy Blog -  Tech Articls & Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="IntroductionThe Garbage-First (G1) garbage collector is a server-style garbage collector, targeted for multiprocessor machines with large memories. It attempts to meet garbage collection (GC) pause ti">
<meta name="keywords" content="Java,Basic,JVM,G1">
<meta property="og:type" content="article">
<meta property="og:title" content="Introduction to G1">
<meta property="og:url" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/index.html">
<meta property="og:site_name" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:description" content="IntroductionThe Garbage-First (G1) garbage collector is a server-style garbage collector, targeted for multiprocessor machines with large memories. It attempts to meet garbage collection (GC) pause ti">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/g1_heap_region.png">
<meta property="og:image" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/g1-heap-allocation.png">
<meta property="og:image" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/g1_gc_layout.png">
<meta property="og:image" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/rset-example.jpg">
<meta property="og:updated_time" content="2019-05-03T11:59:32.020Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Introduction to G1">
<meta name="twitter:description" content="IntroductionThe Garbage-First (G1) garbage collector is a server-style garbage collector, targeted for multiprocessor machines with large memories. It attempts to meet garbage collection (GC) pause ti">
<meta name="twitter:image" content="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/g1_heap_region.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/">





<meta name="baidu-site-verification" content="xV2vphJ53Q">


  <title>Introduction to G1 | A Big Boy Blog -  Tech Articls & Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?344f3e8f33d176fceb44e65d30a341dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">A Big Boy Blog -  Tech Articls & Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Python Java Android Django Web -> sulang357159@gmail.com</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/01/05/Java/JVM/Basic/G1/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Introduction to G1</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-05T16:20:22+08:00">
                2019-01-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The Garbage-First (G1) garbage collector is a server-style garbage collector, <strong>targeted for multiprocessor machines with large memories</strong>. It attempts to meet garbage collection (GC) pause time goals with high probability while achieving high throughput. Whole-heap operations, such as <strong>global marking</strong>, are performed concurrently with the application threads. This prevents interruptions proportional(比例的，均衡的) to heap or live-data size.</p>
<p>The G1 collector achieves high performance and pause time goals through several techniques.</p>
<ul>
<li><p>The heap is partitioned(分割) into a set of equally sized <strong>heap regions</strong>, each a contiguous range of virtual memory.</p>
</li>
<li><p>G1 performs a concurrent global marking phase to determine the liveness of objects throughout the heap. After the marking phase completes, G1 knows which regions are mostly empty. It collects these regions first, which often yields(产生) a large amount of free space. This is why this method of garbage collection is called <strong>Garbage-First</strong>. </p>
</li>
<li><p>As the name suggests, G1 concentrates(集中) its <strong>collection</strong> and <strong>compaction</strong> activity on the areas of the heap that are likely to be full of reclaimable(可回收的) objects, that is(即，就是说), garbage. G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.</p>
</li>
<li><p>G1 copies objects from one or more regions of the heap to a single region on the heap, and in the process both compacts and frees up memory. This evacuation(回收操作) is performed in parallel on multiprocessors to decrease pause times and increase throughput. Thus, with each garbage collection, G1 continuously works to reduce fragmentation. This is beyond the capability of both of the previous methods. <strong>CMS (Concurrent Mark Sweep) garbage collection does not do compaction. Parallel compaction performs only whole-heap compaction, which results in considerable pause times.</strong></p>
</li>
</ul>
<p>It is important to note that G1 is not a real-time collector. It meets the set pause time target with high probability but not absolute certainty. Based on data from previous collections, G1 estimates how many regions can be collected within the target time. Thus, the collector has a reasonably accurate model of the cost of collecting the regions, and it uses this model to determine which and how many regions to collect while staying within the pause time target.</p>
<p>The first focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6 GB or larger, and a stable and predictable pause time below 0.5 seconds.</p>
<p>Applications running today with either the CMS or the with parallel compaction would benefit from switching to G1 if the application has one or more of the following traits(特性，特点).</p>
<ul>
<li><p>More than 50% of the Java heap is occupied with live data.</p>
</li>
<li><p>The rate of object allocation rate or promotion varies(改变，变化) significantly(明显地).</p>
</li>
<li><p>The application is experiencing undesired(不希望的) long garbage collection or compaction pauses (longer than 0.5 to 1 second).</p>
</li>
</ul>
<p>G1 is planned as the long-term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS reveals differences that make G1 a better solution. One difference is that G1 is a compacting collector. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.</p>
<p>As with CMS, <strong>G1 is designed for applications that require shorter GC pauses.</strong></p>
<hr>
<h3 id="Young-GC-And-Mixed-GC"><a href="#Young-GC-And-Mixed-GC" class="headerlink" title="Young GC And Mixed GC"></a>Young GC And Mixed GC</h3><p>G1提供了两种GC模式，<strong>Young GC</strong>和<strong>Mixed GC</strong>，两种都是完全<strong>Stop The World</strong>：</p>
<ul>
<li>Young GC：选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。</li>
<li>Mixed GC：选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</li>
</ul>
<p>由上述可知，Mixed GC不是Full GC，它只能回收部分老年代的Region，如果Mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用Serial Old GC(Full GC)来收集整个GC Heap。所以我们可以知道，G1是不提供Full GC的。</p>
<blockquote>
<p>global concurrent marking：它的执行过程类似CMS，但是不同的是，在G1 GC中，它主要是为Mixed GC提供标记服务的，并不是一次GC过程的一个必须环节。<br>执行过程分为四个步骤：</p>
<ul>
<li>初始标记（initial mark，STW）。它标记了从GC Root开始直接可达的对象。</li>
<li>并发标记（Concurrent Marking）。这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。</li>
<li>最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。</li>
<li>清除垃圾（Cleanup）。清除空Region（没有存活对象的），加入到free list。<br>第一阶段initial mark是共用了Young GC的暂停，这是因为他们可以复用root scan操作，所以可以说global concurrent marking是伴随Young GC而发生的。第四阶段Cleanup只是回收了没有存活对象的Region，所以它并不需要STW。</li>
</ul>
</blockquote>
<h4 id="什么时候触发Mixed-GC"><a href="#什么时候触发Mixed-GC" class="headerlink" title="什么时候触发Mixed GC"></a>什么时候触发Mixed GC</h4><ul>
<li><p>G1HeapWastePercent：在global concurrent marking结束之后，我们可以知道old gen regions中有多少空间要被回收，在每次YGC之后和再次发生Mixed GC之前，会检查垃圾占比是否达到此参数，只有达到了，下次才会发生Mixed GC。</p>
</li>
<li><p>G1MixedGCLiveThresholdPercent：old generation region中的存活对象的占比，只有在此参数之下，才会被选入CSet。</p>
</li>
<li><p>G1MixedGCCountTarget：一次global concurrent marking之后，最多执行Mixed GC的次数。</p>
</li>
<li><p>G1OldCSetRegionThresholdPercent：一次Mixed GC中能被选入CSet的最多old generation region数量。</p>
</li>
</ul>
<hr>
<h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><img src="/2019/01/05/Java/JVM/Basic/G1/g1_heap_region.png" title="Heap Division by G1">
<p>G1 is generational in a logical sense. A set of empty regions is designated as the logical young generation. In the figure, the young generation is light blue. Allocations are done out of(从..) that logical young generation, and when the young generation is full, that set of regions is garbage collected (a young collection).</p>
<p>In some cases, regions outside the set of young regions (old regions in dark blue) can be garbage collected at the same time. This is referred to as a <strong>mixed collection</strong>. </p>
<p>In the figure, the regions being collected are marked by <strong>red boxes</strong>. The figure illustrates a mixed collection because both young regions and old regions are being collected. The garbage collection is a compacting collection that copies live objects to selected, initially empty regions.</p>
<p>Based on the age of a surviving object, the object can be copied to a survivor region (marked by “S”) or to an old region (not specifically shown). The regions marked by “H” contain humongous objects that are larger than half a region and are treated specially.</p>
<h4 id="Humongous-Objects-and-Humongous-Allocations"><a href="#Humongous-Objects-and-Humongous-Allocations" class="headerlink" title="Humongous Objects and Humongous Allocations"></a>Humongous Objects and Humongous Allocations</h4><p>For G1 GC, <strong>any object that is more than half a region size is considered a humongous object</strong>. Such an object is allocated directly in the old generation into humongous regions. These humongous regions are a contiguous set of regions. StartsHumongous marks the start of the contiguous set and ContinuesHumongous marks the continuation of the set.</p>
<p>Before allocating any humongous region, the marking threshold is checked, initiating a concurrent cycle, if necessary.</p>
<p>Dead humongous objects are freed at the end of the marking cycle during the cleanup phase and also during a full garbage collection cycle.</p>
<p>To reduce copying overhead, the humongous objects are not included in any evacuation pause. A full garbage collection cycle compacts humongous objects in place.</p>
<p>Because each individual set of StartsHumongous and ContinuesHumongous regions contains just one humongous object, the space between the end of the humongous object and the end of the last region spanned by the object is unused. For objects that are just slightly larger than a multiple of the heap region size, this unused space can cause the heap to become fragmented.</p>
<p>If you see back-to-back concurrent cycles initiated due to humongous allocations and if such allocations are fragmenting your old generation, then increase the value of -XX:G1HeapRegionSize such that previous humongous objects are no longer humongous and will follow the regular allocation path.</p>
<hr>
<h3 id="Allocation-Evacuation-Failure"><a href="#Allocation-Evacuation-Failure" class="headerlink" title="Allocation (Evacuation) Failure"></a>Allocation (Evacuation) Failure</h3><p>As with <strong>CMS</strong>, the <strong>G1</strong> collector runs parts of its collection while the application continues to run and there is a risk that <strong>the application will allocate objects faster than the garbage collector can recover free space</strong>. </p>
<blockquote>
<p>See the section Concurrent Mode Failure in Concurrent Mark Sweep (CMS) Collector for the analogous CMS behavior. </p>
</blockquote>
<p>In G1, the failure (exhaustion of the Java heap) occurs while G1 is copying live data out of one region (evacuating) into another region. The copying is done to compact the live data. If a free (empty) region cannot be found during the evacuation of a region being garbage collected, then an allocation failure occurs (because there is no space to allocate the live objects from the region being evacuated) and a stop-the-world (STW) full collection is done.</p>
<hr>
<h3 id="Floating-Garbage"><a href="#Floating-Garbage" class="headerlink" title="Floating Garbage"></a>Floating Garbage</h3><p>Objects can die during a G1 collection and not be collected. G1 uses a technique called <strong>snapshot-at-the-beginning (SATB)</strong> to guarantee that all live objects are found by the garbage collector. SATB states(声明) that any object that is live at the start of the concurrent marking (a marking over the entire heap) is considered live for the purpose of the collection. SATB allows floating garbage in a way analogous(类似的) to that of a CMS incremental update.</p>
<hr>
<h3 id="Pauses"><a href="#Pauses" class="headerlink" title="Pauses"></a>Pauses</h3><p><strong>G1 pauses the application to copy live objects to new regions.</strong> These pauses can either be young collection pauses where only young regions are collected or mixed collection pauses where young and old regions are evacuated. </p>
<p>As with CMS there is a final marking or remark pause to complete the marking while the application is stopped. Whereas CMS also had an initial marking pause, G1 does the initial marking work as part of an evacuation pause. G1 has a cleanup phase at the end of a collection which is partly STW and partly concurrent. The STW part of the cleanup phase identifies empty regions and determines old regions that are candidates for the next collection.</p>
<hr>
<h3 id="Card-Tables-and-Concurrent-Phases"><a href="#Card-Tables-and-Concurrent-Phases" class="headerlink" title="Card Tables and Concurrent Phases"></a>Card Tables and Concurrent Phases</h3><p>If a garbage collector does not collect the entire heap (<strong>an incremental collection</strong>), the garbage collector needs to know where there are <strong>pointers from the uncollected part of the heap into the part of the heap that is being collected</strong>. </p>
<p>This is typically for a generational garbage collector in which the uncollected part of the heap is usually the old generation, and the collected part of the heap is the young generation. </p>
<p>The data structure for keeping this information (old generation pointers to young generation objects), is a <strong>remembered set</strong>. A card table is a particular type of remembered set. </p>
<p>Java HotSpot VM uses an array of bytes as a card table. Each byte is referred to as a card. A card corresponds to a range of addresses in the heap. <strong>Dirtying a card means changing the value of the byte to a dirty value; a dirty value might contain a new pointer from the old generation to the young generation in the address range covered by the card</strong>.</p>
<blockquote>
<p>Processing a card means looking at the card to see if there is an old generation to young generation pointer and perhaps doing something with that information such as transferring it to another data structure.</p>
</blockquote>
<p>G1 has concurrent marking phase which marks live objects found from the application. The concurrent marking extends from the end of a evacuation pause (where the initial marking work is done) to the remark. The concurrent cleanup phase adds regions emptied by the collection to the list of free regions and clears the remembered sets of those regions. In addition, a concurrent refinement thread runs as needed to process card table entries that have been dirtied by application writes and which may have cross region references.</p>
<hr>
<h3 id="Starting-a-Concurrent-Collection-Cycle"><a href="#Starting-a-Concurrent-Collection-Cycle" class="headerlink" title="Starting a Concurrent Collection Cycle"></a>Starting a Concurrent Collection Cycle</h3><p>As mentioned previously, both young and old regions are garbage collected in a mixed collection. To collect old regions, G1 does a complete marking of the live objects in the heap. Such a marking is done by a concurrent marking phase. </p>
<p>A concurrent marking phase is started when the occupancy of the entire Java heap reaches the value of the parameter <strong>InitiatingHeapOccupancyPercent</strong>. Set the value of this parameter with the command-line option -XX:InitiatingHeapOccupancyPercent=<nn>. The default value of InitiatingHeapOccupancyPercent is 45.</nn></p>
<hr>
<h3 id="Pause-Time-Goal"><a href="#Pause-Time-Goal" class="headerlink" title="Pause Time Goal"></a>Pause Time Goal</h3><p>Set a pause time goal for G1 with the flag <strong>MaxGCPauseMillis</strong>. G1 uses a prediction model to decide how much garbage collection work can be done within that target pause time. </p>
<p>At the end of a collection, G1 chooses the regions to be collected in the next collection (the collection set). The collection set will contain young regions (the sum of whose sizes determines the size of the logical young generation). It is partly through the selection of the number of young regions in the collection set that G1 exerts control over the length of the GC pauses. You can specify the size of the young generation on the command line as with the other garbage collectors, but doing so may hamper the ability of G1 to attain the target pause time. </p>
<p>In addition to the pause time goal, you can specify the length of the time period during which the pause can occur. You can specify the minimum mutator usage with this time span (GCPauseIntervalMillis) along with the pause time goal. The default value for MaxGCPauseMillis is 200 milliseconds. The default value for GCPauseIntervalMillis (0) is the equivalent of no requirement on the time span.</p>
<p>在G1提出之前，经典的垃圾收集器主要有三种类型：串行收集器、并行收集器和并发标记清除收集器，这三种收集器分别可以是满足Java应用三种不同的需求：内存占用及并发开销最小化、应用吞吐量最大化和应用GC暂停时间最小化。但是，上述三种垃圾收集器都有几个共同的问题：</p>
<ul>
<li>所有针对老年代的操作必须扫描整个老年代空间；</li>
<li>年轻地和老年代是独立的连续的内存块，必须先决定年轻代和老年代在虚拟地址空间的位置。</li>
</ul>
<p>G1是一种服务器端的垃圾收集器，应用在多处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集暂停时间的要求。它是专门针对以下应用场景设计的:</p>
<ul>
<li>像CMS收集器一样，能与应用程序线程并发执行。</li>
<li>整理空闲空间更快。</li>
<li>需要GC停顿时间更好预测。</li>
<li>不希望牺牲大量的吞吐性能。</li>
<li>不需要更大的Java Heap。</li>
</ul>
<p>G1收集器的设计目标是取代CMS收集器，它同CMS相比，在以下方面表现的更出色：</p>
<ul>
<li>G1是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。</li>
<li>G1的Stop The World(STW)更可控，G1在停顿时间上添加了预测机制，用户可以指定期望停顿时间。</li>
</ul>
<blockquote>
<p>The Garbage-First (G1) collector is a server-style garbage collector, targeted for multi-processor machines with large memories. It meets garbage collection (GC) pause time goals with a high probability, while achieving high throughput. The G1 garbage collector is fully supported in Oracle JDK 7 update 4 and later releases. The G1 collector is designed for applications that:</p>
<ul>
<li>Can operate concurrently with applications threads like the CMS collector.</li>
<li>Compact free space without lengthy GC induced pause times.</li>
<li>Need more predictable GC pause durations.</li>
<li>Do not want to sacrifice a lot of throughput performance.</li>
<li>Do not require a much larger Java heap.</li>
</ul>
</blockquote>
<h3 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h3><h4 id="Region-1"><a href="#Region-1" class="headerlink" title="Region"></a>Region</h4><p>传统的GC收集器将连续的内存空间划分为新生代、老年代和永久代（JDK 8去除了永久代，引入了元空间Metaspace），这种划分的特点是各代的存储地址(逻辑地址)是连续的。如下图所示：</p>
<img src="/2019/01/05/Java/JVM/Basic/G1/g1-heap-allocation.png">
<p>而G1的各代存储地址是不连续的，每一代都使用了n个不连续的大小相同的Region，每个Region占有一块连续的虚拟内存地址。如下图所示：</p>
<img src="/2019/01/05/Java/JVM/Basic/G1/g1_gc_layout.png">
<p>每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、幸存区、老年代这些概念还存在，成为逻辑上的概念，这样方便复用之前分代框架的逻辑。</p>
<p>在物理上不需要连续，则带来了额外的好处 —— 有的分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即<strong>首先收集垃圾最多的分区</strong>。</p>
<p>在上图中，我们注意到还有一些Region标明了H，它代表Humongous，这表示这些Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象。H-obj有如下几个特征：</p>
<ul>
<li>H-obj直接分配到了old gen，防止了反复拷贝移动。</li>
<li>H-obj在global concurrent marking阶段的cleanup 和 Full GC阶段回收。</li>
<li>在分配H-obj之前先检查是否超过 initiating heap occupancy percent和the marking threshold, 如果超过的话，就启动global concurrent marking，为的是提早回收，防止 evacuation failures 和 Full GC。</li>
</ul>
<p>为了减少连续H-objs分配对GC的影响，需要把大对象变为普通的对象，建议增大Region size。</p>
<p>一个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围从1M到32M，且是2的指数。如果不设定，那么G1会根据Heap大小自动决定。</p>
<hr>
<h4 id="CSet-收集集合"><a href="#CSet-收集集合" class="headerlink" title="CSet - 收集集合"></a>CSet - 收集集合</h4><p>一组可被回收的分区的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小。</p>
<hr>
<h4 id="RSet-已记忆集合"><a href="#RSet-已记忆集合" class="headerlink" title="RSet - 已记忆集合"></a>RSet - 已记忆集合</h4><p>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</p>
<img src="/2019/01/05/Java/JVM/Basic/G1/rset-example.jpg">
<p>Region1和Region3中的对象都引用了Region2中的对象，因此在Region2的RSet中记录了这两个引用。</p>
<blockquote>
<p>G1 GC是在points-out的card table之上再加了一层结构来构成points-into RSet：每个region会记录下到底哪些别的region有指向自己的指针，而这些指针分别在哪些card的范围内。<br>这个RSet其实是一个hash table，key是别的region的起始地址，value是一个集合，里面的元素是card table的index。<br>举例来说，如果region A的RSet里有一项的key是region B，value里有index为1234的card，它的意思就是region B的一个card里有引用指向region A。所以对region A来说，该RSet记录的是points-into的关系；而card table仍然记录了points-out的关系。</p>
</blockquote>
<hr>
<h4 id="Snapshot-At-The-Beginning-SATB"><a href="#Snapshot-At-The-Beginning-SATB" class="headerlink" title="Snapshot-At-The-Beginning(SATB)"></a>Snapshot-At-The-Beginning(SATB)</h4><p>SATB是GC开始时活着的对象的一个快照。它是通过Root Tracing得到的，作用是维持并发GC的正确性。</p>
<p>那么它是怎么维持并发GC的正确性的呢？根据三色标记算法，我们知道对象存在三种状态：</p>
<ul>
<li>白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。</li>
<li>灰：对象被标记了，但是它的field还没有被标记或标记完。</li>
<li>黑：对象被标记了，且它的所有field也被标记完了。</li>
</ul>
<p>由于并发阶段的存在，Mutator和Garbage Collector线程同时对对象进行修改，就会出现白对象漏标的情况，这种情况发生的前提是：</p>
<ul>
<li>Mutator赋予一个黑对象该白对象的引用。</li>
<li>Mutator删除了所有从灰对象到该白对象的直接或者间接引用。</li>
</ul>
<hr>
<h4 id="Pause-Prediction-Model"><a href="#Pause-Prediction-Model" class="headerlink" title="Pause Prediction Model"></a>Pause Prediction Model</h4><p>Pause Prediction Model 即停顿预测模型。它在G1中的作用是：G1 uses a pause prediction model to meet a user-defined pause time target and selects the number of regions to collect based on the specified pause time target.</p>
<p>G1 GC是一个响应时间优先的GC算法，它与CMS最大的不同是，用户可以设定整个GC过程的期望停顿时间，参数-XX:MaxGCPauseMillis指定一个G1收集过程目标停顿时间，默认值200ms，不过它不是硬性条件，只是期望值。那么G1怎么满足用户的期望呢？就需要这个停顿预测模型了。G1根据这个模型统计计算出来的历史数据来预测本次收集需要选择的Region数量，从而尽量满足用户设定的目标停顿时间。</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/g1.html</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc.html#garbage_first_garbage_collection</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Basic/" rel="tag"># Basic</a>
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
            <a href="/tags/G1/" rel="tag"># G1</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/28/Java/JVM/Case/ResizeMetaspaceCauseOfFullGC/" rel="next" title="Resize Metaspace Cause Of Full GC">
                <i class="fa fa-chevron-left"></i> Resize Metaspace Cause Of Full GC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/01/05/Java/Advance/off-heap memory/" rel="prev" title="堆外内存(off-heap memory)">
                堆外内存(off-heap memory) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jason - sulang357159@163.com">
          
            <p class="site-author-name" itemprop="name">Jason - sulang357159@163.com</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">592</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">251</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">646</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Introduction"><span class="nav-number">1.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Young-GC-And-Mixed-GC"><span class="nav-number">2.</span> <span class="nav-text">Young GC And Mixed GC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么时候触发Mixed-GC"><span class="nav-number">2.1.</span> <span class="nav-text">什么时候触发Mixed GC</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Region"><span class="nav-number">3.</span> <span class="nav-text">Region</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Humongous-Objects-and-Humongous-Allocations"><span class="nav-number">3.1.</span> <span class="nav-text">Humongous Objects and Humongous Allocations</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Allocation-Evacuation-Failure"><span class="nav-number">4.</span> <span class="nav-text">Allocation (Evacuation) Failure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Floating-Garbage"><span class="nav-number">5.</span> <span class="nav-text">Floating Garbage</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pauses"><span class="nav-number">6.</span> <span class="nav-text">Pauses</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Card-Tables-and-Concurrent-Phases"><span class="nav-number">7.</span> <span class="nav-text">Card Tables and Concurrent Phases</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Starting-a-Concurrent-Collection-Cycle"><span class="nav-number">8.</span> <span class="nav-text">Starting a Concurrent Collection Cycle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pause-Time-Goal"><span class="nav-number">9.</span> <span class="nav-text">Pause Time Goal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Terms"><span class="nav-number">10.</span> <span class="nav-text">Terms</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Region-1"><span class="nav-number">10.1.</span> <span class="nav-text">Region</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CSet-收集集合"><span class="nav-number">10.2.</span> <span class="nav-text">CSet - 收集集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RSet-已记忆集合"><span class="nav-number">10.3.</span> <span class="nav-text">RSet - 已记忆集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Snapshot-At-The-Beginning-SATB"><span class="nav-number">10.4.</span> <span class="nav-text">Snapshot-At-The-Beginning(SATB)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Pause-Prediction-Model"><span class="nav-number">10.5.</span> <span class="nav-text">Pause Prediction Model</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reference"><span class="nav-number">11.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason - sulang357159@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
