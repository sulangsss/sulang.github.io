<hr>
<p>title: Java Executors<br>date: 2019-08-03 20:22:22<br>tags:</p>
<ul>
<li>Java</li>
<li>Thread</li>
<li>Executors<br>categories: </li>
<li>Java</li>
<li>Thread</li>
</ul>
<hr>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>自 JDK 1.5 起，utils 包提供了 ExecutorService 线程池的实现，主要目的是为了重复利用线程，提供系统效率。</p>
<p>线程数量和系统性能是一种抛物线的关系，即当线程数量达到某个值的时候，性能反倒会降低很多，因此对线程的管理，尤其是数量的控制更能直接决定程序的性能。</p>
<blockquote>
<p>JUC: JDK 的 Java utilities concurrent</p>
</blockquote>
<h3 id="ExecutorService-Implementation-Class"><a href="#ExecutorService-Implementation-Class" class="headerlink" title="ExecutorService Implementation Class"></a>ExecutorService Implementation Class</h3><ul>
<li>ScheduledExecutorService</li>
<li>ThreadPoolExecutor</li>
<li>ScheduledThreadPoolExecutor</li>
</ul>
<h4 id="Thread-Factory-Class"><a href="#Thread-Factory-Class" class="headerlink" title="Thread Factory Class"></a>Thread Factory Class</h4><ul>
<li>newSingleThreadExecutor: 创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool: 创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，在提交新任务，任务将会进入等待队列中等待。如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。</li>
<li>newCachedThreadPool: 创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒处于等待任务到来）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池的最大值是Integer的最大值(2^31-1)。</li>
<li>newScheduledThreadPool: 创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</li>
<li>newWorkStealingPool: 创建一个带并行级别的线程池，并行级别决定了同一时刻最多有多少个线程在执行，默认并行级别为当前系统的CPU个数。</li>
</ul>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[Java Executor并发框架（一）整体介绍]<a href="https://www.cnblogs.com/vhua/p/5277694.html">https://www.cnblogs.com/vhua/p/5277694.html</a></li>
</ul>
