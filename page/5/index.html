<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="true">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="A Big Boy Blog -  Tech Articls & Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta property="og:type" content="website">
<meta property="og:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:url" content="https://sulangsss.github.io/page/5/index.html">
<meta property="og:site_name" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sulangsss.github.io/page/5/">





<meta name="baidu-site-verification" content="xV2vphJ53Q">


  <title>A Big Boy Blog -  Tech Articls & Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?344f3e8f33d176fceb44e65d30a341dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">A Big Boy Blog -  Tech Articls & Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Python Java Android Django Web -> sulang357159@gmail.com</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/03/Java/JVM/Basic/Prearraygement-Knowledge/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Java/JVM/Basic/Prearraygement-Knowledge/" itemprop="url">Java JVM Prearrangement Knowledge</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T13:01:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h2><p>Ergonomics is the process by which the Java Virtual Machine (JVM) and garbage collection tuning, such as behavior-based(基于行为) tuning(调节，调整), improve application performance. </p>
<p>The JVM provides platform-dependent default selections for the garbage collector, heap size, and runtime compiler. These selections match the needs of different types of applications while requiring less command-line tuning. </p>
<p>In addition, behavior-based tuning dynamically tunes the sizes of the heap to meet a specified behavior of the application.</p>
<p>This section describes these default selections and behavior-based tuning. Use these defaults first before using the more detailed controls described in subsequent sections.</p>
<h3 id="Behavior-Based-Tuning"><a href="#Behavior-Based-Tuning" class="headerlink" title="Behavior-Based Tuning"></a>Behavior-Based Tuning</h3><h4 id="Maximum-Pause-Time-Goal"><a href="#Maximum-Pause-Time-Goal" class="headerlink" title="Maximum Pause Time Goal"></a>Maximum Pause Time Goal</h4><p><strong>The pause time is the duration during which the garbage collector stops the application and recovers space that is no longer in use.</strong> The intent of the maximum pause time goal is to limit the longest of these pauses. </p>
<p>An average time for pauses and a variance(方差) on that average is maintained by the garbage collector. The average is taken from the start of the execution but is weighted so that more recent pauses count more heavily. If the average plus the variance of the pause times is greater than the maximum pause time goal, then the garbage collector considers that the goal is not being met.</p>
<p>The maximum pause time goal is specified with the command-line option <strong>-XX:MaxGCPauseMillis=<nnn></nnn></strong>. This is interpreted(可理解的) as a hint to the garbage collector that pause times of <nnn> milliseconds or less are desired. The garbage collector will adjust the Java heap size and other parameters related to garbage collection in an attempt to keep garbage collection pauses shorter than <nnn> milliseconds. </nnn></nnn></p>
<p>By default there is no maximum pause time goal. These adjustments may cause garbage collector to occur more frequently, reducing the overall throughput of the application. The garbage collector tries to meet any pause time goal before the throughput goal. In some cases, though, the desired pause time goal cannot be met.</p>
<h4 id="Throughput-Goal"><a href="#Throughput-Goal" class="headerlink" title="Throughput Goal"></a>Throughput Goal</h4><p>The throughput goal is measured in terms of the time spent collecting garbage and the time spent outside of garbage collection (referred to as application time). </p>
<p>The goal is specified by the command-line option -XX:GCTimeRatio=<nnn>. The ratio of garbage collection time to application time is <strong>1 / (1 + <nnn>)</nnn></strong>. For example, -XX:GCTimeRatio=19 sets a goal of 1/20th or 5% of the total time for garbage collection.</nnn></p>
<p><strong>The time spent in garbage collection is the total time for both the young generation and old generation collections combined.</strong> If the throughput goal is not being met, then the sizes of the generations are increased in an effort to increase the time that the application can run between collections.</p>
<h4 id="Footprint-Goal"><a href="#Footprint-Goal" class="headerlink" title="Footprint Goal"></a>Footprint Goal</h4><p>If the throughput and maximum pause time goals have been met, then the garbage collector reduces the size of the heap until one of the goals (invariably(adv.总是) the throughput goal) cannot be met. The goal that is not being met is then addressed(处理，解决).</p>
<hr>
<h3 id="Tuning-Strategy"><a href="#Tuning-Strategy" class="headerlink" title="Tuning Strategy"></a>Tuning Strategy</h3><p>Do not choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size. <strong>Choose a throughput goal that is sufficient for your application.</strong></p>
<p>The heap will grow or shrink to a size that will support the chosen throughput goal. A change in the application’s behavior can cause the heap to grow or shrink. For example, if the application starts allocating at a higher rate, the heap will grow to maintain the same throughput.</p>
<p>If the heap grows to its maximum size and the throughput goal is not being met, the maximum heap size is too small for the throughput goal. Set the maximum heap size to a value that is close to the total physical memory on the platform but which does not cause swapping of the application. Execute the application again. If the throughput goal is still not met, then the goal for the application time is too high for the available memory on the platform.</p>
<p>If the throughput goal can be met, but there are pauses that are too long, then select a maximum pause time goal. Choosing a maximum pause time goal may mean that your throughput goal will not be met, so choose values that are an acceptable compromise for the application.</p>
<p>It is typical that the size of the heap will oscillate(波动) as the garbage collector tries to satisfy competing goals. This is true even if the application has reached a steady state. The pressure to achieve a throughput goal (which may require a larger heap) competes with the goals for a maximum pause time and a minimum footprint (which both may require a small heap).</p>
<hr>
<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><h3 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer）</p>
<p>用引用计数器判断对象是否存活的过程是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>引用计数算法的实现简单，判定效率也很高，大部分情况下是一个不错的算法。它没有被JVM采用的原因是它很难解决对象之间循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * testGC()方法执行后，objA和objB会不会被GC呢？ */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，对象objA 和对象objB都有字段instance，赋值令objA.instance = objB;、objB.instance = objA;，除此之外，这两个对象再无引用。如果JVM采用引用计数算法来管理内存，这两个对象不可能再被访问，但是他们互相引用着对方，导致它们引用计数不为0，所以引用计数器无法通知GC收集器回收它们。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流商用程序语言的实现中，都是通过可达性分析（tracing GC）来判定对象是否存活的。</p>
<p>此算法的基本思路是：通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots到这个对象不可达）时，则证明此对象时不可用的。</p>

<p>对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p>可以看到，GC Roots在对象图之外，是特别定义的“起点”，不可能被对象图内的对象所引用。</p>
<p>准确地说，GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p>
<p>在Java中，可作为GC Roots的对象包括以下几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。</p>
</li>
<li><p>方法区中类静态属性引用的对象。</p>
</li>
<li><p>方法区中常量引用的对象。</p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
<p>可以概括得出，可作为GC Roots的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为Roots，因此必须选取确定存活的引用类型对象。</p>
<p>GC管理的区域是Java堆，虚拟机栈、方法区和本地方法栈不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是不会被GC所回收的。</p>
<p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。</p>
<p>而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p>
<h4 id="两次标记与finalize-方法"><a href="#两次标记与finalize-方法" class="headerlink" title="两次标记与finalize()方法"></a>两次标记与finalize()方法</h4><p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程：</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finaliza()方法。</p>
<p>当对象没有覆盖finaliza()方法或者finaliza()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finaliza()方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在finaliza()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p>
<p>finaliza()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。如果对象想在finaliza()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，基本上它就真的被回收了</p>
<p>需要说明的是，使用finalize()方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize() 能做的工作，使用try-finally或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。</p>
<hr>
<h3 id="GC-Arithmetic"><a href="#GC-Arithmetic" class="headerlink" title="GC Arithmetic"></a>GC Arithmetic</h3><h4 id="Mark-Sweep-标记-清除"><a href="#Mark-Sweep-标记-清除" class="headerlink" title="Mark-Sweep - 标记-清除"></a>Mark-Sweep - 标记-清除</h4><p>这是最基础的收集算法，顾名思义，算法分为两个阶段：</p>
<ul>
<li>标记：标记处所有需要回收的对象。</li>
<li>清除：统一回收所有被标记的对象。</li>
</ul>
<p>算法缺陷：</p>
<ul>
<li><p>效率问题，标记和清除两个过程的效率不高。</p>
<blockquote>
<p>因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</p>
</blockquote>
</li>
<li><p>空间问题，标记清除之后会产生大量不连续的内存碎片。</p>
<blockquote>
<p>过多的内存碎片可能会造成后续在分配比较大的对象时，无法找到足够的连续内存而不得不提前触发另一次GC。</p>
</blockquote>
</li>
</ul>
<h4 id="Copying-复制"><a href="#Copying-复制" class="headerlink" title="Copying - 复制"></a>Copying - 复制</h4><p>该算法的出现是为了解决Mark-Sweep的效率问题。</p>
<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次性清理掉。</p>
<p>这样每次都只是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。缺点是可用的内存空间缩小了一半。</p>
<h4 id="Mark-Compact-标记-整理"><a href="#Mark-Compact-标记-整理" class="headerlink" title="Mark-Compact - 标记-整理"></a>Mark-Compact - 标记-整理</h4><p>Copying算法在对象存活率较高时就要进行比较多的复制操作，效率将会降低。</p>
<p>更重要的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，提出了Mark-Compact算法，标记过程与Mark-Sweep算法一样，但是清理过程不一样。</p>
<p>Mark-Compact算法的清理过程是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</strong>。</p>

<h4 id="Generational-Collection-分代收集"><a href="#Generational-Collection-分代收集" class="headerlink" title="Generational Collection - 分代收集"></a>Generational Collection - 分代收集</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同进行划分内存块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</p>
<p>在新生代中，每次GC时都发现有大批对象死去，只有少量对象存活下来，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成回收。</p>
<p>在老年代中，因为对象的存活率高，没有额外空间对它进行分配担保，就必须使用Mark-Sweep或者Mark-Compact算法进行回收。</p>
<h4 id="Minor-GC与复制算法"><a href="#Minor-GC与复制算法" class="headerlink" title="Minor GC与复制算法"></a>Minor GC与复制算法</h4><p>现在的商业虚拟机都使用复制算法来回收新生代。新生代的GC又叫“Minor GC”，IBM公司的专门研究表明：新生代中的对象98%是“朝生夕死”的，所以Minor GC非常频繁，一般回收速度也比较快，同时“朝生夕死”的特性也使得Minor GC使用复制算法时不需要按照1:1的比例来划分新生代内存空间。</p>
<p><strong>Minor GC过程</strong></p>
<p>事实上，新生代将内存分为一块较大的Eden空间和两块较小的Survivor空间（From Survivor和To Survivor），每次Minor GC都使用Eden和From Survivor，当回收时，将Eden和From Survivor中还存活着的对象都一次性地复制到另外一块To Survivor空间上，最后清理掉Eden和刚使用的Survivor空间。</p>
<p>一次Minor GC结束的时候，Eden空间和From Survivor空间都是空的，而To Survivor空间里面存储着存活的对象。在下次MinorGC的时候，两个Survivor空间交换他们的标签，现在是空的“From” Survivor标记成为“To”，“To” Survivor标记为“From”。因此，在MinorGC结束的时候，Eden空间是空的，两个Survivor空间中的一个是空的，而另一个存储着存活的对象。</p>
<p>HotSpot虚拟机默认的 Eden:Survivor 的比例是 8:1，由于一共有两块Survivor，所以每次新生代中可用内存空间为整个新生代容量的90%（80%＋10%），只有10%的容量会被“浪费”。</p>
<p><strong>分配担保</strong></p>
<p>上文说的98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代内存进行分配担保（Handle Promotion）。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>
<hr>
<h3 id="GC-Collectors"><a href="#GC-Collectors" class="headerlink" title="GC Collectors"></a>GC Collectors</h3><p>GC需要完成的三件事：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>如果说收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。</p>

<ul>
<li>两个收集器之间存在连线：它们之间可以搭配使用。</li>
<li>虚拟机所处的区域：它属于新生代收集器还是老年代收集器。</li>
</ul>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial是最基本的，发展历史最悠久的Collector，在JDK 1.3.1之前，是虚拟机收集新生代的唯一选择。最适用于内存使用小于100MB的应用程序，这时候不论是CMS或G1都发挥不了太大的作用。</p>
<p>它是一个单线程的Collector，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条线程去完成GC，更重要的是在它进行GC时，必须暂停其他所有的工作线程(应用程序的线程)，直到它GC结束。</p>

<p>单线程是它的劣势，也是它的优势。</p>
<ul>
<li>简单而高效</li>
<li>对于限定单个CPU的环境来说，Serial没有线程交互开销，专心做GC工作自然可以获得最高的单线程GC效率。</li>
<li>在桌面应用场景中，Serial是JVM运行在Client模式下的一个很好的选择。</li>
</ul>
<h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial Old是Serial的老年代版本，同样以单线程GC。它主要用于Client模式。</p>
<p>如果用于Sever模式，一种用途是在JDK 1.5之前版本中与Parallel Scavenge搭配使用，另一种用途就是作为CMS的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>

<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>ParNew其实是Serial的多线程版本，除了以多线程GC外，其余行为和设置与Serial是一样的，比如控制参数(-XX:SuvivorRatio)、收集算法、STW对象分配规则、回收策略等等。</p>

<p>ParNew除了多线程GC之外，其他与Serial相比并没有太多创新之处，但它却是许多运行在Server模式下JVM首选的新生代Collector，其中还有一个与性能无关但很重要的原因是，除了Serial外，目前只有它可以与CMS配合使用。</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>Parallel Scavenge是一个新生代的Collector，它使用的收集算法是Copying，以多线程进行GC。</p>
<p>它的目标是达到一个可控制的吞吐量(Throughput)，CMS是尽可能地缩短在GC时用户线程的停顿时间。</p>
<blockquote>
<p>吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + GC时间)。例如，虚拟机运行100分钟，其中GC花费了1分钟，那么吞吐量就是99%。</p>
</blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>

<p>JVM调优关键参数：</p>
<ul>
<li>-XX:MaxGCPauseMillis：尽可能地保证GC的时间不超过该值。</li>
<li>-XX:GCTimeRatio：范围是0~100，GC时间占总时间的比率。例如，设置为19，即GC时间的最大占比为5%(1 / (1+19))，默认值为99，即GC最大占比为1%(1 / (1+99))</li>
<li>-XX:+UseAdaptiveSizePolicy：不需要手工指定新生代的大小、Eden与Survivor比例、晋升老年代对象年龄等等细节参数，JVM根据当前系统的运行情况进行动态调整这些参数以提供最适合的停顿时间和最大的吞吐量(GC自适应的调节策略 GC Ergonomics)。</li>
</ul>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>Parallel Old是Parallel Scavenger的老年代版本，以多线程GC，使用Mark-Compact算法。</p>

<h4 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS - Concurrent Mark Sweep"></a>CMS - Concurrent Mark Sweep</h4><p>Concurrent Low Pause Collector</p>
<p>CMS是一种期望得到最短GC时间为目标的Collector。CMS是基于Mark-Sweep实现的，整个过程分为以下几个步骤：</p>
<ul>
<li>初始标记(STW) - CMS initial mark，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li>并发标记 - CMS concurrent mark，进行GC Roots Tracing的过程。</li>
<li>重新标记(STW) - CMS remark，为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，一般停顿时间比初始标记长一些，但远比并发标记短。</li>
<li>并发清除 - CMS concurrent sweep</li>
</ul>

<p>整个过程中最耗时的并发标记和并发清除过程都可以与用户线程一起运行。所以，从总体上来说，CMS内存回收过程与用户线程一起并发执行的。</p>
<p>与CMS配合使用的Collector：</p>
<ul>
<li>Young Generation：Serial、ParNew</li>
<li>Tenured Generation：SerialOld</li>
</ul>
<p>CMS缺点：</p>
<ul>
<li>对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分CPU资源而导致应用程序慢，总吞吐量会降低。CMS默认启动的GC线程数为(CPU + 3) / 4。</li>
<li>无法处理浮动垃圾(Floating Garbage)，可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。</li>
<li>空间碎片，因为它是基于Mark-Sweep算法实现的。</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>G1将堆空间划分成了互相独立的区块。每块区域既有可能属于O区、也有可能是Y区，且每类区域空间可以是不连续的（对比CMS的O区和Y区都必须是连续的）。这种将O区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。</p>
<p>G1相对于CMS的区别在：</p>
<ul>
<li>G1在压缩空间方面有优势；</li>
<li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题；</li>
<li>Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活；</li>
<li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象；</li>
<li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做；</li>
<li>G1会在Young GC中使用，而CMS只能在O区使用。</li>
</ul>
<hr>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，它被所有线程共享的，在虚拟机启动时创建。此内存区域唯一的目的是存放对象实例，几乎所有的对象实例都在这里分配内存，且每次分配的空间是不定长的。</p>
<p>在Heap中分配一定的内存来保存对象实例，实际上只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（方法是指令，保存在Stack中），在Heap中分配一定的内存保存对象实例和对象的序列化比较类似。</p>
<p>对象实例在Heap中分配好以后，需要在Stack中保存一个4字节的Heap 内存地址，用来定位该对象实例在Heap中的位置，便于找到该对象实例。</p>
<p>Java虚拟机规范中描述道：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都在堆上分配的定论也并不“绝对”了。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为”GC堆(Garbage Collected Heap)”。从内存回收的角度看内存空间可如下划分：</p>

<ul>
<li>新生代（Young）</li>
</ul>
<p>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。</p>
<p>新生代又可细分为Eden空间、From Survivor空间、To Survivor空间，默认比例为8:1:1。</p>
<ul>
<li>老年代（Tenured/Old）</li>
</ul>
<p>在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</p>
<ul>
<li>永久代（Perm）</li>
</ul>
<p>永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</p>
<p><strong>新生代和老年代组成了Java堆的全部内存区域，而永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong></p>
<h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致OutOfMemoryError异常出现，所以这里放到一起讲解。</p>
<p>以NIO（New Input/Output）类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</p>
<p>Object Class Data(类定义数据)是存储在方法区的，此外，常量、静态变量、JIT编译后的代码也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 Non-Heap。</p>
<ul>
<li>JDK 1.8以前的永久代（PermGen）</li>
</ul>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。</p>
<p>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如Oracle JRockit、IBM J9等）来说是不存在永久代的概念的。</p>
<p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p>
<ol>
<li><p>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</p>
</li>
<li><p>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</p>
</li>
<li><p>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）</p>
</li>
</ol>
<p>这些都会导致方法区溢出，报出java.lang.OutOfMemoryError: PermGen space</p>
<ul>
<li>JDK 1.8的元空间（Metaspace）</li>
</ul>
<p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进HotSpot与 JRockit的融合，修改了方法区的实现，移除了永久代，选择使用本地化的内存空间（而不是JVM的内存空间）存放类的元数据，这个空间叫做元空间（Metaspace）。</p>
<p>做了这个改动以后，java.lang.OutOfMemoryError: PermGen的空间问题将不复存在，并且不再需要调整和监控这个内存空间。</p>
<p>虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。</p>
<p>为了限制垃圾回收的频率和延迟，适当的监控和调优元空间是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p>
<p>元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p>
<p>准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。</p>
<ul>
<li>运行时常量池（Runtime Constant Pool）</li>
</ul>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才能产生，也就是并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，此特性被开发人员利用得比较多的便是String类的intern() 方法。</p>
<hr>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><h3 id="GC-Arithmetic-1"><a href="#GC-Arithmetic-1" class="headerlink" title="GC Arithmetic"></a>GC Arithmetic</h3><p>Conditions：</p>
<ul>
<li>-XX:+UseSerialGC, -XX:+UseParallelGC, -XX:+UseConcMarkSweepGC, -XX:ParallelCMSThreads=2, -XX:ParallelCMSThreads=4, -XX:+UseG1GC</li>
<li>每次运行大概花55分钟</li>
<li>-Xmx2048M -server</li>
<li>OpenJDK version: 1.8.0_51</li>
<li>Software: Linux version 4.0.4-301.fc22.x86_64</li>
<li>Hardware: Intel® Core™ i7-4790 CPU @ 3.60GHz</li>
<li>每次通过optaplanner解决13个问题，每个问题大概5分钟，并且前30秒的JVM预热时间不计算在内。</li>
<li>解决问题时不会发生IO，运行过程中，单个CPU完全饱和，并且会一直创建很多生命周期很短的对象，然后GC负责收集它们。</li>
<li>基准测试测量每毫秒能被计算的分数，越高表示越好。需要说明的是，计算一个分数可不是一件容易的事情，它涉及很多计算，有兴趣的话，可以去optaplanner查看它们的源码。</li>
</ul>
<hr>

<p>结果非常清晰，JDK8默认的ParallelGC是最快的，其他垃圾回收器相比默认的ParallelGC都会有不同程度的衰减，并且G1表现最差，是最慢的。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="noopener">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a><br><a href="http://blog.jobbole.com/109170/" target="_blank" rel="noopener">http://blog.jobbole.com/109170/</a><br><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a><br><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://mp.weixin.qq.com/s/2H2ce_n2NQXWxueImpKaMA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2H2ce_n2NQXWxueImpKaMA</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref5" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref5</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/30/Java/JVM/Case/Check-CPU-Overload/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/Java/JVM/Case/Check-CPU-Overload/" itemprop="url">Check CPU Overload</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T17:31:22+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>Problem Code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"PID: $&#123;ManagementFactory.getRuntimeMXBean().name&#125;"</span>)</span><br><span class="line">val random = Random(System.currentTimeMillis())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    random.nextInt() * random.nextInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Top-CPU"><a href="#Top-CPU" class="headerlink" title="Top CPU"></a>Top CPU</h4><ul>
<li>Mac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top -o cpu</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">- Linux</span><br><span class="line">``` bash</span><br><span class="line">top -c</span><br><span class="line"><span class="comment">#显示进程运行信息列表。按下P,进程按照cpu使用率排序</span></span><br><span class="line"></span><br><span class="line">top -Hp pid</span><br><span class="line"><span class="comment">#显示一个进程的线程运行信息列表。按下P,进程按照cpu使用率排序</span></span><br><span class="line"></span><br><span class="line">cat pid.stack | grep <span class="string">'ThreadId'</span> -C 8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Dump-Process-Stack"><a href="#Dump-Process-Stack" class="headerlink" title="Dump Process Stack"></a>Dump Process Stack</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l PID &gt; pid.stack</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.181-b13 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">"Attach Listener"</span> <span class="comment">#11 daemon prio=9 os_prio=31 tid=0x00007ff4cf882800 nid=0x5903 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Service Thread"</span> <span class="comment">#10 daemon prio=9 os_prio=31 tid=0x00007ff4d2838000 nid=0x5703 runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C1 CompilerThread3"</span> <span class="comment">#9 daemon prio=9 os_prio=31 tid=0x00007ff4d2047800 nid=0x5503 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread2"</span> <span class="comment">#8 daemon prio=9 os_prio=31 tid=0x00007ff4d2047000 nid=0x4003 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread1"</span> <span class="comment">#7 daemon prio=9 os_prio=31 tid=0x00007ff4d2046000 nid=0x3e03 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread0"</span> <span class="comment">#6 daemon prio=9 os_prio=31 tid=0x00007ff4cf842800 nid=0x3c03 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Monitor Ctrl-Break"</span> <span class="comment">#5 daemon prio=5 os_prio=31 tid=0x00007ff4cf839000 nid=0x3a03 runnable [0x0000700005020000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	- locked &lt;0x000000071584d860&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	- locked &lt;0x000000071584d860&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMainV2<span class="variable">$1</span>.run(AppMainV2.java:64)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Signal Dispatcher"</span> <span class="comment">#4 daemon prio=9 os_prio=31 tid=0x00007ff4d2816800 nid=0x4303 runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Finalizer"</span> <span class="comment">#3 daemon prio=8 os_prio=31 tid=0x00007ff4cf818000 nid=0x4b03 in Object.wait() [0x0000700004e1a000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000715588ed0&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">	- locked &lt;0x0000000715588ed0&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">	at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Reference Handler"</span> <span class="comment">#2 daemon prio=10 os_prio=31 tid=0x00007ff4d0807000 nid=0x3503 in Object.wait() [0x0000700004d17000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000715586bf8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">	- locked &lt;0x0000000715586bf8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007ff4d0006800 nid=0x2703 runnable [0x00007000040f3000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt:9)</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> os_prio=31 tid=0x00007ff4cf007000 nid=0x4c03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#0 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf006000 nid=0x1f07 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#1 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4d000f800 nid=0x2a03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#2 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf803000 nid=0x2c03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#3 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf804000 nid=0x5303 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#4 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf804800 nid=0x2d03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#5 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf805000 nid=0x5003 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#6 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf805800 nid=0x4f03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#7 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4d0802800 nid=0x4e03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#8 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf806800 nid=0x3103 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#9 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf807000 nid=0x4d03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> os_prio=31 tid=0x00007ff4cf845800 nid=0xa803 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 15</span><br></pre></td></tr></table></figure>
<p>抽出关键部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007ff4d0006800 nid=0x2703 runnable [0x00007000040f3000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt:9)</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>
<p>其中 nid=0x2703 是线程ID号，换算成十进制是9987</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://wsgzao.github.io/post/htop/" target="_blank" rel="noopener">https://wsgzao.github.io/post/htop/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/30/Java/Math/Double/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/Java/Math/Double/" itemprop="url">Java Double</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T16:01:22+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="number">1f</span></span><br><span class="line">val b = <span class="number">0.9f</span></span><br><span class="line">val r = a - b</span><br><span class="line">println(r)  <span class="comment">//  0.100000024</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么会出现这个误差？</strong>接下来我们一步一步解答这个问题。</p>
<h4 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h4><p>在数学中，采用科学计数法来近似表示一个极大或极小且位数较多的数。</p>
<img src="/2019/04/30/Java/Math/Double/scientific_notation.png">
<p>科学计数法组成部分：</p>
<ul>
<li>有效数字：从第1个非零数字开始的全部数字；</li>
<li>指数：决定小数点的位置；</li>
<li>符号：表示正负数。</li>
</ul>
<p>科学计数法可以唯一的表示任何一个数字，且所占用的存储空间会更少。浮点数表示方式：</p>
<img src="/2019/04/30/Java/Math/Double/float_component.png">
<hr>
<p>存储时的组成部分：</p>
<img src="/2019/04/30/Java/Math/Double/store_component.png">
<p>Float类型的内存分布：</p>
<img src="/2019/04/30/Java/Math/Double/float_type_memory_component.png">
<p>Double类型的内存分布：</p>
<img src="/2019/04/30/Java/Math/Double/double_type_memory_component.png">
<hr>
<p>目前业界流行的浮点数标准是 IEEE754，规定了4种浮点数类型：</p>
<ul>
<li>单精度</li>
<li>双精度</li>
<li>延伸单精度</li>
<li>延伸双精度</li>
</ul>
<blockquote>
<p>其中前两种类型是最常用的。</p>
</blockquote>
<img src="/2019/04/30/Java/Math/Double/float_precision.png" title="单双精度取值范围">
<h4 id="单精度"><a href="#单精度" class="headerlink" title="单精度"></a>单精度</h4><img src="/2019/04/30/Java/Math/Double/single_float_format.png">
<p>数制从十进制到二进制，还要考虑内存硬件设备的实现方式。指数称为”阶码”，有效数字称为”尾数”。所以用于存储符号、阶码、尾数的二进制位分别称为符号位、阶码位、尾数位。</p>
<ol>
<li>符号位</li>
</ol>
<p>在最高二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数。</p>
<ol start="2">
<li>阶码位</li>
</ol>
<p>在符号位右侧分配8位用来存储指数，IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。</p>
<ol start="3">
<li>尾数位</li>
</ol>
<p>最右侧分配连续的23位用来存储有效数字，IEEE754 标准规定尾数以原码表示。</p>
<p>正指数和有效数字的最大值决定了32位存储空间能够表示浮点数的十进制最大值。</p>
<p>指数最大值为2^127 约等于 1.7 x 10^38。</p>
<p>有效数字部分最大值是二进制的 1.11···1(小数点后23个1)，是个无限接近于2的数字，所以得到最大的十进制数为2 × 1.7 × 10^38，再加上最左1位的符号，最终得到32位浮点数最大值为 3.4e+38。</p>
<img src="/2019/04/30/Java/Math/Double/decimal_binary_format.png">
<h4 id="为什么8位阶码的偏置为127？"><a href="#为什么8位阶码的偏置为127？" class="headerlink" title="为什么8位阶码的偏置为127？"></a>为什么8位阶码的偏置为127？</h4><p>8位移码的取值范围为0~255（00000000~11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。</p>
<p>8位有符号数取值范围为-128~+127（10000000~01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。</p>
<p>如果采用偏置128，在表达+127(2的7次方=127)时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。</p>
<h4 id="原码、补码、反码"><a href="#原码、补码、反码" class="headerlink" title="原码、补码、反码"></a>原码、补码、反码</h4><p>计算机保存最原始的数字，不区分正负数，即无符号数字。如果我们在内存分配4位(bit)去存放无符号数字，是下面这样子的：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
</tr>
</tbody>
</table>
<p>后来在生活中为了表示“欠别人钱”这个概念，就从无符号数中，划分出了“正数”和“负数”。<strong>为了表示正与负，人们发明了”原码”，把生活应该有的正负概念，原原本本的表示出来。</strong></p>
<table>
<thead>
<tr>
<th>正数</th>
<th>二进制</th>
<th>负数</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>-0</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>-1</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>-2</td>
<td>1010</td>
</tr>
</tbody>
</table>
<p>但使用“原码”储存的方式，方便了看的人类，却苦了计算机。们希望(+1)和(-1)相加是0，但计算机只能算出0001+1001=1010(-2)，这个结果并不是我们想要的。此外，0的表示有两种方式：+0 和 -0。</p>
<p><strong>为了解决”正负相加等于0”的问题，在”原码”的基础上，人们发明了”反码”。</strong>“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反：</p>
<img src="/2019/04/30/Java/Math/Double/fan_ma_vs_yuan_ma.png">
<p>当“原码”变成“反码”时，完美的解决了“正负相加等于0”的问题。+1 和 -1 相加，变成了0001 + 1101 = 1111，刚好反码表示方式中，1111象征-0。</p>
<p>人们总是进益求精，历史遗留下来的问题—— 有两个零存在：+0 和 -0，我们希望只有一个0，所以发明了”补码”，同样是针对”负数”做处理的。</p>
<p>“补码”的意思是，从原来”反码”的基础上，补充一个新的代码：+1。</p>
ß<br><br>有得必有失，在补一位1的时候，要丢掉最高位。<br><br>我们要处理”反码”中的”-0”，当1111再补上一个1之后，变成了10000，丢掉最高位就是0000，刚好和左边正数的0相同。<br><br>这样就解决了+0和-0同时存在的问题，另外”正负数相加等于0”的问题，同样得到满足：<br><br>例如，3 和 -3 相加，0011 + 1101 = 10000，丢掉最高位，就是0000(0)。<br><br>同样有失必有得，我们失去了-0，收获了-8。<br><br><br><br>#### Range<br><br><strong>基本类型：int 二进制位数：32</strong><br>包装类：java.lang.Integer<br>最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）<br>最大值：Integer.MAX_VALUE= 2147483647  （2的31次方-1）<br><br><strong>基本类型：short 二进制位数：16</strong><br>包装类：java.lang.Short<br>最小值：Short.MIN_VALUE=-32768 （-2的15此方）<br>最大值：Short.MAX_VALUE=32767 （2的15次方-1）<br><br><strong>基本类型：long 二进制位数：64</strong><br>包装类：java.lang.Long<br>最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）<br>最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）<br><br><strong>基本类型：float 二进制位数：32</strong><br>包装类：java.lang.Float<br>最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方）<br>最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1）<br><br><strong>基本类型：double 二进制位数：64</strong><br>包装类：java.lang.Double<br>最小值：Double.MIN_VALUE=4.9E-324 （2的-1074次方）<br>最大值：Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）<br><br><br><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>### Memory Usage<br><br>- Double: 8 Byte，range(1.4E-45 ~ 3.4028235E38)<br>- Float: 4 Byte，range(4.9E-324 ~ 1.7976931348623157E308)<br><br><br><br><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>### Comparison<br><br>#### Check whether value is zero<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> threshold)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt;= -threshold &amp;&amp; value &lt;= threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Case-Simple-comparison"><a href="#Case-Simple-comparison" class="headerlink" title="Case - Simple comparison"></a>Case - Simple comparison</h4><p>First look at the simple comparison to understand what exactly is wrong with comparing double with == operator. In given program, I am creating same floating point number (i.e. 1.1) using two methods:</p>
<ul>
<li>Add .1, 11 times.</li>
<li>Multiply .1 to 11.</li>
</ul>
<p>In theory, both operations should produce the number 1.1. And when we compare the results of both methods, it should match.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Method 1</span></span><br><span class="line">var f1 = .<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 += .<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  It's acutally 1.1</span></span><br><span class="line"><span class="comment">//  f1 is computed to 1.0999999999999999. Its exactly the problem which rounding off causes internally. </span></span><br><span class="line"><span class="comment">//  That’s why, floating point comparison with '==' operator is not recommended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Method 2</span></span><br><span class="line">val f2 = .<span class="number">1</span> * <span class="number">11</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1 == f2 -&gt; $&#123;f1 == f2&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.0999999999999999, f2 1.1</span><br><span class="line">f1 == f2 -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Use BigDecimal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1</span></span><br><span class="line">var f1 = BigDecimal(<span class="string">"0.0"</span>)</span><br><span class="line">val pointOne = BigDecimal(<span class="string">"0.1"</span>)</span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 = f1.add(pointOne)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2</span></span><br><span class="line">var f2 = BigDecimal(<span class="string">"0.1"</span>)</span><br><span class="line">val eleven = BigDecimal(<span class="string">"11"</span>)</span><br><span class="line">f2 = f2.multiply(eleven)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1.compareTo(f2) -&gt; $&#123;f1.compareTo(f2) == 0&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.1, f2 1.1</span><br><span class="line">f1.compareTo(f2) -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Case-Threshold-based-comparison-lt-—-Recommended"><a href="#Case-Threshold-based-comparison-lt-—-Recommended" class="headerlink" title="Case - Threshold based comparison &lt;— Recommended"></a>Case - Threshold based comparison &lt;— Recommended</h4><p>Using programming, we cannot change the way these floating point numbers are stored or computed. So we have to adapt a solution where we agree that a determine the differences in both values which we can tolerate and still consider the numbers equal. This agreed upon difference in values is called the <strong>threshold</strong> or <strong>epsilon</strong>.</p>
<p>So now to use ‘threshold based floating point comparison‘, we can use the Math.abs() method to compute a difference between the two numbers and compare the difference to a threshold value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val threshold = <span class="number">0.0001</span></span><br><span class="line"><span class="comment">//Method 1</span></span><br><span class="line">var f1 = .<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 += .<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2</span></span><br><span class="line">val f2 = .<span class="number">1</span> * <span class="number">11</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1 == f2 -&gt; $&#123;Math.abs(f1 - f2) &lt; threshold&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.0999999999999999, f2 1.1</span><br><span class="line">f1 == f2 -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Case-Compare-with-BigDecimal-lt-—-Recommended"><a href="#Case-Compare-with-BigDecimal-lt-—-Recommended" class="headerlink" title="Case - Compare with BigDecimal &lt;— Recommended"></a>Case - Compare with BigDecimal &lt;— Recommended</h4><p>In BigDecimal class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved.</p>
<p>Best part is that BigDecimal numbers are <strong>immutable</strong> i.e. if you create a BigDecimal BD with value “1.23”, that object will remain “1.23” and can never be changed. This class provide many methods which can be used to do numerical operations on it’s value.</p>
<p>You can use it’s <strong>compareTo()</strong> method to compare to BigDecimal numbers. It ignore the scale while comparing.</p>
<blockquote>
<p>Special Note：Never use the equals() method to compare BigDecimal instances. That is because this equals function will compare the scale. If the scale is different, equals() will return false, even if they are the same number mathematically.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a = BigDecimal(<span class="string">"2.00"</span>)</span><br><span class="line">val b = BigDecimal(<span class="string">"2.0"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"a == b --&gt; $&#123;a == b&#125;"</span>)</span><br><span class="line">println(<span class="string">"a.compareTo(b) --&gt; $&#123;a.compareTo(b) == 0&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b --&gt; <span class="literal">false</span></span><br><span class="line">a.compareTo(b) --&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="NaN-and-INFINITY"><a href="#NaN-and-INFINITY" class="headerlink" title="NaN and INFINITY"></a>NaN and INFINITY</h3><ul>
<li>Once a NaN always a NaN</li>
<li>Double.MAX_VALUE overflow into POSITIVE_INFINITY, The same goes for Double.MIN_VALUE except that it will overflow to Double.NEGATIVE_INFINITY.</li>
</ul>
<p>NaN(Not a Number，非数)是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。</p>
<p>返回NaN的运算：</p>
<ul>
<li><p>至少有一个參数是NaN的运算；</p>
</li>
<li><p>不定式：</p>
</li>
<li><ul>
<li>除法运算：0/0、∞/∞、∞/(−∞)、(−∞)/∞、(−∞)/(−∞)</li>
</ul>
</li>
<li><ul>
<li>乘法运算：0×∞、0×−∞</li>
</ul>
</li>
<li><ul>
<li>加法运算：∞ + (−∞)、(−∞) + ∞</li>
</ul>
</li>
<li><ul>
<li>减法运算：∞ - ∞、(−∞) - (−∞)</li>
</ul>
</li>
<li><ul>
<li>指數運算：0^0、∞^0、1^∞、∞^(−∞)</li>
</ul>
</li>
<li><p>产生复数结果的实数运算：对负数进行开偶次方的运算；对负数（包含−∞）进行对数运算；对正弦或餘弦到达域以外的数进行反正弦或反餘弦运算；</p>
</li>
</ul>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = Math.sqrt(-<span class="number">1.0</span>)</span><br><span class="line">println(<span class="string">"Math.sqrt(-1.0) -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"Double.NaN == result -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(-1.0) -&gt; NaN</span><br><span class="line">Double.NaN == result -&gt; <span class="literal">true</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="NEGATIVE-INFINITY"><a href="#NEGATIVE-INFINITY" class="headerlink" title="NEGATIVE_INFINITY"></a>NEGATIVE_INFINITY</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = -Double.MAX_VALUE * Double.MAX_VALUE</span><br><span class="line">println(<span class="string">"Double.MAX_VALUE * Double.MAX_VALUE -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"Double.NaN == result -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Double.MAX_VALUE * Double.MAX_VALUE -&gt; -Infinity</span><br><span class="line">Double.NaN == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">true</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="POSITIVE-INFINITY"><a href="#POSITIVE-INFINITY" class="headerlink" title="POSITIVE_INFINITY"></a>POSITIVE_INFINITY</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = <span class="number">5.0</span> / <span class="number">0</span></span><br><span class="line">println(<span class="string">"5.0 / 0 -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"isNaN -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5.0 / 0 -&gt; Infinity</span><br><span class="line">isNaN -&gt; <span class="literal">false</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://blog.csdn.net/a327369238/article/details/52354811" target="_blank" rel="noopener">https://blog.csdn.net/a327369238/article/details/52354811</a></li>
<li><a href="https://howtodoinjava.com/java/basics/correctly-compare-float-double/" target="_blank" rel="noopener">https://howtodoinjava.com/java/basics/correctly-compare-float-double/</a></li>
<li><a href="https://www.avocado.com.au/resources/tech-tips/java-double-nan-weirdness/" target="_blank" rel="noopener">https://www.avocado.com.au/resources/tech-tips/java-double-nan-weirdness/</a></li>
<li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">https://www.zhihu.com/question/20159860</a></li>
<li><a href="https://blog.51cto.com/zangyanan/1854836" target="_blank" rel="noopener">https://blog.51cto.com/zangyanan/1854836</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Case/CustomClassLoader造成YGC越来越慢/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Case/CustomClassLoader造成YGC越来越慢/" itemprop="url">CustomClassLoader造成YGC越来越慢，为什么？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T23:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://lovestblog.cn/blog/2016/03/15/ygc-classloader/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2016/03/15/ygc-classloader/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/" itemprop="url">StringTable造成YGC越来越慢，为什么？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T21:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringYGC</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getUUID</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().intern()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val stringYGC = StringYGC()</span><br><span class="line">    val times = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1</span>..times) &#123;</span><br><span class="line">        stringYGC.getUUID()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM Options：-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xmx2G -Xms2G -Xmn100M</p>
<p>这里特意将新生代设置比较小，老生代设置比较大，让代码在执行过程中更容易突出问题来，大量做ygc，期间不做CMS GC。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8306K(92160K), 0.0087308 secs] 81920K-&gt;8306K(2086912K), 0.0087759 secs] [Times: user=0.06 sys=0.01, real=0.01 secs]</span><br><span class="line">.....</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10240K(92160K), 0.1632875 secs] 1089021K-&gt;1017720K(2086912K), 0.1633312 secs] [Times: user=1.51 sys=0.02, real=0.16 secs]</span><br></pre></td></tr></table></figure>
<p>从输出的Log来看，发现YGC不断发生，并且每次YGC时间不断在增长，从9ms慢慢增长到了163ms，甚至还会继续涨下去。原因是什么？</p>
<hr>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>我们先来了解下intern方法的实现，这是String提供的一个方法，JVM提供这个方法的目的是希望对于某个同名字符串使用非常多的场景，在JVM里只保留一份，比如我们不断new String(“Hello”)，其实在java heap里会有多个String的对象，并且值都是Hello，如果我们只希望内存里只保留一个Hello，或者希望我接下来用到的地方都返回同一个Hello，那就可以用String.intern这个方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val h1 = <span class="string">"Hello"</span>.intern()</span><br><span class="line">val h2 = h1.intern()</span><br></pre></td></tr></table></figure>
<p>这样 h1 和 h2 都是指向内存里的同一个String对象，那JVM里到底怎么做到的呢？</p>
<p>intern这个方法其实是一个native方法，具体对应到JVM里的逻辑是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">oop StringTable::intern(oop <span class="built_in">string</span>, TRAPS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="function">Handle <span class="title">h_string</span> <span class="params">(THREAD, <span class="built_in">string</span>)</span></span>;</span><br><span class="line">  jchar* chars = java_lang_String::as_unicode_string(<span class="built_in">string</span>, length);</span><br><span class="line">  oop result = intern(h_string, chars, length, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = hash_string(name, len);</span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Found</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) <span class="keyword">return</span> found_string;</span><br><span class="line"></span><br><span class="line">  debug_only(StableMemoryChecker smc(name, len * <span class="keyword">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  assert(!Universe::heap()-&gt;is_in_reserved(name) || GC_locker::is_active(),</span><br><span class="line">         <span class="string">"proposed name of symbol must be stable"</span>);</span><br><span class="line"></span><br><span class="line">  Handle <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.is_null() &amp;&amp; (!JavaObjectsInPerm || string_or_null()-&gt;is_perm())) &#123;</span><br><span class="line">    <span class="built_in">string</span> = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> = java_lang_String::create_tenured_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table</span></span><br><span class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, <span class="built_in">string</span>, name, len,</span><br><span class="line">                                hashValue, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在JVM里存在一个叫做StringTable的数据结构，这个数据结构是一个Hashtable，在我们调用String.intern的时候其实就是先去这个StringTable里查找是否存在一个同名的项，如果存在就直接返回对应的对象，否则就往这个table里插入一项，指向这个String对象，那么再下次通过intern再来访问同名的String对象的时候，就会返回上次插入的这一项指向的String对象。</p>
<blockquote>
<p>JVM里提供一个参数专门来控制这个table的size，-XX:StringTableSize，既然有这个参数，那么意味着StringTable是size是固定的。</p>
</blockquote>
<p>当发生Hash碰撞的时候，你就要对其对应的桶挨个遍历，超过了100个还是没有找到对应的同名的项，那就会设置一个flag，让下次进入到safepoint的时候做一次rehash动作，尽量减少碰撞的发生，但是当恶化到一定程度的时候，其实也没啥办法啦，因为你的数据量实在太大，桶子数就那么多，那每个桶再怎么均匀也会带着一个很长的链表，所以此时我们通过修改上面的StringTableSize将桶数变大，可能会一定程度上缓解，但是如果是java代码的问题导致泄露，那就只能定位到具体的代码进行改造了。</p>
<blockquote>
<p>在JDK6及之前的版本，字符串常量池是放在Perm Gen（也就是方法区）中。<br>在JDK7版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。</p>
</blockquote>
<hr>
<h3 id="StringTable为什么会影响YGC"><a href="#StringTable为什么会影响YGC" class="headerlink" title="StringTable为什么会影响YGC"></a>StringTable为什么会影响YGC</h3><p>YGC中对StringTable处理的具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_process_strong_tasks-&gt;is_task_claimed(SH_PS_StringTable_oops_do)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (so &amp; SO_Strings || (!collecting_perm_gen &amp;&amp; !JavaObjectsInPerm)) &#123;</span><br><span class="line">        <span class="comment">//  actually, invoke here</span></span><br><span class="line">        StringTable::oops_do(roots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (JavaObjectsInPerm) &#123;</span><br><span class="line">      <span class="comment">// Verify the string table contents are in the perm gen</span></span><br><span class="line">      NOT_PRODUCT(StringTable::oops_do(&amp;assert_is_perm_closure));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为YGC过程不涉及到对perm做回收，因此collecting_perm_gen是false，而JavaObjectsInPerm默认情况下也是false，表示String.intern返回的字符串是不是在perm里分配，如果是false，表示是在heap里分配的，因此StringTable指向的字符串是在heap里分配的，所以YGC过程需要对StringTable做扫描，以保证处于新生代的String代码不会被回收掉。</p>
<p>设想一下如果StringTable非常庞大，那是不是意味着YGC过程扫描的时间也会变长呢？这也就是解释了为什么StringTable会影响YGC了，</p>
<p>另外一个问题是StringTable什么时候清理？</p>
<p>YGC过程不会对StringTable做清理，这也就是我们demo里的情况会让Stringtable越来越大，但是在FGC或者CMS GC的过程中会对StringTable进行清理。</p>
<blockquote>
<p>如何证明？命令 jmap -histo:live <pid> 触发FGC</pid></p>
</blockquote>
<hr>
<h3 id="输出SringTable统计信息"><a href="#输出SringTable统计信息" class="headerlink" title="输出SringTable统计信息"></a>输出SringTable统计信息</h3><p>JVM Option：-XX:+PrintStringTableStatistics</p>
<p>Testing Code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringYGC</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getUUID</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().intern()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val stringYGC = StringYGC()</span><br><span class="line">    val times = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1</span>..times) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == times / <span class="number">2</span>) &#123;</span><br><span class="line">            System.exit(<span class="number">9</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        stringYGC.getUUID()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GC日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8477K(92160K), 0.0069494 secs] 81920K-&gt;8477K(2086912K), 0.0069858 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br><span class="line">....</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10238K(92160K), 0.0846080 secs] 611372K-&gt;540071K(2086912K), 0.0846461 secs] [Times: user=0.80 sys=0.02, real=0.09 secs]</span><br></pre></td></tr></table></figure>
<p>SymbolTable statistics：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :   5002671 = 120064104 bytes, avg  24.000</span><br><span class="line">Number of literals      :   5002671 = 560195376 bytes, avg 111.979</span><br><span class="line">Total footprint         :           = 680739584 bytes</span><br><span class="line">Average bucket size     :    83.360</span><br><span class="line">Variance of bucket size :    83.687</span><br><span class="line">Std. dev. of bucket size:     9.148</span><br><span class="line">Maximum bucket size     :       130</span><br></pre></td></tr></table></figure>
<ul>
<li>Average bucket size：bucket中LinkedList的平均size。</li>
<li>Maximum bucket size：表示bucket中LinkedList最大的size。</li>
<li>Number of entries：Hashtable的entry数量。</li>
<li>Number of buckets：bucket数量。 </li>
</ul>
<p>Average bucket size越大，说明Hashtable碰撞越严重，由于bucket数量固定为60013，随着StringTable添加的引用越来越多，碰撞越来越严重，YGC时间越来越长。</p>
<h4 id="Comparing-Testing"><a href="#Comparing-Testing" class="headerlink" title="Comparing Testing"></a>Comparing Testing</h4><p>GC日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8819K(92160K), 0.0083969 secs] 81920K-&gt;8819K(2086912K), 0.0084334 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]</span><br><span class="line">...</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10238K(92160K), 0.0611064 secs] 609735K-&gt;538845K(2086912K), 0.0611351 secs] [Times: user=0.57 sys=0.01, real=0.06 secs]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :   2500000 =  20000000 bytes, avg   8.000</span><br><span class="line">Number of entries       :   5002673 = 120064152 bytes, avg  24.000</span><br><span class="line">Number of literals      :   5002673 = 560195520 bytes, avg 111.979</span><br><span class="line">Total footprint         :           = 700259672 bytes</span><br><span class="line">Average bucket size     :     2.001</span><br><span class="line">Variance of bucket size :     2.002</span><br><span class="line">Std. dev. of bucket size:     1.415</span><br><span class="line">Maximum bucket size     :        11</span><br></pre></td></tr></table></figure>
<p>对比上面的结果，Average bucket size降低很明显。</p>
<p>设置StringTableSize一个合适的值，即bucket数量为期望的数量后，碰撞的概率明显降低，由Average bucket size和Maximum bucket size的值明显小于未配置StringTableSize参数时的值可知，且YGC时间也明显降低。另外, 最好通过BTrace分析是哪里频繁调用String.intern(), 确实String.intern()没有滥用的前提下, 再增大StringTableSize的值。</p>
<hr>
<h3 id="为什么StringTable不能扩大？"><a href="#为什么StringTable不能扩大？" class="headerlink" title="为什么StringTable不能扩大？"></a>为什么StringTable不能扩大？</h3><p>既然StringTable是Hashtable数据结构，那为什么不能自己通过rehash扩大bucket数量来提高性能呢？JVM中StringTable的rehash有点不一样，JVM中StringTable的rehash不会扩大bucket数量，而是在bucket不变的前提下，通过一个新的seed尝试摊平每个bucket中LinkedList的长度。</p>
<p>rehash大概是一个如下图所示的过程，rehash前后bucket数量不变，这是重点：</p>
<p>假设reash前数据分布(23，4，8，2，1，5)<br><img src="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/refresh_before.png"></p>
<p>假设reash前数据分布(6，8，8，9，5，7)<br><img src="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/refresh_after.png"></p>
<hr>
<h3 id="Disable-Jackson-String-intern"><a href="#Disable-Jackson-String-intern" class="headerlink" title="Disable Jackson String.intern"></a>Disable Jackson String.intern</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  com.fasterxml.jackson.core.util.InternCache.intern(InternCache.java:45)</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = input.intern();</span><br><span class="line">    put(result, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jackson之所以用intern去处理，本来是想节省点cache的内存，没想到业务场景是每次都不一样的字符串，这样直接就导致了String.intern后StringTable的大小暴涨，所以在这种场景中，这样做反而得不偿失，还好jackson代码支持通过接口来把调用intern的部分关掉。</p>
<p><strong>CANONICALIZE_FIELD_NAMES (default: true)</strong></p>
<ul>
<li>Means that once name String is decoded from input (byte or char stream), it will be added in a symbol table, to reduce overhead of decoding same name next time it is seen (by any parser constructed by same factory)</li>
</ul>
<p><strong>INTERN_FIELD_NAMES (default: true)</strong></p>
<ul>
<li>If canonicalization is enabled, this feature determines whether String decoded is also interned (using String.intern()) or not – doing that can help further improve deserialization performance since identity comparison may be used.</li>
<li>If names are unlikely to repeat, or if sheer number of distinct names is huge (in tens of thousands or above), it may make sense to disable this feature.</li>
</ul>
<p>Disable using String.intern() method：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val factory = JsonFactory().disable(JsonFactory.Feature.INTERN_FIELD_NAMES)</span><br><span class="line">val mapper = ObjectMapper(factory).setTimeZone(TimeZone.getDefault())</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://lovestblog.cn/blog/2016/11/06/string-intern/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2016/11/06/string-intern/</a><br><a href="https://juejin.im/post/5ab99afff265da23a2291dee" target="_blank" rel="noopener">https://juejin.im/post/5ab99afff265da23a2291dee</a><br>Refresh：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a><br><a href="https://www.jianshu.com/p/5524fce8b08f" target="_blank" rel="noopener">https://www.jianshu.com/p/5524fce8b08f</a><br><a href="http://hellojava.info/?p=514" target="_blank" rel="noopener">http://hellojava.info/?p=514</a><br>Jackson触发的String.intern()：<a href="https://www.cnblogs.com/halberts/p/7473857.html" target="_blank" rel="noopener">https://www.cnblogs.com/halberts/p/7473857.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Case/排查JVM的线程卡死/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Case/排查JVM的线程卡死/" itemprop="url">排查JVM的线程卡死</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T21:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Thread-Status"><a href="#Thread-Status" class="headerlink" title="Thread Status"></a>Thread Status</h3><ul>
<li>NEW</li>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
<li>TERMINATED</li>
</ul>
<hr>
<h3 id="Practice-jstack"><a href="#Practice-jstack" class="headerlink" title="Practice - jstack"></a>Practice - jstack</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jstack -l pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制打印堆栈信息到标准输出，如果使用 jstack PID 没有响应的情况下(此时 JVM 进程可能挂起)，加 -F 参数</span></span><br><span class="line">jstack -F pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># -heap 参数用于查看指定 JVM 进程的堆的信息，包括堆的各个参数的值，堆中新生代、年老代的内存大小、使用率等</span></span><br><span class="line">jmap -heap PID</span><br><span class="line">jmap -F -heap PID</span><br></pre></td></tr></table></figure>
<blockquote>
<p>-l：long listing. Prints additional information about locks</p>
</blockquote>
<p>此时输出的日志如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-<span class="number">06</span>-<span class="number">15</span> <span class="number">08</span>:<span class="number">51</span>:<span class="number">29</span></span><br><span class="line"><span class="function">Full thread dump Java <span class="title">HotSpot</span><span class="params">(TM)</span> 64-Bit Server <span class="title">VM</span> <span class="params">(<span class="number">25.192</span>-b12 mixed mode)</span>:</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">"Disruptor-1" #31 prio</span>=<span class="number">10</span> os_prio=<span class="number">0</span> tid=<span class="number">0x00007f3fad4d2800</span> nid=<span class="number">0x39</span> runnable [<span class="number">0x00007f3ece5fa000</span>]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.lmax.disruptor.BusySpinWaitStrategy.waitFor(BusySpinWaitStrategy.java:<span class="number">39</span>)</span><br><span class="line">	at com.lmax.disruptor.ProcessingSequenceBarrier.waitFor(ProcessingSequenceBarrier.java:<span class="number">56</span>)</span><br><span class="line">	at com.lmax.disruptor.BatchEventProcessor.processEvents(BatchEventProcessor.java:<span class="number">159</span>)</span><br><span class="line">	at com.lmax.disruptor.BatchEventProcessor.run(BatchEventProcessor.java:<span class="number">125</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"main/queue-thread-local-cleaner-daemon" #29 daemon prio=5 os_prio=0 tid=0x00007f3fad4be000 nid=0x38 runnable [0x00007f3ee41f8000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000007b145e200</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">215</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:<span class="number">2078</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">1093</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">809</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1074</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1134</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"chronicle-weak-reference-cleaner" #28 daemon prio=5 os_prio=0 tid=0x00007f3fad476800 nid=0x37 in Object.wait() [0x00007f3ee42f9000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">144</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000007b1fd3910</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">	at net.openhft.chronicle.core.util.WeakReferenceCleaner$ReferenceProcessor.run(WeakReferenceCleaner.java:<span class="number">101</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1149</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- &lt;<span class="number">0x00000007b1fe43f0</span>&gt; (a java.util.concurrent.ThreadPoolExecutor$Worker)</span><br><span class="line"></span><br><span class="line">"MyPerf4J-BackgroundExecutor_0" #17 prio=5 os_prio=0 tid=0x00007f3f04002800 nid=0x2d waiting on condition [0x00007f3f1d3bc000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000004d52001f8</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">	at java.util.concurrent.LinkedBlockingQueue.take(LinkedBlockingQueue.java:<span class="number">442</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1074</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1134</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"MyPerf4J-LightWeightScheduler-1" #9 prio=5 os_prio=0 tid=0x00007f3f00001000 nid=0x26 waiting on condition [0x00007f3f1e4f6000]</span><br><span class="line">   java.lang.Thread.State: WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000004d5200bf0</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.park(LockSupport.java:<span class="number">175</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await(AbstractQueuedSynchronizer.java:<span class="number">2039</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">1088</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">809</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1074</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1134</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"MyPerf4J-LightWeightScheduler-0" #8 prio=5 os_prio=0 tid=0x00007f3face7c800 nid=0x25 runnable [0x00007f3f1e5f7000]</span><br><span class="line">   java.lang.Thread.State: TIMED_WAITING (parking)</span><br><span class="line">	at sun.misc.Unsafe.park(Native Method)</span><br><span class="line">	- parking to wait <span class="keyword">for</span>  &lt;<span class="number">0x00000004d5200bf0</span>&gt; (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)</span><br><span class="line">	at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:<span class="number">215</span>)</span><br><span class="line">	at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:<span class="number">2078</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">1093</span>)</span><br><span class="line">	at java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take(ScheduledThreadPoolExecutor.java:<span class="number">809</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.getTask(ThreadPoolExecutor.java:<span class="number">1074</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:<span class="number">1134</span>)</span><br><span class="line">	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:<span class="number">624</span>)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:<span class="number">748</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line">	</span><br><span class="line">"Surrogate Locker Thread (Concurrent GC)" #4 daemon prio=9 os_prio=0 tid=0x00007f3facdca000 nid=0x23 waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"Finalizer" #3 daemon prio=8 os_prio=0 tid=0x00007f3facd97800 nid=0x22 in Object.wait() [0x00007f3f1ec1e000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000004d52012d0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">144</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000004d52012d0</span>&gt; (a java.lang.ref.ReferenceQueue$Lock)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:<span class="number">165</span>)</span><br><span class="line">	at java.lang.ref.Finalizer$FinalizerThread.run(Finalizer.java:<span class="number">216</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"Reference Handler" #2 daemon prio=10 os_prio=0 tid=0x00007f3facd95000 nid=0x21 in Object.wait() [0x00007f3f1ed1f000]</span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;<span class="number">0x00000004d5000260</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">	at java.lang.Object.wait(Object.java:<span class="number">502</span>)</span><br><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:<span class="number">191</span>)</span><br><span class="line">	- locked &lt;<span class="number">0x00000004d5000260</span>&gt; (a java.lang.ref.Reference$Lock)</span><br><span class="line">	at java.lang.ref.Reference$ReferenceHandler.run(Reference.java:<span class="number">153</span>)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007f3fac00c000 nid=0x9 runnable [0x00007f3fb1fb2000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.anda.trading.Application.blockingUntilJournalFinish(Application.kt:<span class="number">188</span>)</span><br><span class="line">	at com.anda.trading.Application.readJournalFromHeader(Application.kt:<span class="number">180</span>)</span><br><span class="line">	at com.anda.trading.Application.readJournal(Application.kt:<span class="number">217</span>)</span><br><span class="line">	at com.anda.trading.ApplicationKt.main(Application.kt:<span class="number">567</span>)</span><br><span class="line">	at com.anda.trading.ApplicationKt.main(Application.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>
<p>异常日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">"main" #1 prio=5 os_prio=0 tid=0x00007f3fac00c000 nid=0x9 runnable [0x00007f3fb1fb2000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.anda.trading.Application.blockingUntilJournalFinish(Application.kt:<span class="number">188</span>)</span><br><span class="line">	at com.anda.trading.Application.readJournalFromHeader(Application.kt:<span class="number">180</span>)</span><br><span class="line">	at com.anda.trading.Application.readJournal(Application.kt:<span class="number">217</span>)</span><br><span class="line">	at com.anda.trading.ApplicationKt.main(Application.kt:<span class="number">567</span>)</span><br><span class="line">	at com.anda.trading.ApplicationKt.main(Application.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>
<p>问题点：at com.anda.trading.Application.blockingUntilJournalFinish(Application.kt:188) 死循环等待。</p>
<hr>
<h3 id="Practice-arthas"><a href="#Practice-arthas" class="headerlink" title="Practice - arthas"></a>Practice - arthas</h3><hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://my.oschina.net/7001/blog/1504798" target="_blank" rel="noopener">https://my.oschina.net/7001/blog/1504798</a></li>
<li><a href="https://www.javatang.com/archives/2017/10/26/08572060.html" target="_blank" rel="noopener">https://www.javatang.com/archives/2017/10/26/08572060.html</a></li>
<li><a href="https://dzone.com/articles/difference-between-blocked-waiting-timed-waiting-e" target="_blank" rel="noopener">https://dzone.com/articles/difference-between-blocked-waiting-timed-waiting-e</a></li>
<li><a href="https://alibaba.github.io/arthas/quick-start.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/quick-start.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Basic/YGC/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Basic/YGC/" itemprop="url">JVM YGC</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T19:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>otSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次YGC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次YGC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p>
<p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p>
<p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。YGC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/young_gc.png">
<hr>
<h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC - Young GC"></a>YGC - Young GC</h4><p>YGC是JVM GC当前最为频繁的一种GC，一个高并发的服务在运行期间，会进行大量的YGC，发生YGC时，会进行STW，一般时间都很短，除非碰到YGC时，存在大量的存活对象需要进行拷贝。</p>
<p>一次YGC过程主要分成两个步骤：</p>
<ol>
<li>查找GC Roots，拷贝所引用的对象到 to 区；</li>
<li>递归遍历上一步中查找到的对象，并拷贝其所引用的对象到 to 区，当然可能会存在自然晋升，或者因为 to 区空间不足引起的提前晋升的情况；</li>
</ol>
<hr>
<h3 id="Find-GC-Roots"><a href="#Find-GC-Roots" class="headerlink" title="Find GC Roots"></a>Find GC Roots</h3><p>YGC的第一步根据GC Roots找出第一批活跃的对象，Hotspot中通过 <strong>gch-&gt;gen_process_strong_roots</strong> 方法实现</p>
<blockquote>
<p>Serial GC源代码为例</p>
</blockquote>
<img src="/2019/04/27/Java/JVM/Basic/YGC/find_gc_roots_code.png">
<ul>
<li>在黄色框的实现中，SharedHeap::process_strong_roots()扫描了所有一定是GC Roots的内存区域；</li>
<li>红色框中的实现逻辑对于YGC来说是没有意义的，因为level=0，Hotspot中唯一用到这个地方的只有CMS GC实现，默认只收集old generation，所以需要扫描young generation作为它的Strong root；</li>
<li>如果一个old generation的对象引用了young generation，那么这个old generation的对象肯定也属于Strong root的一部分，这部分逻辑并没有在process_strong_roots中实现，而是在绿色框中实现了，其中rem_set中保存了old generation中dirty card的对应区域，每次对象的拷贝移动都会检查一下是否产生了新的跨代引用，<strong>比如有对象晋升到了old generation，而该对象还引用了young generation的对象，这种情况下会把相应的card置为dirty，下次YGC的时候只会扫描dirty card所指内存的对象，避免扫描所有的old generation对象。</strong></li>
</ul>
<blockquote>
<p>process_strong_roots的实现，主要包括了以下东西：</p>
<ul>
<li>Universe类中所引用的一些必须存活的对象 Universe::oops_do(roots)</li>
<li>所有JNI Handles JNIHandles::oops_do(roots)</li>
<li>所有线程的栈 Threads::oops_do(roots, code_roots)</li>
<li>所有被Synchronize锁持有的对象  ObjectSynchronizer::oops_do(roots)</li>
<li>VM内实现的MBean所持有的对象 Management::oops_do(roots)</li>
<li>JVMTI所持有的对象 JvmtiExport::oops_do(roots)</li>
<li>(可选)所有已加载的类 或 所有已加载的系统类 SystemDictionary::oops_do(roots)</li>
<li>(可选)所有驻留字符串（StringTable） StringTable::oops_do(roots)</li>
<li>(可选)代码缓存（CodeCache） CodeCache::scavenge_root_nmethods_do(code_roots)</li>
<li>(可选)PermGen的remember set所记录的存在跨代引用的区域  rem_set()-&gt;younger_refs_iterate(perm_gen(), perm_blk)<br>注意：YGC在执行时只收集young generation，不收集old generation和perm generation，并不会做类的卸载行为，所以上述可选部分都作为Strong root，但是在FGC时就不会当作Strong root了。</li>
</ul>
</blockquote>
<hr>
<h3 id="Recurse-Roots"><a href="#Recurse-Roots" class="headerlink" title="Recurse Roots"></a>Recurse Roots</h3><p>在查找GC Roots的步骤中，已经找出了第一批存活的对象，这些存活对象可能在 to-space，也有可能直接晋升到了 old generation，这些区域都是需要进行遍历的，保证所有的活跃对象都能存活下来。<br>遍历过程的实现由FastEvacuateFollowersClosure类的do_void方法完成，这是一个*-Closure 方式命名的类，实现如下：</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/recurse_roots.png">
<p>每个内存区域都有两个指针变量，分别是 _saved_mark_word 和 _top，其中_saved_mark_word 指向当前遍历对象的位置，_top指向当前内存区域可分配的位置，其中_saved_mark_word 到 _top之间的对象是已拷贝，但未扫描的对象。</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/saved_market_word.png">
<p>GC Roots引用的对象拷贝完成后，to-space的_saved_mark_word和_top的状态如上图所示，假设期间没有对象晋升到old generation。每次扫描一个对象，_saved_mark_word会往前移动，期间也有新的对象会被拷贝到to-space，_top也会往前移动，直到_saved_mark_word追上_top，说明to-space的对象都已经遍历完成。</p>
<p>其中while循环条件 while (!_gch-&gt;no_allocs_since_save_marks(_level)，就是在判断各个内存代中的_saved_mark_word是否已经追到_top，如果还没有追上，就执行_gch-&gt;oop_since_save_marks_iterate进行遍历，实现如下：</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/oop_since_save_marks_iterate.png">
<p>to-space对象的遍历实现：</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/to-space.png">
<p>这里的blk变量是传递过来的FastScanClosure回调函数，oop_iterate方法会遍历该对象的所有引用，并调用回调函数的do_oop_work方法处理这里引用所指向的对象。</p>
<p>do_oop_work的实现：</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/do_oop_work.png">
<p>在FastScanClosure回调函数的do_oop_work方法实现中，红框的是重要的部分，因为可能存在多个对象共同引用一个对象，所以在遍历过程中，可能会遇到已经处理过的对象，如果遇到这样的对象，就不会再次进行复制了，如果该对象没有被拷贝过，则调用 copy_to_survivor_space 方法拷贝对象到to-space或者晋升到old generation，这里提一下ParNew的实现，因为是并发执行的，所以可能存在多个线程拷贝了同一个对象到to-space，不过通过原子操作，保证了只有一个对象是有效的。</p>
<p>copy_to_survivor_space 的实现：</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/copy_to_survivor_space.png">
<p>拷贝对象的目标空间不一定是to-space，也有可能是old generation，如果一个对象经历了很多次YGC，会从young generation直接晋升到old generation，为了记录对象经历的YGC次数，在对象头的mark word 数据结构中有一个位置记录着对象的YGC次数，也叫对象的年龄，如果扫描到的对象，其年龄小于某个阈值（tenuring threshold），该对象会被拷贝到to-space，并增加该对象的年龄，同时to-space的_top指针也会往后移动，这个新对象等待着被扫描。</p>
<img src="/2019/04/27/Java/JVM/Basic/YGC/saved_market_word_2.png">
<hr>
<h3 id="Full-GC-和-YGC-触发条件"><a href="#Full-GC-和-YGC-触发条件" class="headerlink" title="Full GC 和 YGC 触发条件"></a>Full GC 和 YGC 触发条件</h3><p><strong>YGC</strong>：对新生代堆进行GC。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。</p>
<p>YGC触发条件：</p>
<ul>
<li>edn空间不足</li>
</ul>
<p><strong>FGC</strong>：全堆范围的GC。默认堆空间使用到达80%(可调整)的时候会触发FGC。<br>FGC触发条件：</p>
<ul>
<li>old空间不足；</li>
<li>perm空间不足；</li>
<li>显示调用System.gc()，包括RMI等的定时触发；</li>
<li>YGC时的悲观策略；</li>
<li>dump live的内存信息时(jmap –dump:live)；</li>
<li>heap dump。</li>
</ul>
<blockquote>
<p>悲观策略：当准备要触发一次 young GC时，如果发现统计数据说之前 young GC的平均晋升大小比目前的 old gen剩余的空间大，则不会触发young GC而是转为触发 full GC。<br>因为HotSpot VM的GC里，除了垃圾回收器 CMS 的 concurrent collection 之外，其他能收集 old gen 的GC都会同时收集整个GC堆，包括young gen，所以不需要事先准备一次单独的young GC。</p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://ifeve.com/jvm-yong-generation/" target="_blank" rel="noopener">http://ifeve.com/jvm-yong-generation/</a><br><a href="https://www.jianshu.com/p/9af1a63a33c3" target="_blank" rel="noopener">https://www.jianshu.com/p/9af1a63a33c3</a><br><a href="https://juejin.im/post/5b8d2a5551882542ba1ddcf8" target="_blank" rel="noopener">https://juejin.im/post/5b8d2a5551882542ba1ddcf8</a><br><a href="https://www.zhihu.com/question/41922036/answer/93079526" target="_blank" rel="noopener">https://www.zhihu.com/question/41922036/answer/93079526</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/24/Java/Advance/Queue/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/Java/Advance/Queue/" itemprop="url">Java Queue</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-24T12:01:06+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Advance/" itemprop="url" rel="index">
                    <span itemprop="name">Advance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A collection designed for holding elements prior to processing.</span></span><br><span class="line"><span class="comment"> * Besides basic &#123;<span class="doctag">@link</span> java.util.Collection Collection&#125; operations,</span></span><br><span class="line"><span class="comment"> * queues provide additional insertion, extraction, and inspection</span></span><br><span class="line"><span class="comment"> * operations.  Each of these methods exists in two forms: one throws</span></span><br><span class="line"><span class="comment"> * an exception if the operation fails, the other returns a special</span></span><br><span class="line"><span class="comment"> * value (either &#123;<span class="doctag">@code</span> null&#125; or &#123;<span class="doctag">@code</span> false&#125;, depending on the</span></span><br><span class="line"><span class="comment"> * operation).  The latter form of the insert operation is designed</span></span><br><span class="line"><span class="comment"> * specifically for use with capacity-restricted &#123;<span class="doctag">@code</span> Queue&#125;</span></span><br><span class="line"><span class="comment"> * implementations; in most implementations, insert operations cannot</span></span><br><span class="line"><span class="comment"> * fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入（抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入（返回特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue是个接口，它提供的add，offer方法初衷是希望子类能够禁止添加元素为<span class="keyword">null</span>，这样可以避免在查询时返回<span class="keyword">null</span>究竟是正确还是错误。实际上大多数Queue的实现类的确响应了Queue接口的规定，比如ArrayBlockingQueue，PriorityBlockingQueue等等。</span><br><span class="line"></span><br><span class="line">但还是有一些实现类没有这样要求，比如LinkedList。虽然 LinkedList 没有禁止添加 <span class="keyword">null</span>，但是一般情况下 Queue 的实现类都不允许添加 <span class="keyword">null</span> 元素，为啥呢？因为poll(),peek()方法在异常的时候会返回 <span class="keyword">null</span>，你添加了<span class="keyword">null</span> 以后，当获取时不好分辨究竟是否正确返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque if it is</span></span><br><span class="line"><span class="comment">     * possible to do so immediately without violating capacity restrictions,</span></span><br><span class="line"><span class="comment">     * throwing an &#123;<span class="doctag">@code</span> IllegalStateException&#125; if no space is currently</span></span><br><span class="line"><span class="comment">     * available.  When using a capacity-restricted deque, it is generally</span></span><br><span class="line"><span class="comment">     * preferable to use method &#123;<span class="doctag">@link</span> #offerFirst&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the element cannot be added at this</span></span><br><span class="line"><span class="comment">     *         time due to capacity restrictions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null and this</span></span><br><span class="line"><span class="comment">     *         deque does not permit null elements</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><ul>
<li>PriorityQueue</li>
<li>PriorityBlockingQueue</li>
<li>Deque</li>
<li>ArrayDeque：ArrayDeque是一个循环队列，它使用数组实现的Deque，底层是数组。</li>
<li>BlockingQueue</li>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<p><strong>Summary</strong></p>
<ul>
<li>当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。</li>
<li>当 Deque 当做 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。</li>
<li>ArrayDeque不是线程安全的。 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。</li>
<li>ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li>
<li>LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li>
<li>SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li>
<li>PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li>
</ul>
<hr>
<h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p>
<p><strong>核心属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 以下几个就是控制并发用的同步器</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure>
<p><strong>核心原理</strong></p>
<p>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。</p>
<p>如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后写线程唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</p>
<img src="/2019/04/24/Java/Advance/Queue/array-blocking-queue.png">
<p>构造函数可选参数：</p>
<ul>
<li>队列容量，其限制了队列中最多允许的元素个数；</li>
<li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li>
<li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li>
</ul>
<hr>
<h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。</p>
<p><strong>核心属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure>
<p>ReentrantLock与Condition使用说明：</p>
<ul>
<li><p>takeLock 和 notEmpty 搭配：如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。</p>
</li>
<li><p>putLock 和 notFull 搭配：如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。</p>
</li>
</ul>
<img src="/2019/04/24/Java/Advance/Queue/linked-blocking-queue.png">
<hr>
<h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。</p>
<p>虽然说是队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</p>
<p>在开发中比较少使用到 SynchronousQueue 这个类，不过它在线程池的实现类 ScheduledThreadPoolExecutor 中得到了应用。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p>
<p><strong>核心原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取值并移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写操作 put(E o) 和读操作 take() 都是调用 Transferer.transfer(…) 方法，区别在于第一个参数是否为 null 值。</p>
<p>transfer 的设计思路，其基本算法如下：</p>
<ul>
<li><p>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而队列中的元素也都是写线程）。这种情况下，将当前线程加入到等待队列即可。</p>
</li>
<li><p>如果队列中有等待节点，而且与当前操作可以匹配（如队列中都是读操作线程，当前线程是写操作线程，反之亦然）。这种情况下，匹配等待队列的队头，出队，返回相应数据。</p>
</li>
</ul>
<p><strong>示例图说明</strong></p>
<ol>
<li>前提条件：公平模式，初始化情况下，TransferQueue的状态</li>
</ol>
<img src="/2019/04/24/Java/Advance/Queue/TransferQueue1.png">
<ol start="2">
<li>put线程1执行操作put(1)，由于当前没有配对的消费线程，所以线程1入队列，自旋一小会后睡眠等待。</li>
</ol>
<img src="/2019/04/24/Java/Advance/Queue/TransferQueue2.png">
<ol start="3">
<li>put线程2执行操作put(2)，由于当前没有配对的消费线程，所以线程2入队列，自旋一小会后睡眠等待。</li>
</ol>
<img src="/2019/04/24/Java/Advance/Queue/TransferQueue3.png">
<ol start="4">
<li>这时候taker线程执行操作taker(1)，由于tail指向put2线程，put线程2跟take线程1配对了(put一take)，这时take1线程不需要入队，但是请注意了，这时候，要唤醒的线程并不是put线程2，而是put线程1。put线程1被唤醒，take线程1的take()方法返回了put线程1的数据，这样就实现了线程间的一对一通信，这时候内部状态如下：</li>
</ol>
<blockquote>
<p>公平策略总结下来就是：队尾匹配队头出队。</p>
</blockquote>
<img src="/2019/04/24/Java/Advance/Queue/TransferQueue4.png">
<p>SynchronousQueue的实现模型。总结下来就是：队尾匹配队头出队，先进先出，体现公平原则。</p>
<hr>
<h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p>
<p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p>
<p><strong>核心属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法中，如果不指定大小的话，默认大小为 11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是存放数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列当前大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小比较器，如果按照自然序排序，那么此属性可设置为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个很好理解，其实例由上面的 lock 属性创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作</span></span><br><span class="line"><span class="comment">// 其使用 CAS 操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue q;</span><br></pre></td></tr></table></figure>
<p>此类实现了 Collection 和 Iterator 接口中的所有接口方法，对其对象进行迭代并遍历时，不能保证有序性。</p>
<p>如果你想要实现有序遍历，建议采用 Arrays.sort(queue.toArray()) 进行处理。PriorityBlockingQueue 提供了 drainTo 方法用于将部分或全部元素有序地填充（准确说是转移，会删除原队列中的元素）到另一个集合中。</p>
<p>还有一个需要说明的是，如果两个对象的优先级相同（compare 方法返回 0），此队列并不保证它们之间的顺序。</p>
<p>PriorityBlockingQueue 使用了基于数组的二叉堆来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://juejin.im/post/5a3763ed51882506a463b740" target="_blank" rel="noopener">https://juejin.im/post/5a3763ed51882506a463b740</a></li>
<li><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">https://javadoop.com/post/java-concurrent-queue</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29227508" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29227508</a></li>
<li><a href="http://www.cnblogs.com/CarpenterLee/p/5488070.html" target="_blank" rel="noopener">http://www.cnblogs.com/CarpenterLee/p/5488070.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/23/Git/GitFlow/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/Git/GitFlow/" itemprop="url">Git Flow QuickStart</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T21:36:12+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用。</p>
<p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。</p>
<p>分支类型说明：</p>
<ul>
<li><p>feature： 用于日常的功能开发，一般一个功能分支代表一个功能，一般一个功能分支代表一个功能。</p>
<blockquote>
<p>继承分支：develop，合并分支：develop，命名规则：任何名字除了master, develop, release-<em>, hotfix-</em></p>
</blockquote>
</li>
<li><p>release：当需要发布新版本时使用，主要用于测试。可在此分支上直接开发功能，修复bug，但务必同时合并到develop和master。</p>
<blockquote>
<p>继承分支：develop，合并分支：develop master，命名规则：release-*</p>
</blockquote>
</li>
<li><p>hotfix：用于修复线上的bug，务必同时合并到develop和master。</p>
<blockquote>
<p>继承分支：master，合并分支：develop master，命名规则：hotfix-*</p>
</blockquote>
</li>
</ul>
<hr>
<h3 id="Git-Flow-Tools"><a href="#Git-Flow-Tools" class="headerlink" title="Git Flow Tools"></a>Git Flow Tools</h3><h4 id="Feature-Branch"><a href="#Feature-Branch" class="headerlink" title="Feature Branch"></a>Feature Branch</h4><ol>
<li><p>创建 feature 分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start login</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to a new branch <span class="string">'feature/login'</span></span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch <span class="string">'feature/login'</span> was created, based on <span class="string">'develop'</span></span><br><span class="line">- You are now on branch <span class="string">'feature/login'</span></span><br><span class="line"></span><br><span class="line">Now, start committing on your feature. When <span class="keyword">done</span>, use:</span><br><span class="line"></span><br><span class="line">     git flow feature finish login</span><br></pre></td></tr></table></figure>
</li>
<li><p>完成 feature 分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish login</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">Updating d2df03b..85d1933</span><br><span class="line">Fast-forward</span><br><span class="line"> login.java | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 login.java</span><br><span class="line">Deleted branch feature/login (was 85d1933).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- The feature branch <span class="string">'feature/login'</span> was merged into <span class="string">'develop'</span></span><br><span class="line">- Feature branch <span class="string">'feature/login'</span> has been removed</span><br><span class="line">- You are now on branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>此时，本地feature/login已经被删除，同时代码合并到了本地的develop分支。</p>
<blockquote>
<p>如果想在github上保留feature/login，则需要手动push该分支。</p>
</blockquote>
<h4 id="Release-Branch"><a href="#Release-Branch" class="headerlink" title="Release Branch"></a>Release Branch</h4><ol>
<li><p>创建 release 分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 1.13.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to a new branch <span class="string">'release/1.13.1'</span></span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch <span class="string">'release/1.13.1'</span> was created, based on <span class="string">'develop'</span></span><br><span class="line">- You are now on branch <span class="string">'release/1.13.1'</span></span><br><span class="line"></span><br><span class="line">Follow-up actions:</span><br><span class="line">- Bump the version number now!</span><br><span class="line">- Start committing last-minute fixes <span class="keyword">in</span> preparing your release</span><br><span class="line">- When <span class="keyword">done</span>, run:</span><br><span class="line"></span><br><span class="line">     git flow release finish <span class="string">'1.13.1'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>完成 release 分支</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish <span class="string">'1.13.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Deleted branch release/1.13.1 (was 85d1933).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- Latest objects have been fetched from <span class="string">'origin'</span></span><br><span class="line">- Release branch has been merged into <span class="string">'master'</span></span><br><span class="line">- The release was tagged <span class="string">'1.13.1'</span></span><br><span class="line">- Release branch has been back-merged into <span class="string">'develop'</span></span><br><span class="line">- Release branch <span class="string">'release/1.13.1'</span> has been deleted</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>完成release 1.13.1后，本地release 1.13.1会被删除 ，release代码会自动合并到本地 master 分支。</p>
<blockquote>
<p>如果想在github上保留release 1.13.1，则需要手动push该分支。</p>
</blockquote>
<ol start="3">
<li>Push Tag</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin 1.13.1</span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure>
<h4 id="Hotfix-Branch"><a href="#Hotfix-Branch" class="headerlink" title="Hotfix Branch"></a>Hotfix Branch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建hotfix分支</span></span><br><span class="line">git flow hotfix start &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交hotfix分支</span></span><br><span class="line">git flow hotfix finish &lt;name&gt;</span><br></pre></td></tr></table></figure>
<p>和release分支一样，提交时也会自动打上tag。</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a><br><a href="https://juejin.im/post/5c3e9b6df265da616c65d685" target="_blank" rel="noopener">https://juejin.im/post/5c3e9b6df265da616c65d685</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/12/Network/MTU/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/12/Network/MTU/" itemprop="url">What's MTU and MSS?</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-12T15:40:00+08:00">
                2019-04-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>如果发送的TCP报文段很长的话，会在发送时发生分段，在接收端进行重组，同样IP数据报在长度超过一定值时也会发生分片，在接收端再将分片重组。</p>
<img src="/2019/04/12/Network/MTU/seven-layer-network-protocol.jpg">
<img src="/2019/04/12/Network/MTU/layer-network-protocol-detail.png">
<p>在7层网络协议中，MTU是数据链路层的概念。MTU限制的是数据链路层的payload，也就是上层协议的大小，例如IP，ICMP等。</p>
<h4 id="MTU-Maximum-Transmission-Unit"><a href="#MTU-Maximum-Transmission-Unit" class="headerlink" title="MTU - Maximum Transmission Unit"></a>MTU - Maximum Transmission Unit</h4><p>MTU 是链路层中的网络对数据帧的一个限制，依然以以太网为例，MTU为1500个字节。一个IP数据报在以太网中传输，如果它的长度大于该MTU值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的IP数据报不一定按序到达，但IP首部中的信息能让这些数据报片按序组装。IP数据报的分片与重组是在网络层进完成的。</p>
<p><strong>如何确定 UDP 包的数据大小？</strong></p>
<ul>
<li>在链路层，由以太网的物理特性决定了数据帧的长度为 46＋18 ~ 1500＋18，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500（不包括帧头和帧尾），即MTU（Maximum Transmission Unit）为1500；</li>
<li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；</li>
<li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；</li>
</ul>
<p>所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。</p>
<p>从上面的分析来看，在普通的局域网环境下，UDP的数据最大为1472字节最好(避免分片重组)。但在网络编程中，Internet中的路由器可能有设置成不同的值（小于默认值），Internet上的标准MTU值为576，所以Internet的UDP编程时数据长度最好在576－20－8＝548字节以内。</p>
<p><strong>如何查看路由的MTU值？</strong></p>
<p>Theory：ping程序使用ICMP报文，ICMP报文首部占8字节，IP数据报首部占20字节，因此在数据大小基础上加上28字节为MTU值。</p>
<ul>
<li>Windows: ping -f -l 1472 192.168.0.1</li>
<li>Linux: ping -c 1 -M do -s 1472 192.168.0.1</li>
</ul>
<hr>
<h4 id="MSS-Maxitum-Segment-Size"><a href="#MSS-Maxitum-Segment-Size" class="headerlink" title="MSS - Maxitum Segment Size"></a>MSS - Maxitum Segment Size</h4><p>MSS是TCP里的一个概念。MSS是TCP数据包每次能够传输的最大数据分段，TCP报文段的长度大于MSS时，要进行分段传输。</p>
<p>TCP协议在建立连接的时候通常要协商双方的MSS值，每一方都有用于通告它期望接收的MSS选项（MSS选项只出现在SYN报文段中，即TCP三次握手的前两次）。MSS的值一般为MTU值减去两个首部大小（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes），所以如果用链路层以太网，MSS的值往往为1460。而Internet上标准的MTU（最小的MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。TCP报文段的分段与重组是在运输层完成的。</p>
<blockquote>
<p>MSS = MTU - IP首部大小 - TCP首部大小。</p>
</blockquote>
<hr>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TCP分段的原因是MSS，IP分片的原因是MTU，由于一直有MSS &lt;= MTU，很明显，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。</p>
<p>再来看UDP数据报，由于UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p>另外，IP数据报分片后，只有第一片带有UDP首部或ICMP首部，其余的分片只有IP头部，到了端点后根据IP头部中的信息再网络层进行重组。而TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是向其他网络协议，在下一站就要进行重组。</p>
<p>最后一点，对IP分片的数据报来说，即使只丢失一片数据也要重新传整个数据报（既然有重传，说明运输层使用的是具有重传功能的协议，如TCP协议）。这是因为IP层本身没有超时重传机制，则由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<hr>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>举一个最简单的场景，你在家用自己的笔记本上网，用的是路由器，路由器连接电信网络，然后访问了<a href="http://www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：" target="_blank" rel="noopener">www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1500     1500                 1500    </span><br><span class="line">笔记本 -&gt; 路由器 -&gt; 电信机房  -&gt; 服务器</span><br></pre></td></tr></table></figure>
<p>假设现在我把笔记本的MTU最大值设置成了1700，然后发送了一个超大的ip数据包（2000），这时候在以外网传输的时候会被拆成2个包，一个1700，一个300，然后加上头信息进行传输。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1700     1500                 1500    </span><br><span class="line">笔记本 -&gt; 路由器 -&gt; 电信机房  -&gt; 服务器</span><br></pre></td></tr></table></figure>
<p>路由器接收到了一个1700的帧，发现大于自己设置的最大值：1500，如果IP包DF标志位为1，也就是不允许分包，那么路由器直接就把这个包丢弃了，根本就不会到达电信机房，也就到不了服务器了，所以，到这里我们就会发现，MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。</p>
<hr>
<h3 id="为什么MTU通常设置为1500"><a href="#为什么MTU通常设置为1500" class="headerlink" title="为什么MTU通常设置为1500?"></a>为什么MTU通常设置为1500?</h3><p>其实一个标准的以太网数据帧大小是：1518，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500，那么，1518这个值又是从哪里来的呢？</p>
<p><strong>假设取一个更大的MTU值会怎么样？</strong></p>
<p>假设MTU值和IP数据包大小一致，一个IP数据包的大小是：65535，那么加上以太网帧头和为，一个以太网帧的大小就是：65535 + 14 + 4 = 65553，看起来似乎很完美，发送方也不需要拆包，接收方也不需要重组。</p>
<p>那么假设我们现在的带宽是：100Mbps，因为以太网帧是传输中的最小可识别单元，再往下就是0101所对应的光信号了，所以我们的一条带宽同时只能发送一个以太网帧。如果同时发送多个，那么对端就无法重组成一个以太网帧了，在100Mbps的带宽中（假设中间没有损耗），我们计算一下发送这一帧需要的时间：</p>
<p>( 65553 <em> 8 ) / ( 100 </em> 1024 * 1024 ) ≈ <strong>0.005(s)</strong></p>
<p>在100M网络下传输一帧就需要5ms，也就是说这5ms其他进程发送不了任何数据。如果是早先的电话拨号，网速只有2M的情况下：</p>
<p>( 65553 <em> 8 ) / ( 2 </em> 1024 * 1024 ) ≈ <strong>0.100(s)</strong></p>
<p>100ms，这简直是噩梦。其实这就像红绿灯，时间要设置合理，交替通行，不然同一个方向如果一直是绿灯，那么另一个方向就要堵成翔了。</p>
<p><strong>MTU值既然大了不行，那把MTU的值设置小一点可以么？</strong></p>
<p>假设MTU值设置为100，那么单个帧传输的时间，在2Mbps带宽下需要：</p>
<p>( 100 <em> 8 ) / ( 2 </em> 1024 <em> 1024 ) </em> 1000 ≈ 5(ms)</p>
<p>时间上已经能接受了，问题在于，不管MTU设置为多少，以太网头帧尾大小是固定的，都是14 + 4，所以在MTU为100的时候，一个以太网帧的传输效率为：</p>
<p>( 100 - 14 - 4 ) / 100 = <strong>82%</strong></p>
<p>写成公式就是：( T - 14 - 4 ) / T，当T趋于无穷大的时候，效率接近100%，也就是MTU的值越大，传输效率最高，但是基于上一点传输时间的问题，来个折中的选择吧，既然头加尾是18，那就凑个整来个1500，总大小就是1518，传输效率：</p>
<p>1500 / 1518 =  98.8%</p>
<p>100Mbps传输时间：( 1518 <em> 8 ) / ( 100 </em> 1024 <em> 1024 ) </em> 1000 = 0.11(ms)</p>
<p>2Mbps传输时间：( 1518 <em> 8 ) / ( 2 </em> 1024 <em> 1024 ) </em> 1000 = 5.79(ms)</p>
<blockquote>
<p>至于MUT的值最少是64，这个值是因为和以太网帧在半双工下的碰撞有关。</p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://www.zhihu.com/question/31460305" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305</a><br>什么是MTU: <a href="https://www.vps234.com/vps-mtu-config-tutorials/" target="_blank" rel="noopener">https://www.vps234.com/vps-mtu-config-tutorials/</a><br>GCP and AWS MTU: <a href="http://www.cloudnetworkstuff.com/index.php/2018/04/19/multicloud-path-mtu-aws-gcp/" target="_blank" rel="noopener">http://www.cloudnetworkstuff.com/index.php/2018/04/19/multicloud-path-mtu-aws-gcp/</a><br>关于网络编程中MTU、TCP、UDP优化配置的一些总结: <a href="https://www.cnblogs.com/maowang1991/archive/2013/04/15/3022955.html" target="_blank" rel="noopener">https://www.cnblogs.com/maowang1991/archive/2013/04/15/3022955.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/58/">58</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jason - sulang357159@163.com">
          
            <p class="site-author-name" itemprop="name">Jason - sulang357159@163.com</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">577</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">246</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">633</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason - sulang357159@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
