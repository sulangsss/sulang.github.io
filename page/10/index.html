<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="true">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="A Big Boy Blog -  Tech Articls & Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta property="og:type" content="website">
<meta property="og:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:url" content="https://sulangsss.github.io/page/10/index.html">
<meta property="og:site_name" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sulangsss.github.io/page/10/">





<meta name="baidu-site-verification" content="xV2vphJ53Q">


  <title>A Big Boy Blog -  Tech Articls & Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?344f3e8f33d176fceb44e65d30a341dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">A Big Boy Blog -  Tech Articls & Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Python Java Android Django Web -> sulang357159@gmail.com</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/09/Network/HTTP/HTTP,HTTPS代理原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/09/Network/HTTP/HTTP,HTTPS代理原理/" itemprop="url">HTTP,HTTPS代理原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-09T10:52:18+08:00">
                2018-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/HTTP/" itemprop="url" rel="index">
                    <span itemprop="name">HTTP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="HTTP代理"><a href="#HTTP代理" class="headerlink" title="HTTP代理"></a>HTTP代理</h2><h3 id="代理原理"><a href="#代理原理" class="headerlink" title="代理原理"></a>代理原理</h3><p>HTTP代理服务器会自动提取请求数据包的HTTP Request数据，并且把HTTP Response的数据转发给发送请求的客户端；HTTP代理服务器使用的端口通常是8080。</p>
<img src="/2018/12/09/Network/HTTP/HTTP,HTTPS代理原理/http-proxy-1.jpg">
<ul>
<li>对于Web客户端来说，代理扮演的服务器角色，接收请求（Request），返回响应（Response）</li>
<li>对于Web服务器来说，代理扮演的客户端角色，发送请求（Request），接收响应（Response）</li>
</ul>
<h3 id="代理步骤"><a href="#代理步骤" class="headerlink" title="代理步骤"></a>代理步骤</h3><ol>
<li>用户向代理发起TCP连接；</li>
<li>代理接收用户的连接，双方建立连接；</li>
<li>用户向代理发送HTTP请求，请求内容和没有HTTP代理的内容完全相同；</li>
<li>代理解析HTTP请求；</li>
<li>代理向服务器发起TCP连接；</li>
<li>服务器接收代理的连接；</li>
<li>代理向服务器发送HTTP请求（这个HTTP请求是基于用户的HTTP请求，可能会有修改）</li>
<li>服务器发送响应给代理；</li>
<li>代理再转发响应给客户端；</li>
</ol>
<h3 id="报文对比"><a href="#报文对比" class="headerlink" title="报文对比"></a>报文对比</h3><p>HTTP请求协议（不使用代理协议）报文</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Host: www.xxxx.com</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure>
<p>HTTP请求协议（使用代理协议）报文</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET http://www.xxxx.com/ HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Host: www.xxxx.com</span><br><span class="line">Cookie:</span><br></pre></td></tr></table></figure>
<p>差异点：</p>
<ul>
<li>GET</li>
<li>Proxy-Connection</li>
</ul>
<h3 id="HTTP-Actions"><a href="#HTTP-Actions" class="headerlink" title="HTTP Actions"></a>HTTP Actions</h3><ul>
<li><p>OPTIONS方法：这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用’*‘来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</p>
</li>
<li><p>HEAD方法：与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部份。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中“关于该资源的信息”(元信息或称元数据)。</p>
</li>
<li><p>GET方法：向指定的资源发出“显示”请求。使用GET方法应该只用在读取数据，而不应当被用于产生“副作用”的操作中，例如在Web Application中。其中一个原因是GET可能会被网络蜘蛛等随意访问。参见安全方法</p>
</li>
<li><p>POST方法：向指定资源提交数据，请求服务器进行处理(例如提交表单或者上传文件)。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</p>
</li>
<li><p>PUT方法：向指定资源位置上传其最新内容。</p>
</li>
<li><p>DELETE方法：请求服务器删除Request-URI所标识的资源。</p>
</li>
<li><p>TRACE方法：回显服务器收到的请求，主要用于测试或诊断。</p>
</li>
<li><p>CONNECT方法：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接(经由非加密的HTTP代理服务器)。</p>
</li>
</ul>
<h4 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h4><p>connect方法的通常就是把服务器作为跳板机，让服务器直接代理客户端访问，然后把数据原原本本的返回给客户端，connect方法的原理就是TCP直连。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CONNECT http://www.xxxx.com:80/ HTTP/1.1</span><br><span class="line">Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, application/vnd.ms-excel, application/vnd.ms-powerpoint, application/msword, */*</span><br><span class="line">Accept-Language: zh-CN</span><br><span class="line">User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; InfoPath.2; .NET4.0C; .NET4.0E)</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Proxy-Connection: Keep-Alive</span><br><span class="line">Host: www.xxxx.com</span><br></pre></td></tr></table></figure>
<h3 id="HTTP代理类型"><a href="#HTTP代理类型" class="headerlink" title="HTTP代理类型"></a>HTTP代理类型</h3><ul>
<li>全匿名代理，不改变客户端的request fields（请求信息），使服务器端看来就像有个真正的客户浏览器在访问。客户端的真实IP是隐藏起来的。</li>
<li>普通匿名代理，能隐藏客户端的真实IP，但会更改客户端的request fields（请求信息），服务器端有可能会被认为使用了代理。</li>
<li>透明代理（简单代理），改变客户端的request fields（请求信息），并会传送真实IP地址。</li>
</ul>
<hr>
<h2 id="HTTPS代理"><a href="#HTTPS代理" class="headerlink" title="HTTPS代理"></a>HTTPS代理</h2><h3 id="代理原理-1"><a href="#代理原理-1" class="headerlink" title="代理原理"></a>代理原理</h3><p>HTTPS代理有多种做法，通常使用CONNECT method，通过proxy建立一条隧道(隧道代理)，这样proxy无法解密数据；此外，还有一种类似于中间人攻击的代理手法。</p>
<h3 id="代理步骤-1"><a href="#代理步骤-1" class="headerlink" title="代理步骤"></a>代理步骤</h3><img src="/2018/12/09/Network/HTTP/HTTP,HTTPS代理原理/https-proxy-1.jpg">
<ul>
<li>用户向代理发起CONNECT请求；</li>
<li>代理向Targe发起TCP连接请求；</li>
<li>代理向用户返回”HTTP/1.0 OK”，隧道建立完成；</li>
<li>代理转发用户的数据给Target，转发Target的数据给用户，直到任何一方连接结束；</li>
</ul>
<h3 id="TLS-MIM-man-in-the-middle-中间人攻击"><a href="#TLS-MIM-man-in-the-middle-中间人攻击" class="headerlink" title="TLS MIM(man in the middle 中间人攻击)"></a>TLS MIM(man in the middle 中间人攻击)</h3><p>正常情况下浏览器与服务器在TLS链接下内容是加密的，第三方即使可以嗅探到所有的数据，也不能解密。</p>
<p>中间人可以与你建立链接，然后中间人再与服务器建立链接，转发你们之间的内容。这时候中间人就获得了明文的信息。</p>
<h4 id="如何防范？如果确定是否被攻击？"><a href="#如何防范？如果确定是否被攻击？" class="headerlink" title="如何防范？如果确定是否被攻击？"></a>如何防范？如果确定是否被攻击？</h4><p>在访问https链接的时候，查看一下服务器提供的证书是不是正确的。除非入侵并取得服务器的证书私钥，否则中间人是不能完全伪装成服务器的样子的。</p>
<h4 id="为什么这么多人呼吁删除CNNIC-ROOT-CA？"><a href="#为什么这么多人呼吁删除CNNIC-ROOT-CA？" class="headerlink" title="为什么这么多人呼吁删除CNNIC ROOT CA？"></a>为什么这么多人呼吁删除CNNIC ROOT CA？</h4><h4 id="HTTP-Public-Key-Pinning（HPKP）"><a href="#HTTP-Public-Key-Pinning（HPKP）" class="headerlink" title="HTTP Public Key Pinning（HPKP）"></a>HTTP Public Key Pinning（HPKP）</h4><p>用来防范由「伪造或不正当手段获得网站证书」造成的中间人攻击</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://lilywei739.github.io/2017/01/25/principle_for_http_https.html" target="_blank" rel="noopener">https://lilywei739.github.io/2017/01/25/principle_for_http_https.html</a><br>HTTP Public Key Pinning 介绍: <a href="https://imququ.com/post/http-public-key-pinning.html" target="_blank" rel="noopener">https://imququ.com/post/http-public-key-pinning.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/08/Java/Advance/ByteBuffer/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/Java/Advance/ByteBuffer/" itemprop="url">Java ByteBuffer 与 HeapByteBuffer 的区别</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-08T12:39:18+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Advance/" itemprop="url" rel="index">
                    <span itemprop="name">Advance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="HeapByteBuffer"><a href="#HeapByteBuffer" class="headerlink" title="HeapByteBuffer"></a>HeapByteBuffer</h3><p>HeapByteBuffer分配在Java Heap内。</p>
<p>当向NIO Channel写入HeapByteBuffer数据时，需要先把HeapByteBuffer数据拷贝到DirectMemory后，才能把数据发送出去。</p>
<h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  capacity为字节的数量</span></span><br><span class="line">ByteBuffer.allocate(<span class="keyword">int</span> capacity);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h3><p>DirectByteBuffer分配在Java Heap外。</p>
<p>当向NIO Channel写入DirectByteBuffer数据时，不需要拷贝，直接把数据发送出去。这样的话，无疑DirectByteBuffer的IO性能肯定强于使用HeapByteBuffer，因为它省去了临时buffer的拷贝开销，这也是为什么各个NIO框架大多使用DirectByteBuffer的原因。</p>
<h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  可以看到分配内存是通过unsafe.allocateMemory()来实现的，这个unsafe默认情况下java代码是没有能力可以调用到的，</span></span><br><span class="line"><span class="comment">//  不过你可以通过反射的手段得到实例进而做操作，当然你需要保证的是程序的稳定性，既然叫unsafe的，就是告诉你这不是安全的，</span></span><br><span class="line"><span class="comment">//  其实并不是不安全，而是交给程序员来操作，它可能会因为程序员的能力而导致不安全，而并非它本身不安全。</span></span><br><span class="line">ByteBuffer.allocateDirect(<span class="keyword">int</span> capacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  free</span></span><br><span class="line"><span class="keyword">if</span> (byteBuffer.isDirect()) &#123;</span><br><span class="line">    ((DirectBuffer)byteBuffer).cleaner().clean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="Direct-buffer是相当于固定的内核buffer还是JVM进程内的堆外内存？"><a href="#Direct-buffer是相当于固定的内核buffer还是JVM进程内的堆外内存？" class="headerlink" title="Direct buffer是相当于固定的内核buffer还是JVM进程内的堆外内存？"></a>Direct buffer是相当于固定的内核buffer还是JVM进程内的堆外内存？</h4><p>JVM进程的Java堆外申请的内存，是用户空间的，DirectByteBuffer的创建就是使用了malloc申请的内存。</p>
<h4 id="为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？"><a href="#为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？" class="headerlink" title="为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？"></a>为什么在执行网络IO或者文件IO时，一定要通过堆外内存呢？</h4><blockquote>
<p>Given a direct byte buffer, the Java virtual machine will make a best effort to perform native I/O operations directly upon it. That is, it will attempt to avoid copying the buffer’s content to (or from) an intermediate buffer before (or after) each invocation of one of the underlying operating system’s native I/O operations.</p>
</blockquote>
<p>如果是使用DirectBuffer就会少一次内存拷贝。如果是非DirectBuffer，JDK会先创建一个DirectBuffer，再去执行真正的写操作。</p>
<p>这是因为当我们把一个地址通过JNI传递给底层的C库的时候，<strong>有一个基本的要求：就是这个地址上的内容不能失效。</strong>然而，在GC管理下的对象是会在Java堆中移动的。也就是说，有可能我把一个地址传给底层的write，但是这段内存却因为GC整理内存而失效了。所以我必须要把待发送的数据放到一个GC管不着的地方。这就是调用native方法之前，数据一定要在堆外内存的原因。</p>
<p>此外，使用DirectBuffer好处还有，GC压力更小。虽然GC仍然管理着DirectBuffer的回收，但它是使用PhantomReference(虚引用)来达到的，在平常的Young GC或者mark and compact的时候却不会在内存里搬动。如果IO的数量比较大，比如在网络发送很大的文件，那么GC的压力下降就会很明显。</p>
<blockquote>
<p><strong>需要特别注意的是，DirectBuffer直接分配在JVM之外的物理内存，而不是JVM中的逻辑内存，需要往Socket或其他接口写的时候，不需要将数据从JVM复制到物理内存，直接输出即可。缺点是当你需要对这些数据进行额外处理的时候，如编码，过滤等，数据还是会复制到 JVM，所以请确保你不需要对数据进行这些额外操作，只是从一个文件复制数据到另一个文件，一个Socket到另一个的时候才使用。</strong></p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://blog.csdn.net/xieyuooo/article/details/7547435" target="_blank" rel="noopener">https://blog.csdn.net/xieyuooo/article/details/7547435</a><br><a href="https://www.zhihu.com/question/60892134" target="_blank" rel="noopener">https://www.zhihu.com/question/60892134</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/07/Network/Socket/What's socket/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/Network/Socket/What's socket/" itemprop="url">认识Socket</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-07T22:52:18+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/" itemprop="url" rel="index">
                    <span itemprop="name">Network</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Network/Socket/" itemprop="url" rel="index">
                    <span itemprop="name">Socket</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="What’s-socket"><a href="#What’s-socket" class="headerlink" title="What’s socket"></a>What’s socket</h3><p>socket是计算机网络中用于在节点内发送或接收数据的内部端点。</p>
<p>具体来说，它是网络软件 (协议栈) 中这个端点的一种表示，包含通信协议、目标地址、状态等，是系统资源的一种形式。</p>
<p>socket所处的位置大致就是下面的黑色部分，应用层与传输层之间：</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/tcp-1.png">
<p>其中的传输层就是TCP/IP所在的地方，socket在这里起到就是连接应用层与传输层的作用。</p>
<p>socket的诞生是为了应用程序能够更方便的将数据经由传输层来传输，所以它本质上就是对TCP/IP的运用进行了一层封装，然后应用程序直接调用socket API即可进行通信。</p>
<p>那么它是如何工作的呢？它分为2个部分，服务端需要建立socket来监听指定的地址，然后等待客户端来连接。而客户端则需要建立socket并与服务端的socket地址进行连接。</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/tcp-client-server.png">
<p>上图展示的就是建立TCP/IP连接的过程，<strong>经典的叫法为“三次握手”的过程</strong>。顾名思义，这个过程中来回产生了三次网络通信。</p>
<p>接下来的数据传输过程就简单很多，发送数据就是客户端往服务端通信，服务端处理完之后的数据返回则相反。</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/tcp-communication.png">
<p>值得注意的是，传输的过程涉及到数据Copy，不过这些Copy是必不可少的。其中的发送缓冲区和接收缓冲区就是套接字缓存 (socket buffer)。</p>
<p>连接使用完之后需要关闭，不过 TCP/IP 连接关闭过程比创建更复杂一些，次数多了一次，这就是<strong>经典的“四次握手”过程</strong>。</p>
<p>socket是进程间数据传输的媒介，为了保证连接的可靠，你需要特别注意建立连接和关闭连接的过程。为了确保准确、完整的数据传输，客户端和服务端来回进行了多次网络通信才得以完成连接的创建和关闭，这同时也是你在运用一个连接时所花费的额外成本。</p>
<h3 id="长短连接"><a href="#长短连接" class="headerlink" title="长短连接"></a>长短连接</h3><h4 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h4><p>长连接意味着进行一次数据传输后，不关闭连接，长期保持连通状态。如果两个应用程序之间有新的数据需要传输，则直接复用这个连接，无需再建立一个新的连接。就像下图这样。</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/long-connection.png">
<p>它的优势是在多次通信中可以省去连接建立和关闭连接的开销，并且从总体上来看，进行多次数据传输的总耗时更少。缺点是需要花费额外的精力来保持这个连接一直是可用的，因为网络抖动、服务器故障等都会导致这个连接不可用，甚至是由于防火墙的原因。</p>
<p>所以，一般我们会通过下面这几种方式来做“保活”工作，确保连接在被使用的时候是可用状态：</p>
<ul>
<li><p>利用TCP自身的保活（Keepalive）机制来实现，保活机制会定时发送探测报文来识别对方是否可达。一般的默认定时间隔是2小时，你可以根据自己的需要在操作系统层面去调整这个间隔，不管是Linux还是Windows系统。</p>
</li>
<li><p>上层应用主动的定时发送一个小数据包作为“心跳”，探测是否能成功送达到另外一端。 保活功能大多数情况下用于服务端探测客户端的场景，一旦识别客户端不可达，则断开连接，缓解服务端压力。</p>
</li>
</ul>
<p>如果在做了高可用的分布式系统场景中运用长连接会更麻烦一些。因为高可用必然包含自动故障转移、故障隔离等机制。这恰恰导致了一旦发生故障，客户端需要及时发现哪些连接已处于不可用状态，并进行相应的重连，包括重新做负载均衡等工作。</p>
<hr>
<p>短连接意味着每一次的数据传输都需要建立一个新的连接，用完再马上关闭它。下次再用的时候重新建立一个新的连接，如此反复。</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/short-connection.png">
<p>它的优势是由于每次使用的连接都是新建的，所以基本上只要能够建立连接，数据就大概率能送达到对方。并且哪怕这次传输出现异常也不用担心影响后续新的数据传输，因为届时又是一个新的连接。缺点是每个连接都需要经过三次握手和四次握手的过程，耗时大大增加。</p>
<p><strong>此外，短连接还有一个致命的缺点。</strong>前面提到的维基百科对socket的定义，其中说到socket包含通信协议、目标地址、状态等。实际当你在基于socket 进行开发的时候，这些包含的具体资源主要就是这5个：</p>
<ul>
<li>源IP</li>
<li>源端口</li>
<li>目的IP</li>
<li>目的端口</li>
<li>协议</li>
</ul>
<p>有个专业的叫法称之为“五元组”。在一台计算机上只要这五元组的值不重复，那么连接就可以被建立。然而一台计算机最多只能开启65535个端口，如果现在两个进程之间需要通信，作为服务端的IP和端口必然是固定的，因此单个客户端理论上最多只能与服务端同时建立65535个socket连接。</p>
<p>如果除去操作系统和其它进程所占用的端口，实际还会更少。所以，一旦使用不当，在很短的时间内建立了大量连接，端口很容易被占用完。这不但会导致自身无法正常工作，还会影响到同一台计算机上的其它进程。</p>
<h4 id="Application-Scenarios"><a href="#Application-Scenarios" class="headerlink" title="Application Scenarios"></a>Application Scenarios</h4><p>一些监控或者实时报价类系统，比如股票软件，它需要在几秒之内刷新最新的价格。像这种场景中同时包含了需要运用长连接的三个主要因素：</p>
<ul>
<li><p>高频</p>
<blockquote>
<p>因为频次越高的话，使用短连接带来的建立连接和关闭连接的总开销越大。</p>
</blockquote>
</li>
<li><p>服务端主动推送</p>
<blockquote>
<p>而服务端主动推送也需要长连接的原因是，由于服务端往往是“中心化”的，一般都是1个服务端为多个客户端提供服务。所以，如果使用短连接的方式，那么在客户端未主动连接到服务端的情况下，服务端并不知道需要往哪些客户端去推送数据，这是原因之一。所以此时，长连接成为了一个很好的选择。另外一个原因是，哪怕客户端通过定时的短连接轮询方式进行主动连接，除了增加了额外的建立连接和关闭连接的开销外，还可能遇到通信完成后结果数据并未发生变化，做了无用功。</p>
</blockquote>
</li>
<li><p>有状态</p>
<blockquote>
<p>成熟股票软件的服务端，为了支撑更多的用户以及做高可用，必然部署了多台。但是这个业务场景，用户无法容忍由于多个服务端之间数据同步的误差导致他在客户端看到的价格刷新产生“回退”现象。所以，只能尽量保持一直连接在同一台服务器上，才能避免这个情况。这种场景被称之为“有状态”，也可以理解为是“串行”的，因为多次请求的前后需要保持“连续性”。</p>
</blockquote>
</li>
</ul>
<hr>
<p>短连接则更适用于诸如阅读类软件的场景中，例如，很多时候用户点开一篇文章后需要花一些时间进行阅读，这个时间有长有短，并且直到用户下一次操作之前都没有数据传输发生。这个场景中包含了运用短连接的两个主要因素：</p>
<ul>
<li><p>低频</p>
<blockquote>
<p>因为低频，所以更能容忍建立连接和关闭连接的开销。</p>
</blockquote>
</li>
<li><p>无状态</p>
<blockquote>
<p>用户的下一次点击往往跳转到了其它文章，并且新打开的与当前文章并不需要具有“连续性”，所以这种场景我们称之为“无状态”的。另外，理论上同一时刻打开几篇文章也不会存在什么不妥。</p>
</blockquote>
</li>
</ul>
<hr>
<p>通过这两个案例我们可以总结出一个决定何时运用长连接和短连接的最佳实践。</p>
<ul>
<li><p>长连接适用于：两个进程之间需要高频通信并且具备服务端主动推送或者有状态（需串行）两者之一的场景，否则并不是必选项。</p>
</li>
<li><p>短连接适用于：两个进程之间通信频率较低，或者属于无状态（可并行）的场景，否则并不是必选项。</p>
</li>
</ul>
<p>其它情况就根据所需的侧重点来，比如侧重性能就长连接，侧重编码的便捷性就选择短连接。</p>
<p>不过有时候我们可能需要一个中庸的方案来作为默认选择，因为很多场景中的请求并不是平稳的，甚至波动会较大，而且可能同时存在有状态和无状态的场景，此时如果单方面的选择长连接或者短连接都会产生较多的资源浪费。</p>
<p>那么我们可以通过增加一些复杂度来实现一个能够综合长连接和短连接各自优点的方案：<strong>建立多个长连接，每次数据传输的时候独占使用，用完之后放回，再给后续使用。这种方案被称之为“连接池”。</strong></p>
<p>例如, 很多的数据库访问框架都内置了连接池机制，因为作为底层框架的它不知道会被使用到何种场景的系统中，所以提供了这个选项。</p>
<p>一般都会在应用程序启动时预先建立好指定数据量的连接，以更好应对冷启动后请求数快速上升带来的资源竞争问题，这个数量一般称之为最小连接数。另外，如果新的请求进来时，所有已建立的连接都在使用中，但是连接数的上限未达到指定数量，可以再建立新的长连接来使用，用完依旧放回到空闲池，相当于把连接池扩大了，这个上限数量一般称之为最大连接数。</p>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/connection-pools.png">
<hr>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p>TCP作为一种可靠传输控制协议，其核心思想：<strong>既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求</strong>。</p>
<h4 id="TCP可靠传输的精髓"><a href="#TCP可靠传输的精髓" class="headerlink" title="TCP可靠传输的精髓"></a>TCP可靠传输的精髓</h4><p>TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号（Initial Sequence Number），假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003…，并把自己的初始序列号ISN告诉B，让B有一个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001，则意味着字节编号为1001-2000，共1000个字节已经安全到达。</p>
<p>同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003…，并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001，则意味着字节编号为2001-4000，共2000个字节已经安全到达。</p>
<h3 id="TCP握手过程"><a href="#TCP握手过程" class="headerlink" title="TCP握手过程"></a>TCP握手过程</h3><p>A <--> B 的TCP握手过程：</--></p>
<ol>
<li>A 发送同步信号SYN + A’s Initial sequence number</li>
<li>B 确认收到A的同步信号，并记录 A’s ISN 到本地，命名 B’s ACK sequence number</li>
<li>B 发送同步信号SYN + B’s Initial sequence number</li>
<li>A 确认收到B的同步信号，并记录 B’s ISN 到本地，命名 A’s ACK sequence number</li>
</ol>
<p>其中2和3可以合并成一个步骤</p>
<p>为什么是三次握手，而不是四次，甚至五次？</p>
<blockquote>
<p>在Google Groups的TopLanguage中看到一帖讨论TCP“三次握手”觉得很有意思。贴主提出“TCP建立连接为什么是三次握手？”的问题，在众多回复中，有一条回复写道：“这个问题的本质是, 信道不可靠, 但是通信双发需要就某个问题达成一致. 而要解决这个问题, 无论你在消息中包含什么信息, 三次通信是理论上的最小值. 所以三次握手不是TCP本身的要求, 而是为了满足”在不可靠信道上可靠地传输信息”这一需求所导致的. 请注意这里的本质需求,信道不可靠, 数据传输要可靠. 三次达到了, 那后面你想接着握手也好, 发数据也好, 跟进行可靠信息传输的需求就没关系了. 因此,如果信道是可靠的, 即无论什么时候发出消息, 对方一定能收到, 或者你不关心是否要保证对方收到你的消息, 那就能像UDP那样直接发送消息就可以了.”。这可视为对“三次握手”目的的另一种解答思路。</p>
</blockquote>
<img src="/2018/12/07/Network/Socket/What%27s%20socket/tcp-three-times.png">
<ul>
<li><p>第一次握手 - 建立连接</p>
<blockquote>
<p>客户端发送连接请求报文段，将SYN位置为1，<strong>Sequence Number为X</strong>。然后，客户端进入SYN_SEND状态，等待服务器的确认；</p>
</blockquote>
</li>
<li><p>第二次握手 - 服务器收到SYN</p>
<blockquote>
<p>服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，<strong>设置Acknowledgment Number为X+1(Sequence Number+1)</strong>，同时，自己还要发送SYN请求信息，将SYN位置为1，<strong>Sequence Number为Y</strong>。服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态。</p>
</blockquote>
</li>
<li><p>第三次握手 - 客户端收到服务器的SYN</p>
<blockquote>
<p>客户端收到服务器的SYN+ACK报文段。然后将<strong>Acknowledgment Number设置为Y+1</strong>，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
</blockquote>
</li>
</ul>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633</a><br><a href="https://github.com/jawil/blog/issues/14" target="_blank" rel="noopener">https://github.com/jawil/blog/issues/14</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/07/Kubenetes/Timezone/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/07/Kubenetes/Timezone/" itemprop="url">Kuberntes timezone</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-07T11:11:22+08:00">
                2018-12-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Kuberntes/" itemprop="url" rel="index">
                    <span itemprop="name">Kuberntes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>部署应用时，单独读取主机的“/etc/localtime”文件，即创建pod时同步时区，无需修改镜像，但是每个应用都要单独设置。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">myweb</span></span><br><span class="line"><span class="attr">        image:</span> </span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">HostTime</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/etc/localtime</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">HostTime</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/etc/localtime</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/05/Mac/Solution/ShareMem/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/05/Mac/Solution/ShareMem/" itemprop="url">Mac Share Memory</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-05T10:21:22+08:00">
                2018-12-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mac/" itemprop="url" rel="index">
                    <span itemprop="name">Mac</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Mac/Solution/" itemprop="url" rel="index">
                    <span itemprop="name">Solution</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="hdiutil"><a href="#hdiutil" class="headerlink" title="hdiutil"></a>hdiutil</h3><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>创建一个1024MB的ramdisk</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个ramdisk路径，假设返回的路径是 /dev/disk3</span></span><br><span class="line"><span class="comment"># hdiutil attach -nomount ram://$((2 * 1024 * SIZE_IN_MB))</span></span><br><span class="line">hdiutil attach -nomount ram://$((2 * 1024 * 1024))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化</span></span><br><span class="line"><span class="comment"># diskutil eraseVolume HFS+ RAMDisk NAME_OF_DISK</span></span><br><span class="line"><span class="comment"># 访问路径：/Volumes/RAMDisk</span></span><br><span class="line">diskutil eraseVolume HFS+ RAMDisk /dev/disk3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 命令执行输出样例</span></span><br><span class="line"><span class="comment"># Started erase on disk3</span></span><br><span class="line"><span class="comment"># Unmounting disk</span></span><br><span class="line"><span class="comment"># Erasing</span></span><br><span class="line"><span class="comment"># Initialized /dev/rdisk3 as a 1024 MB case-insensitive HFS Plus volume</span></span><br><span class="line"><span class="comment"># Mounting disk</span></span><br><span class="line"><span class="comment"># Finished erase on disk3 RAMDisk</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/04/Java/Advance/Sleep()和wait()/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/04/Java/Advance/Sleep()和wait()/" itemprop="url">Java sleep() 和 wait()</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-04T13:35:06+08:00">
                2018-12-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Advance/" itemprop="url" rel="index">
                    <span itemprop="name">Advance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><p>关于sleep()和wait()，以下描述错误的一项是:</p>
<ul>
<li>A sleep是线程类（Thread）的方法，wait是Object类的方法；</li>
<li>B sleep不释放对象锁，wait放弃对象锁</li>
<li>C sleep暂停线程、但监控状态仍然保持，结束后会自动恢复</li>
<li>D wait后进入等待锁定池，只有针对此对象发出notify方法后获得对象锁进入运行状态</li>
</ul>
<h3 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h3><h4 id="每个对象都有两个池-锁-monitor-池和等待池"><a href="#每个对象都有两个池-锁-monitor-池和等待池" class="headerlink" title="每个对象都有两个池- 锁(monitor)池和等待池"></a>每个对象都有两个池- 锁(monitor)池和等待池</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/03/DB/MySQL/Optimize/MySQL优化原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/DB/MySQL/Optimize/MySQL优化原理/" itemprop="url">MySQL优化原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T13:10:18+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index">
                    <span itemprop="name">DB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/Optimize/" itemprop="url" rel="index">
                    <span itemprop="name">Optimize</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote>
<p>MySQL优化原理1：<a href="https://www.jianshu.com/p/d7665192aaaf" target="_blank" rel="noopener">https://www.jianshu.com/p/d7665192aaaf</a><br>MySQL优化原理2：<a href="https://www.jianshu.com/p/01b9f028d9c7" target="_blank" rel="noopener">https://www.jianshu.com/p/01b9f028d9c7</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/03/DB/KV-System/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/DB/KV-System/" itemprop="url">Key-Value Database System</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:30:18+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index">
                    <span itemprop="name">DB</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Leveldb"><a href="#Leveldb" class="headerlink" title="Leveldb"></a>Leveldb</h3><hr>
<h3 id="Rocksdb"><a href="#Rocksdb" class="headerlink" title="Rocksdb"></a>Rocksdb</h3><hr>
<h3 id="BadgerDB"><a href="#BadgerDB" class="headerlink" title="BadgerDB"></a>BadgerDB</h3><p>BadgerDB is an embeddable, persistent, simple and fast key-value (KV) database written in pure Go. It’s meant to be a performant alternative to non-Go-based key-value stores like RocksDB.</p>
<hr>
<h3 id="Berkerlydb"><a href="#Berkerlydb" class="headerlink" title="Berkerlydb"></a>Berkerlydb</h3><hr>
<h3 id="Accumulo"><a href="#Accumulo" class="headerlink" title="Accumulo"></a>Accumulo</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/03/BlockChain/Terms/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/03/BlockChain/Terms/" itemprop="url">BlockChain Terms</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-03T00:30:18+08:00">
                2018-12-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/BlockChain/" itemprop="url" rel="index">
                    <span itemprop="name">BlockChain</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Keyword"><a href="#Keyword" class="headerlink" title="Keyword"></a>Keyword</h3><ul>
<li>Transaction：次对账本的操作，导致账本状态的一次改变，如添加一条转账记录。</li>
<li>Block：记录一段时间内发生的所有交易和状态结果等，是对当前账本状态的一次共识。</li>
<li>Chain：由区块按照发生顺序串联而成，是整个账本状态变化的日志记录。</li>
<li>PoW(Proof of Work)：工作量证明。</li>
<li>POS(Proof of Stake)：股权证明。</li>
<li>DPOS(Delegated Proof of Stake)：委任权益证明。</li>
<li>PBFT(Practical Byzantine Fault Tolerance)：实用拜占庭容错算法。</li>
<li>Ripple Consensus</li>
</ul>
<hr>
<h4 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h4><p>工作量证明（Proof of Work，简称PoW）为最早的证明方法，也是第一个虚拟币比特币运用的机制。</p>
<p>哈希函数是密码学上计算难度经过反复验证的东西，所以用它来做证明是最有效的，每发出一条信息上传区块链的时候，你要证明你付出了一定的算力，你的证据就是你区块里面的字符串，而加上这个字符串以后，你的区块的哈希值正好小于某个数。</p>
<p>哈希函数的特征告诉我们，你没有任何取巧的方法可以做到这一点，你只能一个个字符串的去尝试。形象来说就是系统为了找出谁有更强大的计算能力，每次会出一道数学题，只有最快解出这道题目的计算机才能进行记账。目前比特币和以太坊均采用此机制。</p>
<p>优点是完全去中心化，节点自有进出，比特币经过了进十年的发展中间经过了黑客攻击、政策限制等不利因素，仍然自我正常运行证明了该工作机制的伟大之处。</p>
<p>缺点POW依赖计算机通过数学运算获取记账权，造成了电力和计算机硬件资源消耗巨大，每次达成共识需要全网所有节点共同参与运算，运行效率低。</p>
<hr>
<h4 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h4><p>权益证明（Proof of Stake，简称PoS）它是PoW的一种升级，主要理念是<strong>节点记账权的获得难度与节点持有的权益成反比</strong>，根据每个节点所占代币的比例和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。</p>
<p>用户可以购买等价的代币，并把这些代币当作押金放入PoS机制中，这样用户就有机会产生新区块而得到奖励。<strong>其在一定程度上减少了数学运算带来的资源消耗，性能也得到了相应的提升，但依然是基于哈希运算</strong>。</p>
<p>这个系统中存在一个持币人的集合，他们把手中的代币放入PoS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块而言，PoS算法在验证者中随机选择一个（选择验证者的权重依据他们投入的代币量，比如一个投入押金为1W代币的验证者被选择的概率是一个投入1K代币验证者的10倍），给他权利产生下一个区块。如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生新区块。与PoW一样，PoS以最长的链为准。</p>
<p>优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。</p>
<p>缺点：还是需要挖矿，本质上没有解决商业应用的痛点；所有的确认都只是一个概率上的表达，而不是一个确定性的事情，理论上有可能存在其他攻击影响，例如以太坊的DAO攻击事件造成以太坊硬分叉，而ETC随之出现，事实上证明了此次硬分叉的失败。</p>
<hr>
<h4 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h4><p>股份授权证明（DPOS）从英文释义上就能看出是源于POS，它与PoS的主要区别在于节点选举若干代理人，由代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。类似于董事会投票，持币者投出一定数量的节点，进行代理验证和记账。</p>
<p>DPoS的工作原理如下：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其挑战是通过及时而高效的方法达到“51%批准”。DPoS的投票模式可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即使发生也可以在几分钟内得到解决。</p>
<p>DPoS的优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。</p>
<p>DPoS的缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。</p>
<hr>
<h4 id="Ripple-Consensus"><a href="#Ripple-Consensus" class="headerlink" title="Ripple Consensus"></a>Ripple Consensus</h4><p>瑞波共识机制（Ripple Consensus）算法使一组节点能够基于特殊节点列表形成共识。初始特殊节点列表就像一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。</p>
<p>共识遵循这些核心成员的“51%权利”，外部人员则没有影响力。由于该俱乐部由中心化开始，它将一直是中心化的，而如果它开始腐化，股东们什么也做不了。与比特币及Peercoin一样，瑞波系统将股东们与其投票权隔开，因此，它比其他系统更中心化。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://www.zhihu.com/question/46729645" target="_blank" rel="noopener">https://www.zhihu.com/question/46729645</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/" itemprop="url">从ACID聊到CAP，再到BASE</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-02T19:50:18+08:00">
                2018-12-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DistributedSystem/" itemprop="url" rel="index">
                    <span itemprop="name">DistributedSystem</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DistributedSystem/CAP/" itemprop="url" rel="index">
                    <span itemprop="name">CAP</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>在使用数据库的时候，心里会假定这里面的数据都是 100% 准确的。回想一下，你在工作中有没有这样做过：</p>
<ul>
<li>有人给你反映了一个问题，说数据错了，你的自然反应是去检查代码有没有问题，而不会想到去确认数据库有没有问题？</li>
<li>为了更快更方便地执行单元测试，你认为通过 Mock 数据加上断言（assertion）来代替数据库中实际存储的数据是完全没问题的。</li>
</ul>
<p>如果你这样做过，或者有过这样的看法，那你一定是在假定：<strong>数据都是100%准确的</strong>。</p>
<p>现在不妨来思考下，数据库为什么会使你有这样的认知？是因为数据库的开发团队对其测试到位吗？其实，真正起到决定性作用的是数据库背后的设计理念<strong>ACID</strong>。</p>
<h3 id="What’s-ACID"><a href="#What’s-ACID" class="headerlink" title="What’s ACID"></a>What’s ACID</h3><p>ACID: Atomicity, Consistency, Isolation, Durability。</p>
<p>Andreas Reuter 和 TheoHärder 这两位前辈在 1983 年提出它，指出一个数据库“事务”只要满足这4个特性，在任何情况下数据都能保证准确。</p>
<p><strong>“事务”是数据库的执行单元</strong>，除了我们平时用显式声明的 <strong>transaction</strong> 之类关键字包裹的代码外，每一条单独的SQL，也是以事务的形式执行的。比如，当你在一条SQL中同时 insert 多笔数据的时候，一旦发生异常，所有的这几笔数据最终都不会被插入到目标表中，会一并撤销。</p>
<p>在保证达到这个效果的过程中，ACID的四个特性分别起到了什么作用呢？</p>
<hr>
<h4 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h4><p>一句话来概括原子性，用于保证每个事务被视为单个完整的个体，不可分割。满足原子性的事务，要么完全成功，要么完全失败，不允许存在其他中间状态。</p>
<p>通常这点指的是我们同时执行多条SQL语句的时候，可以将这些SQL语句的生效与否捆绑到一起，以保证最终要么全部数据被更新到数据库，要么全部都不更新到数据库。</p>
<p><strong>Example: 小明让小王代购了一些东西回来，需要在微信上支付给他1000元</strong></p>
<p>当小明输入完金额点击“确认转账”之后，执行的 SQL 至少是这样的：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> balance = balance - <span class="number">1000</span> <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'小明的 id'</span><span class="string">``</span></span><br><span class="line"><span class="keyword">update</span> balance = balance + <span class="number">1000</span> <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'小王的 id'</span></span><br></pre></td></tr></table></figure>
<p>注意，这两条语句中只要任意一条执行失败，而另外一条执行成功，那么从原子性的要求来说，所有执行成功的修改都需要一并撤销，恢复到最初的状态，这个撤销操作我们称为“回滚”。否则，微信体系中的总余额会无故多出或少了 1000 元。</p>
<p>数据库中原子性的主流实现方案是通过日志来做的，每一次操作数据前都会先将当前数据记录到日志中，这样在需要回滚时，我们只要把 Undo Log 中的数据拿出来还原，就可以撤销已经执行成功的操作。</p>
<p>原子性是四个特性中最核心的一个，仅关注当前的这一次操作，不考虑是否存在其它的什么操作。</p>
<hr>
<h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>在上面小明和小王的故事中，如果再出现一个人小张，他也让小王代购了东西要付钱，会出现新的情况，例如</p>
<img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-1.png">
<p>注意一下红字部分。我们发现，这个时候哪怕两次转账的事务分别保证了原子性，并且执行成功，最终的结果还是有可能出错。</p>
<p>上图中的现象，我们称为“丢失更新”（Lost Update）。当然，还有其他可能产生的现象，比如脏读、不可重复读、幻读，等等。</p>
<p>不过，我们暂时不需要过多纠结于这些现象，只要记得：<strong>当仅满足原子性的前提下，如果遇到并发执行，依旧会出现数据错误</strong>。</p>
<p>所以，这时候我们需要通过隔离性的指导来避免这些问题。<strong>隔离性本质上指导解决的是一个资源竞争问题，通俗点说，就是多个事务并发执行后的状态，应该和它们串行执行后的状态是一致的</strong>。</p>
<p>在数据库中解决资源竞争问题与其它软件系统无异，就用锁。在数据库中对锁的运用不同，因此产生了不同的隔离级别，不同的隔离级别对应解决的是前面提到的这些异常现象。</p>
<ul>
<li>读未提交（Read Uncommitted）解决了丢失更新</li>
<li>读已提交（Read committed）多解决了脏读</li>
<li>可重复读（Repeatable Read）又多解决了不可重复读问题</li>
<li>最高级别的可序列化（Serializable）解决了全部这 4 个问题，即丢失更新、脏读、不可重复度、幻读。</li>
</ul>
<img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-2.png">
<blockquote>
<p>脏读：一个事务中读到(SELECT)了另一个事务还没有提交更新的数据。<br>不重复读：在同一个事务里，前后两次相同的SELECT语句会读到不同的结果。侧重点在于更新修改数据。<br>幻读：表示在同一事务中，使用相同的查询语句，第二次查询时，莫名的多出了一些之前不存在数据，或者莫名的不见了一些数据。幻读与不可重复读的区别：幻读的侧重点在于新增和删除。</p>
</blockquote>
<p>其实在实际的运用中，遇到的场景会更复杂，所以詹姆士·格雷（Jim Gray）等人在 1995 发表了论文“对 ANSI SQL 隔离级别的批评（A Critique of ANSI SQL Isolation Levels）”将上表做了扩充，增加了<strong>游标稳定（Cursor Stability）</strong>和<strong>快照隔离（Snapshot Isolation）</strong>隔离级别，指导我们在做隔离时，可以为获得更好的性能进行一些新的尝试。</p>
<hr>
<h4 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h4><p>当你使用一些云产品写文章的时候，洋洋洒洒写了几千字，安心睡觉去了，第二天起来发现内容停留在刚起笔的那几个字。任何的数据变更完成之后，就相当于成为了“历史”，需要保存下来才能为未来所用。因此数据库需要具备持久性，才能为我们所依赖用于存储数据。</p>
<p>如今，我们几乎都是利用硬盘作为数据库的存储介质，来保证持久性。那么理论上，除非硬盘本身故障，否则都不应该出现这样一种情况：一条SQL变更成功后，发生数据丢失或者数据回到更早的状态。</p>
<hr>
<h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p><strong>一致性的含义其实很简单，就是最终结果的对与错，是否是你所希望的结果。</strong>任何系统如果无法确保产生的数据结果与预期一致，那么整个系统其实是没有价值的。</p>
<p>回到前面小明和小王的例子。只要小明账户少了1000元，小王账户必须要多出1000元，这才是我们所希望的结果，否则都是错的，也就是“不一致”的。</p>
<p>这么一说，一致性和原子性意思好像差不多啊？关于这点可以这样来理解：</p>
<ul>
<li>原子性关注的是关系和过程，确保指定的SQL之间是一个命运共同体。比如鸡蛋孵小鸡这个过程，必然是鸡蛋破了后小鸡再出来，而不是鸡蛋破了，小鸡不见了或者鸡蛋没破，不知道从哪哪冒出来个小鸡。</li>
<li>而一致性关注的是结果，这个结果的预期是你来定的，如何达到这个结果的过程并不是它所包含的概念。还是鸡蛋孵小鸡这个事，比如你预期一个鸡蛋里只能孵出一个小鸡，那么如果最终9个鸡蛋里出现了10个小鸡，这时就是不一致的。</li>
</ul>
<p>由于一致性只表示一个结果，它只是指引出一个正确的工作方向。而要达到这个正确的结果并不完全是由数据库保证的，它只是一个按规则办事的“监督者”。</p>
<p>但是，它提供了主键、外键、约束、字段类型等，让你可以在不同层面上定义什么是“一致”。一旦不符合你的定义，数据库就会抛出异常来提醒你，这里不符合你的预期了。</p>
<hr>
<h3 id="ACID-间的联系"><a href="#ACID-间的联系" class="headerlink" title="ACID 间的联系"></a>ACID 间的联系</h3><p>原子性（A）、隔离性（I）、持久性（D）是为达到一致性（C）而存在的。</p>
<img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-3.png">
<p>可以理解为，只要满足了原子性（A）、隔离性（I）、持久性（D）那么数据存储层面的一致性（C）自然也就满足了。</p>
<p>不过，站在一个完整的系统角度来说，要达到真正的一致性，还需要我们在Coding的时候有意识的去定义达到“正确结果”的代码逻辑。</p>
<hr>
<h3 id="What’s-CAP"><a href="#What’s-CAP" class="headerlink" title="What’s CAP"></a>What’s CAP</h3><p>聊ACID的原因是为了引出分布式系统中的一个经典定理——CAP。</p>
<p><strong>CAP是指导我们进行多进程之间交互的设计理论</strong>，告诉我们该如何去权衡一致性（C）、可用性（A）、分区容错性（P），这也是它这三个字母所表达的含义。</p>
<blockquote>
<p><strong>Robert Greiner CAP</strong><br>第一版：<br>Any distributed system can’t guaranty C, A, and P simultaneously.<br>第二版：<br>In a distributed system (a collection of interconnected nodes that share data), you can only have two out of(从..) the following three guarantees across a write/read pari:<br>Consistency, Availability, and Partition Tolerance - one of them must be sacrified.</p>
</blockquote>
<p>两个版本的差异点：</p>
<ul>
<li>第二版定义了什么才是CAP理论探讨的分布式系统（强调interconnected and share data）。为什么要强调这两点？因为分布式系统并不一定会互联和共享数据。比如Memcache，相互之间就没有连接和共享数据，因此Memcache集群并不符合CAP理论探讨的对象。而MySQL集群就是互联和进行数据复制的，因此是CAP理论探讨的对象。</li>
<li>第二版强调了 write/read pair，CAP关注的是对数据的读写操作，而不是分布式系统的所有功能。例如，ZooKeeper的选举机制就不是CAP探讨的对象。</li>
</ul>
<p>如果你知道分布式系统理论中的CAP定理，肯定会好奇ACID和CAP两者定义的“一致性”表示的是不是同一个意思。其实不是：</p>
<ul>
<li>描述的主体不同，ACID中的C指的是数据库事务的一致性，而CAP中的C指的是程序之间请求的一致性。</li>
<li>对结果的定义也有些差异，CAP中的C除了一致性之外还带着一些原子性的意思，一次操作中产生的多个请求要被视为一个完整的个体，不可分割，这个特点和数据库中的原子性是一致的。</li>
</ul>
<p>所以你会发现，CAP定理中所表述的“一个请求”类似于数据库ACID中的“一条SQL”，并且还保留了原子性和一致性的含义。然后基于分布式的场景，衍生了分区容错性以及可用性的概念。CAP定理作为后来者，为分布式系统而生，是分布式系统设计的指导方针。理解了 ACID，更有利于你去理解 CAP。</p>
<hr>
<h4 id="Consistency-1"><a href="#Consistency-1" class="headerlink" title="Consistency"></a>Consistency</h4><blockquote>
<p>第一版：<br>All nodes see the same data at the same time.<br>第二版：<br>A read is guraranteed to return the most recent write for a given client</p>
</blockquote>
<p>两个版本差异点：</p>
<ul>
<li>第一版从Node角度描述，第二版从Client的角度描述。第二版更符合我们观察和评估系统的方式，即站在客户端的角度来观察系统的特征和行为。</li>
<li>第一版关键词<strong>see</strong>，第二版<strong>read</strong>。第二版从Client的读写角度来描述一致性，定义更加精确。</li>
<li>第一版强调同一时刻所有Node拥有相同的数据，第二版强调Client读取到总是最新的数据（这对于集群中的多个节点来说，可能在同一时刻拥有不同的数据。对于系统执行事务来说，在事务过程中，系统其实处于一个不一致的状态，不同节点的数据并不完全一致，此时Client是无法读取到没有提交的数据。但是当事务提交以后，Client是可以读取到事务写入的数据，如果事务失败则会进行回滚，Client也不会读取到事务中间写入的数据）。</li>
</ul>
<hr>
<h4 id="Available"><a href="#Available" class="headerlink" title="Available"></a>Available</h4><blockquote>
<p>第一版：<br>Every request gets a response on success / failure.<br>第二版：<br>A non-failing node will return a reasonable response within a reasonable amount of time(no error or timeout).</p>
</blockquote>
<p>两个版本的差异：</p>
<ul>
<li>第一版强调 every request，第二版强调 a non-failing node。第一版并不严谨，因为只有非故障节点才能满足可用性要求，如果节点本身就故障了，发给节点的请求不一定就能得到一个响应。</li>
<li>第一版的 success / failure 太宽泛，在实际中没有指导意义，第二版明确了不能超时和不能出错，但要提出合理的结果，需要注意的是没有说”正确”的结果，例如，应该返回200但实际是301，肯定是不正确的结果，但是一个合理的结果。</li>
</ul>
<hr>
<h4 id="Partition-Tolerance"><a href="#Partition-Tolerance" class="headerlink" title="Partition Tolerance"></a>Partition Tolerance</h4><blockquote>
<p>第一版：<br>System continues to work despite message loss or partial failure.<br>第二版：<br>The system will continue to funtion when network partitions occur.</p>
</blockquote>
<p>两个版本的差异：</p>
<ul>
<li>第一版用workd，第二版用function。work强调运行，只要系统不宕机，都可以说系统在work，即使返回错误，或拒绝服务都是在work。function强调履行其职能（正确地发挥其功能作用），即返回reasonable response。</li>
<li>第一版描述分区用的是message loss or partial failure，第二版直接用network partitions。第一版只是说明了message loss造成了分区，但没有详细解释message loss指的是什么，如果说的是丢包，那就太狭隘了，因为它只是网路故障中的一种。而第二版直接说现象，即发生了分区现象。造成这个现象的原因可能是丢包，连接中断或拥塞等等，只要导致了网络分区，就通通算在一起。</li>
</ul>
<hr>
<h3 id="CAP应用"><a href="#CAP应用" class="headerlink" title="CAP应用"></a>CAP应用</h3><p>CAP理论定义是三个要素中只能取两个，但是在实际的分布式环境中，P是一个必要的要素，因为网络本身无法做到100%可靠，所以分区是一个必然的现象。</p>
<p>假如我们选择CA（放弃P），那么当发生分区现象时，为了保证C，系统需要禁止写入操作，因为当有写入请求时，系统返回error。这又和A冲突了，因为A要去返回no error和no timeout。因此分布式系统理论上不可能选择CA架构，只能选CP或AP架构。</p>
<hr>
<h4 id="CP架构"><a href="#CP架构" class="headerlink" title="CP架构"></a>CP架构</h4><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-4.png">
<p>假设，此时所有Node上面的index=0。</p>
<p>为了保证一致性，当分区现象发生后，Node1节点上的index已经更新为1，但由于Node1与Node2之间的网络出了问题，造成数据同步失败，Node2上的index仍然为0。</p>
<p>此时客户端访问Node2，Node2因为C的要求，Node2需要返回Error信息，提示客户端“系统发生了错误”，这种方式违背了A的要求，因此CAP三者只能满足CP。</p>
<hr>
<h4 id="AP架构"><a href="#AP架构" class="headerlink" title="AP架构"></a>AP架构</h4><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-4.png">
<p>假设，此时所有Node上面的index=0。</p>
<p>为了保证可用性，当分区现象发生后，Node1节点上的index已经更新为1，但由于Node1与Node2之间的网络出了问题，造成数据同步失败，Node2上的index仍然为0。</p>
<p>此时客户端访问Node2，Node2因为A的要求，Node2将当前index=0的数据返回给客户端，而实际上当前最新的数据是index=1，这就不满足C的要求了，因此CAP三者只能满足CP。</p>
<hr>
<h4 id="CPA关注的粒度是数据，而不是整个系统"><a href="#CPA关注的粒度是数据，而不是整个系统" class="headerlink" title="CPA关注的粒度是数据，而不是整个系统"></a>CPA关注的粒度是数据，而不是整个系统</h4><p>每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择CP，有的数据必须选择AP。</p>
<p>如果我们在做设计时，从整个系统的角度去选择CP还是AP，就会发现顾此失彼，无论怎么做都是有问题的。</p>
<p>例如，SSO系统包含用户账号信息（用户ID和密码）、用户其他信息（昵称、性别、手机号等等）。</p>
<p>通常情况下，用户账号数据会选择CP，而用户其他信息会选择AP。如果限定了整个系统为CP，则不符合用户其他信息的应用场景，同理可知，限定系统为AP也是不行的。</p>
<p>例如，账户资金系统，用户可用余额信息选择CA（例如，避免双花问题），用户账户流水信息选择AP或CP。</p>
<p>所以在CAP理论落地实践时，需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（AP或CP），而不是直接限定系统所有数据都是同一个策略。</p>
<hr>
<h4 id="CAP是忽略网络延迟的"><a href="#CAP是忽略网络延迟的" class="headerlink" title="CAP是忽略网络延迟的"></a>CAP是忽略网络延迟的</h4><p>Eric Brewer在定义一致性时，并没有把延迟考虑进去。即当事务提交时，数据能够瞬间复制到所有节点。</p>
<p>但实际情况下，从节点A复制到节点B，总是要花费一定时间的。如果是同机房，耗费时间可能是几毫秒；如果是跨地区的机房，耗费的时间可能是几十毫秒。这就意味着节点A和节点B的数据并不一致。</p>
<p>对于某些严苛的业务场景，例如和金钱相关的用户余额和抢购相关的商品库存，技术上是无法做到分布式场景下完美的一致性。而业务上必须要求一致性，因此单个用户的余额、单个商品的库存，理论上要求选择CP而实际上CP都做不到，只能选择CA。也就是说，只能单点写入，其他节点做备份，无法做到分布式情况下多点写入。</p>
<p>在这种情况下，并不意味着这类系统无法应用分布式架构，只是说“单个用户余额、单个商品库存”无法做到分布式，但系统整体还是可以应用分布式架构的。</p>
<p>例如，将用户分区的分布式架构图</p>
<img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-5.png">
<p>把用户分散在不同的Node上，即使某个Node出现了故障，也仅仅是部分用户不能操作，但是大部分用户还是可以进行正常操作的。</p>
<hr>
<h4 id="正常运行情况下，不存在CP和AP的选择，可以同时满足CA"><a href="#正常运行情况下，不存在CP和AP的选择，可以同时满足CA" class="headerlink" title="正常运行情况下，不存在CP和AP的选择，可以同时满足CA"></a>正常运行情况下，不存在CP和AP的选择，可以同时满足CA</h4><p>CAP理论告诉我们，分布式系统只能选择CP或AP，前提条件是“系统发生了分区现象”。如果没有发生分区现象，即P不存在的时候（节点间的网络一切正常），此时没有必要放弃C或A，CA都可以保证。</p>
<p>这就要求架构设计的时候既要考虑分区发生时选择CP还是CA，也要考虑分区没有发生时如何保证CA。</p>
<p>例如，SSO系统中，用户账户数据可以通过消息队列实现CA；用户信息可以采用“数据库同步”的方式实现CA。</p>
<hr>
<h4 id="放弃不等于什么都不做，需要为分区恢复做准备"><a href="#放弃不等于什么都不做，需要为分区恢复做准备" class="headerlink" title="放弃不等于什么都不做，需要为分区恢复做准备"></a>放弃不等于什么都不做，需要为分区恢复做准备</h4><p>CAP理论的“牺牲”只是说在分区过程中我们无法保证C或A，但并不意味着我们什么都不做。因为在系统整个运行周期中，大部分时间都是正常的，发生分区现象的时间并不长。</p>
<p>例如，99.99%可用性的系统，一年运行下来，不可用的时间只有50分钟、99.999%可用性的系统，不可用的时间只有5分钟。</p>
<p>分区期间放弃C或A，并不意味着永远放弃C和A，我们在分区期间进行一些操作，从而让分区故障解决后，系统能够重新达到CA的状态。</p>
<p>比较常见的解决方案是，在分区期间记录一些日志，当分区故障解决后，系统根据日志进行数据恢复，使得重新达到CA状态。</p>
<hr>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><p>BASE: Basically Available, Soft State, Eventually Consistency</p>
<hr>
<h4 id="Basically-Available"><a href="#Basically-Available" class="headerlink" title="Basically Available"></a>Basically Available</h4><p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p>
<p>例如，SSO系统，核心是登录功能，部分是注册功能。</p>
<hr>
<h4 id="Soft-State"><a href="#Soft-State" class="headerlink" title="Soft State"></a>Soft State</h4><p>允许系统存在中间状态，而中间状态不会影响系统整体可用性。这里的中间状态就是CAP理论中的数据不一致性。</p>
<hr>
<h4 id="Eventually-Consistency"><a href="#Eventually-Consistency" class="headerlink" title="Eventually Consistency"></a>Eventually Consistency</h4><p>系统中所有数据副本经过<strong>一定时间</strong>后，<strong>最终</strong>能够达到一致的状态。</p>
<p>这里的“最终”和“一定时间”，与数据的特性是强关联的，不同的数据能够容忍的不一致时间是不同的。</p>
<p>例如，用户账号数据最好能在一分钟就达到一致状态，因为用户在节点A注册或登录后，1分钟内不太可能立刻切换到另一个节点，但10分钟后可能就重新登录到另一个节点。</p>
<p>用户发布的最新微博，可以容忍30分钟内达到一致状态。因为对于用户来说，看不到某个明星发布的最新微博，用户是无感知的，会认为明星没有发布微博。</p>
<p>“最终”的含义就是不管多长时间，最终还是要达到一致性的状态。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>BASE理论本质上是对CAP的延伸和补充，更具体地说，是对CAP中AP方案的一个补充。</p>
<ul>
<li><p>CAP理论是忽略延时的，而实际应用中延时是无法避免的。</p>
<blockquote>
<p>这一点就意味着完美的CP场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合CP要求的。因此CAP中的CP方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒。</p>
</blockquote>
</li>
<li><p>AP方案中牺牲一致性只是指分区期间，而不是永远放弃一致性。</p>
<blockquote>
<p>这一点其实就是BASE理论延伸的地方，分期区间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。</p>
</blockquote>
</li>
</ul>
<p>对于ACID，CAP和BASE对比分析总结：</p>
<ul>
<li>ACID是数据库事务完整性的理论</li>
<li>CAP是分布式系统的设计理论</li>
<li>BASE是CAP理论中AP方案的延伸</li>
</ul>
<hr>
<h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote>
<p><a href="https://www.infoq.cn/article/Q1Dlq-tcyjEX6GVmRuoy" target="_blank" rel="noopener">https://www.infoq.cn/article/Q1Dlq-tcyjEX6GVmRuoy</a><br><a href="http://www.zsythink.net/archives/1233" target="_blank" rel="noopener">http://www.zsythink.net/archives/1233</a><br>Robert Greiner CAP 1.0: <a href="http://robertgreiner.com/2014/06/cap-theorem-explained/" target="_blank" rel="noopener">http://robertgreiner.com/2014/06/cap-theorem-explained/</a><br>Robert Greiner CAP 2.0: <a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" target="_blank" rel="noopener">http://robertgreiner.com/2014/08/cap-theorem-revisited/</a><br>Zookeeper的Leader选举: <a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/6107600.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/53/">53</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jason - sulang357159@163.com">
          
            <p class="site-author-name" itemprop="name">Jason - sulang357159@163.com</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">527</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">236</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">589</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason - sulang357159@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
