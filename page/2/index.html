<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="true">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="A Big Boy Blog -  Tech Articls & Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta property="og:type" content="website">
<meta property="og:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:url" content="https://sulangsss.github.io/page/2/index.html">
<meta property="og:site_name" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sulangsss.github.io/page/2/">





<meta name="baidu-site-verification" content="xV2vphJ53Q">


  <title>A Big Boy Blog -  Tech Articls & Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?344f3e8f33d176fceb44e65d30a341dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">A Big Boy Blog -  Tech Articls & Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Python Java Android Django Web -> sulang357159@gmail.com</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/17/SpringBoot/Eureka/Theory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/SpringBoot/Eureka/Theory/" itemprop="url">深入学习 Eureka 原理</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T11:50:06+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/Eureka/" itemprop="url" rel="index">
                    <span itemprop="name">Eureka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Eureka包含两个组件：Eureka Server和Eureka Client。</p>
<ul>
<li>Eureka Server 提供服务注册服务，各个节点启动后会在 Eureka Server 中进行注册，这样 EurekaServer 中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观的看到。</li>
<li>Eureka Client 是一个java客户端，用于简化与 Eureka Server 的交互，客户端同时也就是一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</li>
</ul>
<h4 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h4><p>从 CAP 理论看，Eureka 是一个 AP 系统，优先保证可用性A 和 分区容错性P，不保证强一致性C，只保证最终一致性，因此在架构中设计了较多缓存。</p>
<img src="/2019/10/17/SpringBoot/Eureka/Theory/eureka-process-structure.png">
<p>Feature：</p>
<ul>
<li>Eureka 不持久化缓存，重启后内存数据丢失；</li>
<li>Eureka 通过增量更新注册信息，只关心瞬时状态；</li>
<li>Eureka 提供客户端缓存，宁可返回某服务5分钟之前可用的服务器列表信息，也不能因为暂时的网络故障而找不到可用的服务器，满足 CAP 中的 AP。</li>
</ul>
<h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><img src="/2019/10/17/SpringBoot/Eureka/Theory/eureka-cache-structure.png">
<p>Eureka Server 存在三个变量(三级缓存机制)：</p>
<ul>
<li>registry(ConcurrentHashMap)：实时更新，类 AbstractInstanceRegistry 成员变量，UI 端请求的是这里的服务注册信息。</li>
<li>readWriteCacheMap(Guava Cache/LoadingCache)：实时更新，类 ResponseCacheImpl 成员变量，缓存时间 180 秒。</li>
<li>readOnlyCacheMap(ConcurrentHashMap)：周期更新，类 ResponseCacheImpl 成员变量，默认每30s从 readWriteCacheMap 更新，Eureka client 默认从这里更新服务注册信息，可配置直接从 readWriteCacheMap 更新</li>
</ul>
<p>Eureka Server 通过上面的三个变量来保存服务注册信息。默认情况下定时任务每 30s 将 readWriteCacheMap 同步至 readOnlyCacheMap，每 60s 清理超过 90s 未续约的节点，Eureka Client 每 30s 从 readOnlyCacheMap 更新服务注册信息，而 UI 则从 registry 更新服务注册信息。</p>
<p><strong>Association attributes：</strong></p>
<ul>
<li>eureka.instance.lease-expiration-duration-in-seconds：Server 至上一次收到 Client 的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该 Instance。</li>
<li><blockquote>
<p>默认为90秒；</p>
</blockquote>
</li>
<li><blockquote>
<p>如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了；</p>
</blockquote>
</li>
<li><blockquote>
<p>如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉；</p>
</blockquote>
</li>
<li><blockquote>
<p>该值至少应该大于leaseRenewalIntervalInSeconds</p>
</blockquote>
</li>
<li><p>eureka.server.enable-self-preservation：是否开启自我保护模式，默认为true。</p>
</li>
<li>eureka.server.eviction-interval-timer-in-ms：Server 清理无效节点的时间间隔，默认60000毫秒，即60秒。</li>
<li>eureka.server.useReadOnlyResponseCache：是否使用 readOnlyCacheMap，默认为true。</li>
<li>eureka.server.responseCacheUpdateIntervalMs：readWriteCacheMap 更新至 readOnlyCacheMap 周期，默认30s。</li>
<li>eureka.server.responseCacheAutoExpirationInSeconds：Server 缓存readWriteCacheMap失效时间，缓存默认180s。</li>
</ul>
<h4 id="Eureka-Client"><a href="#Eureka-Client" class="headerlink" title="Eureka Client"></a>Eureka Client</h4><p>Eureka Client存在两种角色：服务提供者和服务消费者，作为服务消费者一般配合Ribbon或Feign（Feign内部使用Ribbon）使用。</p>
<p>Eureka Client启动后，作为服务提供者立即向 Server 注册，默认情况下每30s续约(renew)；作为服务消费者立即向 Server 全量更新服务注册信息，默认情况下每30s增量更新服务注册信息；Ribbon 延时1s向 Client 获取使用的服务注册信息，默认每30s更新使用的服务注册信息，只保存状态为UP的服务。</p>
<p><strong>Association attributes：</strong></p>
<ul>
<li>eureka.instance.lease-renewal-interval-in-seconds：Client 发送心跳给 Server 端的频率，默认为30秒。如果该instance实现了 HealthCheckCallback，并决定让自己 unavailable 的话，则该 Instance 也不会接收到流量。</li>
<li>eureka.client.registry-fetch-interval-seconds：Client 间隔多久去拉取服务注册信息，默认为30秒，对于 api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒。</li>
<li>eureka.client.registryFetchIntervalSeconds：Client 增量更新周期，默认30s（正常情况下增量更新，超时或与 Server 端不一致等情况则全量更新）。</li>
<li>ribbon.ServerListRefreshInterval：Ribbon 更新周期，默认30s。</li>
</ul>
<p>Process：</p>
<ul>
<li>EurekaClient 第一次全量拉取，定时增量拉取应用服务实例信息，保存在缓存中：</li>
<li>EurekaClient 增量拉取失败，或者增量拉取之后对比 hashcode 发现不一致，就会执行全量拉取，这样避免了网络某时段分片带来的问题；</li>
<li>对于服务调用，如果涉及到 ribbon 负载均衡，那么 ribbon 对于这个实例列表也有自己的缓存，这个缓存定时从 EurekaClient 的缓存更新；</li>
</ul>
<hr>
<h3 id="Registry-And-Discovery"><a href="#Registry-And-Discovery" class="headerlink" title="Registry And Discovery"></a>Registry And Discovery</h3><img src="/2019/10/17/SpringBoot/Eureka/Theory/register-and-discovery.png">
<blockquote>
<p>如果 Server-A 向 Server-B 节点单向注册，则 Server-A 视 Server-B 为 peer Server-A 接受的数据会同步给 Server-B，但 Server-B 接受的数据不会同步给 Server-A。</p>
</blockquote>
<p>Registry Process：</p>
<ol>
<li>将实例注册信息放入或者更新 Registry：</li>
<li>实例注册信息加入最近修改的记录队列；</li>
<li>主动让 Response 缓存失效；</li>
</ol>
<p>Unregister Service Process：</p>
<ol>
<li>从 Registry 中剔除这个实例；</li>
<li>将实例注册信息加入最近修改的记录队列；</li>
<li>主动让 Response 缓存失效；</li>
</ol>
<hr>
<h3 id="Peer-to-Peer-Communication"><a href="#Peer-to-Peer-Communication" class="headerlink" title="Peer to Peer Communication"></a>Peer to Peer Communication</h3><p>Eureka clients tries to talk to Eureka Server in the same zone. If there are problems talking with the server or if the server does not exist in the same zone, the clients fail over to the servers in the other zones.</p>
<p>Once the server starts receiving traffic, all of the operations that is performed on the server is replicated to all of the peer nodes that the server knows about. If an operation fails for some reason, the information is reconciled(一致) on the next heartbeat that also gets replicated between servers.</p>
<p>When the Eureka server comes up, it tries to get all of the instance registry information from a neighboring node. If there is a problem getting the information from a node, the server tries all of the peers before it gives up. If the server is able to successfully get all of the instances, it sets the renewal threshold that it should be receiving based on that information. If any time, the renewals(续期) falls below the percent configured for that value (<strong>below 85% within 15 mins</strong>), the server stops expiring instances to protect the current instance registry information.</p>
<p>In Netflix, the above safeguard is called as <strong>self-preservation mode</strong> and is primarily used as a protection in scenarios where there is a network partition between a group of clients and the Eureka Server. In these scenarios, the server tries to protect the information it already has. There may be scenarios in case of a mass outage(中断) that this may cause the clients to get the instances that do not exist anymore. The clients must make sure they are resilient(能复原的) to eureka server returning an instance that is non-existent or un-responsive. The best protection in these scenarios is to timeout quickly and try other servers.</p>
<hr>
<h3 id="默认配置下服务消费者最长感知时间"><a href="#默认配置下服务消费者最长感知时间" class="headerlink" title="默认配置下服务消费者最长感知时间"></a>默认配置下服务消费者最长感知时间</h3><h4 id="正常上线"><a href="#正常上线" class="headerlink" title="正常上线"></a>正常上线</h4><p>数据流：readWrite -&gt; readOnly -&gt; Client -&gt; Ribbon</p>
<p>预估：30(readOnly) + 30(Client) + 30(Ribbon) = 90s</p>
<h4 id="正常下线"><a href="#正常下线" class="headerlink" title="正常下线"></a>正常下线</h4><p>数据流：readWrite -&gt; readOnly -&gt; Client -&gt; Ribbon</p>
<p>预估：30(readOnly) + 30(Client Fetch) + 30(Ribbon) = 90s</p>
<p>服务正常下线（kill或kill -15杀死进程）会给进程善后机会，DiscoveryClient.shutdown() 将向 Server 更新自身状态为 DOWN，然后发送 DELETE 请求注销自己，registry 和 readWriteCacheMap 实时更新，故UI将不再显示该服务实例。</p>
<blockquote>
<p>SpringBoot 下线是否会默认调用 DiscoveryClient.shutdown()？</p>
</blockquote>
<h4 id="非正常下线"><a href="#非正常下线" class="headerlink" title="非正常下线"></a>非正常下线</h4><p>预估：90(LeaseExpiration)*2 + 30(readOnly) + 30(Client Fetch) + 30(Ribbon) = 270s</p>
<p>服务非正常下线（kill -9杀死进程或进程崩溃）不会触发 DiscoveryClient.shutdown() 方法，Eureka Server 将依赖每60s清理超过90s未续约服务从 registry 和 readWriteCacheMap 中删除该服务实例。</p>
<h4 id="优化配置"><a href="#优化配置" class="headerlink" title="优化配置"></a>优化配置</h4><p><strong>Server Configuration</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 中小规模下，自我保护模式坑比好处多，所以关闭它</span></span><br><span class="line"><span class="string">eureka.server.enableSelfPreservation=false</span></span><br><span class="line"><span class="comment">## 心跳阈值计算周期，如果开启自我保护模式，可以改一下这个配置</span></span><br><span class="line"><span class="comment">## eureka.server.renewalThresholdUpdateIntervalMs=120000</span></span><br><span class="line"><span class="comment">## 主动失效检测间隔,配置成5秒</span></span><br><span class="line"><span class="string">eureka.server.evictionIntervalTimerInMs=5000</span></span><br><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line"><span class="string">eureka.instance.leaseRenewalIntervalInSeconds=5</span></span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line"><span class="string">eureka.instance.leaseExpirationDurationInSeconds=10</span></span><br><span class="line"><span class="comment">## 禁用readOnlyCacheMap</span></span><br><span class="line"><span class="string">eureka.server.useReadOnlyResponseCache=false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Client Configuration</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 心跳间隔，5秒</span></span><br><span class="line"><span class="string">eureka.instance.leaseRenewalIntervalInSeconds=5</span></span><br><span class="line"><span class="comment">## 没有心跳的淘汰时间，10秒</span></span><br><span class="line"><span class="string">eureka.instance.leaseExpirationDurationInSeconds=10</span></span><br><span class="line"><span class="comment"># 定时刷新本地缓存时间</span></span><br><span class="line"><span class="string">eureka.client.registryFetchIntervalSeconds=5</span></span><br><span class="line"><span class="comment"># ribbon缓存时间</span></span><br><span class="line"><span class="string">ribbon.ServerListRefreshInterval=2000</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>禁用 readOnlyCacheMap，直接从 readWriteCacheMap 获取信息；</li>
<li>禁用 Self Preservation Mode；</li>
<li>Heartbeat 时间间隔为5秒；</li>
<li>Heartbeat 超时时间间隔为10秒；</li>
<li>Client 获取服务列表信息间隔为5秒；</li>
<li>ribbon 缓存刷新时间为2秒；</li>
</ol>
<p>经过优化配置后：</p>
<ul>
<li>正常上下线预估：5(Client Fetch) + 2(Ribbon) = 7秒；</li>
<li>异常下线预估(最坏情况))：10(LeaseExpiration)*2 + 5(Evict) + 5(Client Fetch) + 2(Ribbon) = 32秒</li>
</ul>
<hr>
<h3 id="Self-Preservation-Mode"><a href="#Self-Preservation-Mode" class="headerlink" title="Self Preservation Mode"></a>Self Preservation Mode</h3><p>Eureka servers will enter self preservation mode if they detect that a larger than expected number of registered clients have terminated their connections in an ungraceful way, and are pending eviction at the same time. </p>
<p><strong>This is done to ensure catastrophic network events do not wipe out eureka registry data, and having this be propagated downstream to all clients.</strong></p>
<p>When in self preservation mode, eureka servers will stop eviction of all instances until either:</p>
<ol>
<li>the number of heartbeat renewals it sees is back above the expected threshold;</li>
<li>self preservation is disabled;</li>
</ol>
<hr>
<p>默认情况下，如果 Eureka Server 在一定时间内没有接收到某个微服务实例的心跳，Eureka Server 将会注销该实例（默认90秒）。但是当网络分区故障发生时，微服务与 Eureka Server 之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。</p>
<p>Eureka Server 通过“自我保护模式”来解决这个问题——当 Eureka Server 节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。一旦进入该模式，Eureka Server 就会保护服务注册表中的信息，不再删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复后，该 Eureka Server 节点会自动退出自我保护模式。</p>
<p>认情况下，如果在15分钟内超过 85% 的客户端节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障(比如网络故障或频繁的启动关闭客户端)，Eureka Server 自动进入自我保护模式。不再剔除任何服务，当网络故障恢复后，该节点自动退出自我保护模式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line">    <span class="comment">#自我保护模式，当出现网络分区故障、频繁的开启关闭客户端、eureka在短时间内丢失过多客户端时，会进入自我保护模式，即一个服务长时间没有发送心跳，eureka也不会将其删除，默认为true</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment">#阈值因子，默认是0.85，如果阈值比最小值大，则自我保护模式开启</span></span><br><span class="line"><span class="attr">    renewal-percent-threshold:</span> <span class="number">0.85</span></span><br></pre></td></tr></table></figure>
<p>自我保护模式是一种对网络异常的安全保护措施。使用自我保护模式让Eureka集群更加的健壮、稳定。</p>
<hr>
<h3 id="API-Gateway-实现服务下线实时感知"><a href="#API-Gateway-实现服务下线实时感知" class="headerlink" title="API-Gateway 实现服务下线实时感知"></a>API-Gateway 实现服务下线实时感知</h3><p>以Spring Cloud Zuul网关为例，网关作为Eureka Client保存了服务注册信息，服务消费者通过网关将请求转发给服务提供者，只需要做到服务提供者下线时通知网关在自己保存的服务列表中使该服务失效。为了保持网关的独立性，可实现一个独立服务接收下线通知并协调网关集群。</p>
<blockquote>
<p>在 Kubernetes 集群中，可监听 Pod 事件来协调服务的上下线。</p>
</blockquote>
<p>目前服务发现主要有两种模式：</p>
<ul>
<li>客户端发现：客户端负责决定可用服务实例的网络地址，并且在集群中对请求负载均衡, 客户端访问服务登记表，也就是一个可用服务的数据库，然后客户端使用一种负载均衡算法选择一个可用的服务实例然后发起请求。</li>
<li>服务端发现：客户端通过负载均衡器向服务注册中心发起请求，负载均衡器查询服务注册中心，将每个请求路由到可用的服务实例上。</li>
</ul>
<h4 id="Zuul-与-Eureka-的配合"><a href="#Zuul-与-Eureka-的配合" class="headerlink" title="Zuul 与 Eureka 的配合"></a>Zuul 与 Eureka 的配合</h4><p>Eureka Server 为注册中心，Zuul 相对于 Eureka Server 来说是 Eureka Client，Zuul 会把 Eureka Server 端服务列表缓存到本地，并以定时任务的形式更新服务列表，同时 Zuul 通过本地列表发现其它服务，使用 Ribbon 实现客户端负载均衡。</p>
<img src="/2019/10/17/SpringBoot/Eureka/Theory/eureka-and-zuul-connection.png">
<p>正常情况下，调用方对网关发起请求即刻能得到响应。但是当对生产者做缩容、下线、升级的情况下，由于Eureka这种多级缓存的设计结构和定时更新的机制，LoadBalance 端的服务列表B存在更新不及时的情况，服务消费者最长感知时间将无限趋近240s），如果这时消费者对网关发起请求，LoadBalance 会对一个已经不存在的服务发起请求，请求是会超时的。</p>
<h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p><strong>解决方案思路</strong></p>
<p>生产者下线后，最先得到感知的是 Eureka Server 中的 readWriteCacheMap，最后得到感知的是网关核心中的 LoadBalance。但是 loadBalance 对生产者的发现是在 loadBalance 本地维护的列表中。</p>
<p>所以要想达到网关对生产者下线的实时感知，可以这样做：首先生产者或者部署平台主动通知 Eureka Server，然后跳过 Eureka 多级缓存之间的更新时间，直接通知 Zuul 中的 Eureka Client，最后将 Eureka Client 中的服务列表更新到 Ribbon 中。</p>
<blockquote>
<p>如果下线通知的逻辑代码放在生产者中，会造成代码污染、语言差异等问题。</p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[Eureka自我保护模式——难点重点] <a href="https://www.cnblogs.com/linjiqin/p/10090000.html" target="_blank" rel="noopener">https://www.cnblogs.com/linjiqin/p/10090000.html</a></li>
<li>[Spring Cloud Eureka 自我保护机制] <a href="https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html" target="_blank" rel="noopener">https://www.cnblogs.com/xishuai/p/spring-cloud-eureka-safe.html</a></li>
<li>[SpringCloud之Eureka] <a href="https://juejin.im/post/5ca4ca43e51d4577dd2e82e3" target="_blank" rel="noopener">https://juejin.im/post/5ca4ca43e51d4577dd2e82e3</a></li>
<li>[Self Preservation Mode] <a href="https://github.com/Netflix/eureka/wiki/Server-Self-Preservation-Mode" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Server-Self-Preservation-Mode</a></li>
<li>[spring cloud eureka 参数配置] <a href="https://segmentfault.com/a/1190000008378268" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008378268</a></li>
<li>[详解 Eureka 缓存机制] <a href="http://college.creditease.cn/detail/243" target="_blank" rel="noopener">http://college.creditease.cn/detail/243</a></li>
<li>[API网关如何实现对服务下线实时感知] <a href="https://juejin.im/post/5cf62c13f265da1bc37efb4c" target="_blank" rel="noopener">https://juejin.im/post/5cf62c13f265da1bc37efb4c</a></li>
<li>[Understanding Eureka Peer to Peer Communication] <a href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication" target="_blank" rel="noopener">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/17/SpringBoot/Eureka/Quickly-Register-And-Unregister/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/SpringBoot/Eureka/Quickly-Register-And-Unregister/" itemprop="url">Eureka 服务实例上下线</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-17T11:18:06+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/Eureka/" itemprop="url" rel="index">
                    <span itemprop="name">Eureka</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>默认的Spring Eureka服务器，服务提供者和服务调用者配置不够灵敏，总是服务提供者在停掉很久之后，服务调用者很长时间并没有感知到变化。或者是服务已经注册上去了，但是服务调用方很长时间还是调用不到(发现不了这个服务)。</p>
<p>在实际情况中，Eureka 的默认设置是不符合我们生产要求的，一般情况下，我们的生产要求：</p>
<ol>
<li>ServiceA 下线一台实例后，API-Gateway 的调用不能失败；</li>
<li>ServiceB 下线一台实例后，ServiceA 的 Feign 调用不能失败；</li>
<li>服务上线下线，Eureka服务能够快速感知；</li>
</ol>
<hr>
<h3 id="涉及原理知识"><a href="#涉及原理知识" class="headerlink" title="涉及原理知识"></a>涉及原理知识</h3><h4 id="Eureka的两层缓存问题"><a href="#Eureka的两层缓存问题" class="headerlink" title="Eureka的两层缓存问题"></a>Eureka的两层缓存问题</h4><p>EurekaServer 默认有两个缓存，一个是 ReadWriteMap，另一个是 ReadOnlyMap。有服务提供者注册服务或者维持心跳时时，会修改 ReadWriteMap。当有服务调用者查询服务实例列表时，默认会从 ReadOnlyMap 读取（这个在原生Eureka可以配置，SpringCloud Eureka中不能配置，一定会启用ReadOnlyMap读取），这样可以减少 ReadWriteMap 读写锁的争用，增大吞吐量。EurekaServer 定时把数据从 ReadWriteMap 更新到 ReadOnlyMap 中。</p>
<h4 id="心跳时间"><a href="#心跳时间" class="headerlink" title="心跳时间"></a>心跳时间</h4><p>客户端注册服务后，会定时心跳。这个根据客户端的 Eureka 配置中的服务刷新时间决定。还有个配置是客户端的服务过期时间，但是 EurekaServer 默认情况下是忽略客户端的这个字段。需要配置好 EurekaServer 的扫描失效时间，才会触发 EurekaServer 的主动失效机制。</p>
<p>在这个机制启用下：每个客户端会发送自己的服务过期时间上去，EurekaServer 会定时检查每个客户端的服务过期时间和上次心跳时间，如果在服务过期时间内没有收到过任何一次心跳，同时没有处于保护模式下，则会将这个实例从ReadWriteMap中去掉。</p>
<h4 id="调用者服务从Eureka拉列表的轮训间隔"><a href="#调用者服务从Eureka拉列表的轮训间隔" class="headerlink" title="调用者服务从Eureka拉列表的轮训间隔"></a>调用者服务从Eureka拉列表的轮训间隔</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.client.registry-fetch-interval-seconds</span></span><br></pre></td></tr></table></figure>
<p>表示 Eureka Server 间隔多久去拉取服务注册信息，默认为30秒，对于api-gateway，如果要迅速获取服务注册状态，可以缩小该值，比如5秒。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.instance.lease-expiration-duration-in-seconds</span></span><br></pre></td></tr></table></figure>
<p>表示 Eureka Server 至上一次收到 Client 的心跳之后，等待下一次心跳的超时时间，在这个时间内若没收到下一次心跳，则将移除该 Instance。</p>
<p>默认为90秒，如果该值太大，则很可能将流量转发过去的时候，该instance已经不存活了；如果该值设置太小了，则instance则很可能因为临时的网络抖动而被摘除掉。因此，该值至少应该大于lease-renewal-interval-in-seconds。</p>
<blockquote>
<p>eureka.instance.lease-renewal-interval-in-seconds：表示eureka client发送心跳给server端的频率。<br>lease-expiration-duration-in-seconds后，server端没有收到client的心跳，则将摘除该instance。除此之外，如果该instance实现了HealthCheckCallback，并决定让自己unavailable的话，则该instance也不会接收到流量。</p>
</blockquote>
<h4 id="Zuul-Ribbon缓存"><a href="#Zuul-Ribbon缓存" class="headerlink" title="Zuul - Ribbon缓存"></a>Zuul - Ribbon缓存</h4><p>在 Zuul 内部进行 Routing 和 Load Balance 时候，为了保证 HA，不受 Eureka 掉线的影响，内存中会有一个 Server List 缓存。</p>
<hr>
<h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><ol>
<li>服务过期时间，默认90s</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.instance.lease-expiration-duration-in-seconds=9</span></span><br></pre></td></tr></table></figure>
<p>超过这个时间没有接收到心跳 EurekaServer 就会将这个实例剔除。EurekaServer 一定要设置 eureka.server.eviction-interval-timer-in-ms 否则这个配置无效，这个配置一般为服务刷新时间配置的三倍。</p>
<ol start="2">
<li>服务刷新时间配置，每隔这个时间会主动心跳一次，默认30s</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.instance.lease-renewal-interval-in-seconds=3</span></span><br></pre></td></tr></table></figure>
<ol>
<li>拉服务列表时间间隔，默认30s</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.client.registryFetchIntervalSeconds=5</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>ribbon刷新时间，默认30s</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">ribbon.ServerListRefreshInterval=5000</span></span><br></pre></td></tr></table></figure>
<h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><ol>
<li>禁用Eureka的ReadOnlyMap缓存</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.server.use-read-only-response-cache:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>启用主动失效，并且每次主动失效检测间隔为3s</li>
</ol>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">eureka.server.eviction-interval-timer-in-ms:</span> <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># eureka.server.responseCacheUpdateInvervalMs</span></span><br><span class="line"><span class="comment"># eureka.server.responseCacheAutoExpirationInSeconds</span></span><br><span class="line"><span class="comment"># 在启用了主动失效后其实没什么用了。默认值180s</span></span><br></pre></td></tr></table></figure>
<h4 id="Zuul-Retry"><a href="#Zuul-Retry" class="headerlink" title="Zuul - Retry"></a>Zuul - Retry</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.retry&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-retry&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(是否所有操作都重试，若false则仅get请求重试)</span></span><br><span class="line"><span class="string">ribbon.OkToRetryOnAllOperations:true</span> </span><br><span class="line"><span class="comment">#(重试负载均衡其他实例最大重试次数,不含首次实例)</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetriesNextServer:3</span> </span><br><span class="line"><span class="comment">#(同一实例最大重试次数,不含首次调用)</span></span><br><span class="line"><span class="string">ribbon.MaxAutoRetries:1</span></span><br><span class="line"><span class="string">ribbon.ReadTimeout:30000</span></span><br><span class="line"><span class="string">ribbon.ConnectTimeout:3000</span></span><br><span class="line"><span class="comment">#（那些状态进行重试）</span></span><br><span class="line"><span class="string">ribbon.retryableStatusCodes:404,500,503</span></span><br><span class="line"><span class="comment"># (重试开关)</span></span><br><span class="line"><span class="string">spring.cloud.loadbalancer.retry.enable:true</span></span><br></pre></td></tr></table></figure>
<h4 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h4><blockquote>
<p><a href="https://juejin.im/post/5ba0ea35f265da0afe62d7a4" target="_blank" rel="noopener">https://juejin.im/post/5ba0ea35f265da0afe62d7a4</a></p>
</blockquote>
<h4 id="Client-主动通知-Eureka-下线"><a href="#Client-主动通知-Eureka-下线" class="headerlink" title="Client 主动通知 Eureka 下线"></a>Client 主动通知 Eureka 下线</h4><p>如果是 Spring Boot 应用，可以调用以下代码通知 Eureka，本服务实例暂停提供服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryManager.getInstance().shutdownComponent();</span><br></pre></td></tr></table></figure>
<p>另外还可以通过 HTTP API 接口删除实例注册信息来实现服务下线。</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[SpringCloud服务的平滑上下线] <a href="https://juejin.im/post/5cf63899f265da1b9253c7f4" target="_blank" rel="noopener">https://juejin.im/post/5cf63899f265da1b9253c7f4</a></li>
<li>[spring eureka 服务实例实现快速下线快速感知快速刷新配置解析] <a href="https://blog.csdn.net/zhxdick/article/details/78560993" target="_blank" rel="noopener">https://blog.csdn.net/zhxdick/article/details/78560993</a></li>
<li>[eureka缓存细节以及生产环境的最佳配置] bhsc881114.github.io/2018/04/01/eureka缓存细节以及生产环境的最佳配置/</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/15/DB/MySQL/MySQL - 联合索引最左匹配原则/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/DB/MySQL/MySQL - 联合索引最左匹配原则/" itemprop="url">MySQL 联合索引最左匹配原则</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T19:00:13+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/" itemprop="url" rel="index">
                    <span itemprop="name">DB</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/DB/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h3><p>在 MySQL 建立联合索引时会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。</p>
<hr>
<p>Example 1：KEY test_col1_col2_col3 on test(col1,col2,col3);</p>
<p>表结构包含5个字段：col1, col2, col3, col4, col5</p>
<p>联合索引 test_col1_col2_col3 实际建立了(col1)、(col1,col2)、(col1,col2,col3)三个索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=“<span class="number">1</span>” <span class="keyword">AND</span> clo2=“<span class="number">2</span>” <span class="keyword">AND</span> clo4=“<span class="number">4</span>”</span><br></pre></td></tr></table></figure>
<p>上面这个查询语句执行时会依照最左前缀匹配原则，检索时会使用索引(col1,col2)进行数据匹配。</p>
<hr>
<p>Example 2：索引的字段可以是任意顺序的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col1=“<span class="number">1</span>” <span class="keyword">AND</span> clo2=“<span class="number">2</span>”</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col2=“<span class="number">2</span>” <span class="keyword">AND</span> clo1=“<span class="number">1</span>”</span><br></pre></td></tr></table></figure></p>
<p>这两个查询语句都会用到索引(col1,col2)，MySQL 创建联合索引的规则是首先会对联合合索引的最左边的，也就是第一个字段col1的数据进行排序，在第一个字段的排序基础上，然后再对后面第二个字段col2进行排序。其实就相当于实现了类似 order by col1 col2这样一种排序规则。</p>
<p>有人会疑惑第二个查询语句不符合最左前缀匹配：首先可以肯定是两个查询语句都包含索引(col1,col2)中的col1、col2两个字段，只是顺序不一样，查询条件一样，最后所查询的结果肯定是一样的。既然结果是一样的，到底以何种顺序的查询方式最好呢？此时我们可以借助 MySQL 查询优化器explain，explain会纠正sql语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p>
<hr>
<p>Example 3：跳过第一个索引字段</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="keyword">test</span> <span class="keyword">WHERE</span> col2=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>对于联合索引(col1,col2,col3)，上面这条语句是能不够触发索引的。</p>
<p>如果表中的字段除了（col1,col2,col3），还有别的字段。那么的 EXPLAIN 中结果将不会是 INDEX 而是 ALL。其实是没有用到索引的。</p>
<p>如果表中的字段只有（col1,col2,col3）。那么的 EXPLAIN 中结果才会是 INDEX 。</p>
<hr>
<h3 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引"></a>为什么要使用联合索引</h3><ol>
<li><p>减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销。</p>
</li>
<li><p>覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。</p>
</li>
<li><p>效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！</p>
</li>
</ol>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[Mysql联合索引最左匹配原则] <a href="https://segmentfault.com/a/1190000015416513" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015416513</a></li>
<li><a href="https://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">https://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/15/Kubenetes/Ingress/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/Kubenetes/Ingress/" itemprop="url">Kubernetes Ingress</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T17:10:27+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Kubernetes/" itemprop="url" rel="index">
                    <span itemprop="name">Kubernetes</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[Ingress Controllers] <a href="https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/" target="_blank" rel="noopener">https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/15/CS/Thread/Thread-Lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/15/CS/Thread/Thread-Lifecycle/" itemprop="url">Thread Lifecycle</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-15T11:39:18+08:00">
                2019-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/" itemprop="url" rel="index">
                    <span itemprop="name">CS</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CS/Thread/" itemprop="url" rel="index">
                    <span itemprop="name">Thread</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java-Thread-Status"><a href="#Java-Thread-Status" class="headerlink" title="Java Thread Status"></a>Java Thread Status</h3><img src="/2019/10/15/CS/Thread/Thread-Lifecycle/java-early-stage-process-status.jpg">
<p>上图是早期进程的状态，这里所谓“进程状态”指早期的那种“单线程进程”的状态。</p>
<p>对于现在普遍的“多线程进程”，显然，谈论“进程状态”已经没有意义，应该谈论“进程下某个线程的状态”或者直接说“线程状态”。</p>
<p>这里有个误区：其实在 Java 里面，线程是包含6个状态，而不是5个状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">*   sun.misc.VM</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*   The threadStatus field is set by the VM at state transition</span></span><br><span class="line"><span class="comment">*   in the hotspot implementation. Its value is set according to the JVM TI specification GetThreadState function.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_ALIVE = <span class="number">0x0001</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_TERMINATED = <span class="number">0x0002</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_RUNNABLE = <span class="number">0x0004</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_BLOCKED_ON_MONITOR_ENTER = <span class="number">0x0400</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_WAITING_INDEFINITELY = <span class="number">0x0010</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> JVMTI_THREAD_STATE_WAITING_WITH_TIMEOUT = <span class="number">0x0020</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   Thread.State</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These states are virtual machine states which do not reflect any operating system thread states。</p>
<blockquote>
<p>这些状态是虚拟机状态，它不反映任何操作系统的线程状态。</p>
</blockquote>
<img src="/2019/10/15/CS/Thread/Thread-Lifecycle/java-thread-status.jpg">
<p><strong>Runnable 与 传统Running 状态的区别</strong></p>
<p>有人常觉得 Java 线程状态中还少了个 Running 状态，这其实是把两个不同层面的状态混淆了。对 Java 线程状态而言，不存在所谓的 Running 状态，它的 Runnable 状态包含了 Running 状态。</p>
<p>为何 JVM 中没有去区分这两种状态呢？现在的时分(time-sharing)多任务(multi-task)操作系统架构通常都是用所谓的“时间分片(time quantum or time slice)”方式进行抢占式（preemptive）轮转调度（round-robin式）。这个时间分片通常是很小的，一个线程一次最多只能在 CPU 上运行比如 10-20ms 的时间（此时处于 Running 状态），也即大概只有 0.01 秒这一量级，时间片用后就要被切换下来放入调度队列的末尾等待再次调度(也即回到 Ready 状态)。</p>
<p>Java中的 RUNNABLE 状态实际上是包含了 Ready 与 Running 的状态的。</p>
<hr>
<p>从实际来说，线程只有”就绪”、”阻塞”、”运行”三种状态：</p>
<ol>
<li>运行状态，线程正在干活的状态；</li>
<li>就绪状态，CPU正在忙活别的；</li>
<li>阻塞状态，线程主动让出CPU资源；</li>
</ol>
<p>NEW 和 TERMINATED 这两种状态其实并不是线程的状态，而是java.lang.Thread对象的状态。可以说，处于 NEW 和 TERMINATED 状态的”线程”其实并不是线程，而只是一个代表着线程对象而已。</p>
<p>所以我们把 NEW 和 TERMINATED 两种状态去掉，那么Java定义的线程状态还有4种：</p>
<ol>
<li>RUNNABLE</li>
<li>BLOCKED</li>
<li>WAITING</li>
<li>TIMED_WAITING</li>
</ol>
<p>这四种状态怎么对应到”就绪”、”阻塞”、”运行”这三种状态里呢：</p>
<ol>
<li>RUNNABLE，对应”就绪”和”运行”两种状态，也就是说处于就绪和运行状态的线程在java.lang.Thread中都表现为”RUNNABLE”；</li>
<li>BLOCKED，对应”阻塞”状态，此线程需要获得某个锁才能继续执行，而这个锁目前被其他线程持有，所以进入了被动的等待状态，直到抢到了那个锁，才会再次进入”就绪”状态；</li>
<li>WAITING，对应”阻塞”状态，代表此线程正处于无限期的主动等待中，直到有人唤醒它，它才会再次进入就绪状态；</li>
<li>TIMED_WAITING，对应”阻塞”状态，代表此线程正处于有限期的主动等待中，要么有人唤醒它，要么等待够了一定时间之后，才会再次进入就绪状态；</li>
</ol>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[java线程运行怎么有第六种状态？] <a href="https://www.zhihu.com/question/56494969" target="_blank" rel="noopener">https://www.zhihu.com/question/56494969</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/14/Java/JVM/Basic/深入学习 JVM -  G1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/Java/JVM/Basic/深入学习 JVM -  G1/" itemprop="url">深入学习 JVM - G1</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T23:29:06+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/14/Java/JVM/Basic/深入学习 JVM -  CMS/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/Java/JVM/Basic/深入学习 JVM -  CMS/" itemprop="url">深入学习 JVM - CMS</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T22:19:06+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="GC-Phases"><a href="#GC-Phases" class="headerlink" title="GC Phases"></a>GC Phases</h3><h4 id="1-Initial-Mark-初始标记阶段-STW"><a href="#1-Initial-Mark-初始标记阶段-STW" class="headerlink" title="1. Initial Mark - 初始标记阶段 - STW"></a>1. Initial Mark - 初始标记阶段 - STW</h4><p>作用：标记存活的对象。</p>
<p>主要标记两部分：</p>
<ul>
<li>老年代中所有的 GC Roots 对象；</li>
<li>年轻代中活着的对象引用到的老年代的对象；</li>
</ul>
<h4 id="2-Concurrent-Mark-并发标记阶段"><a href="#2-Concurrent-Mark-并发标记阶段" class="headerlink" title="2. Concurrent Mark - 并发标记阶段"></a>2. Concurrent Mark - 并发标记阶段</h4><p>从“初始化标记”阶段找到的GC Roots开始，找出所有存活的对象。</p>
<p>并发标记的特点是标记线程和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p>
<h4 id="3-Concurrent-Preclean-预清理阶段"><a href="#3-Concurrent-Preclean-预清理阶段" class="headerlink" title="3. Concurrent Preclean - 预清理阶段"></a>3. Concurrent Preclean - 预清理阶段</h4><p>前一个阶段在并行运行的时候，一些对象的引用已经发生了变化，当这些引用发生变化的时候，JVM会标记堆的这个区域为Dirty Card(包含被标记但是改变了的对象，被认为”dirty”)，这就是Card Marking。</p>
<h4 id="4-Concurrent-Abortable-Preclean"><a href="#4-Concurrent-Abortable-Preclean" class="headerlink" title="4. Concurrent Abortable Preclean"></a>4. Concurrent Abortable Preclean</h4><h4 id="5-Final-Remark"><a href="#5-Final-Remark" class="headerlink" title="5. Final Remark"></a>5. Final Remark</h4><h4 id="6-Concurrent-Sweep"><a href="#6-Concurrent-Sweep" class="headerlink" title="6. Concurrent Sweep"></a>6. Concurrent Sweep</h4><h4 id="7-Concurrent-Reset"><a href="#7-Concurrent-Reset" class="headerlink" title="7. Concurrent Reset"></a>7. Concurrent Reset</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/14/Java/JVM/Basic/深入学习 JVM -  Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/Java/JVM/Basic/深入学习 JVM -  Class/" itemprop="url">深入学习 JVM - Class</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T16:51:06+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/14/Java/JVM/Basic/深入学习 JVM -  GC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/Java/JVM/Basic/深入学习 JVM -  GC/" itemprop="url">深入学习 JVM - GC</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T11:32:06+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="GC-Arithmetic"><a href="#GC-Arithmetic" class="headerlink" title="GC Arithmetic"></a>GC Arithmetic</h3><h4 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h4><p>GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针，这些指针是tracing GC的trace的起点。</p>
<blockquote>
<p>只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots。</p>
</blockquote>
<p>哪些对象可以作为 GC Root：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<p><strong>选择这些对象作为 GC Root 的依据是什么？</strong></p>
<p>可作为GC Roots的节点主要在全局性的引用与执行上下文中。</p>
<p>要明确的是，<strong>tracing gc必须以当前存活的对象集为Roots</strong>，因此必须选取确定存活的引用类型对象。GC管理的区域是Java堆，而虚拟机栈、方法区和本地方法栈不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是不会被GC所回收的。</p>
<p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p>
<h4 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h4><h4 id="常见回收算法"><a href="#常见回收算法" class="headerlink" title="常见回收算法"></a>常见回收算法</h4><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><ol>
<li>优先分配对象到 Eden 区；</li>
<li>大对象直接分配到老年代；</li>
<li>长期存活对象分配到老年代，-XX:MaxTenuringThreshold=15；</li>
<li>空间分配担保，-XX:+HandlePromotionFailure，默认开启；</li>
<li>动态对象年龄判定；</li>
</ol>
<hr>
<p><strong>优先分配对象到 Eden 区</strong></p>
<p>内存分配情况：将JVM内存划分为一块较大的Eden空间（80%）和两块小的Servivor（各占10%）。当回收时，将 Eden 和 Survivor 中还存活的对象一次性采用复制算法直接复制到另外一块 Survivor 空间上，最后清理 Eden 空间和原先的 Survivor 空间中的数据。</p>
<p>大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，JVM将发起一次 Minor GC。</p>
<blockquote>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多是具有朝生夕灭的特性，所以Minor GC非常频繁，而且该速度也比较快。<br>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，一般可能也会伴随着一次Minor GC，但是与Minor GC不同的是，Major GC的速度慢十倍以上。</p>
</blockquote>
<p><strong>大对象直接分配到老年代</strong></p>
<p>大对象做一个定义：这里指的是需要大量连续内存空间的Java对象。最典型的大对象可以是很长的字符串和数组。</p>
<p>大对象对于JVM的内存分配来说是十分麻烦的，如果我们将大对象分配在新生代中，那样子的话很容易导致内存还有不少空间时，提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>为了避免上述情况的经常发生而导致不需要的GC活动所浪费的资源和时间，可采用的分配策略是将大对象直接分配到老年代中去，虚拟机中也提供了-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代里面分配内容。</p>
<blockquote>
<p>-XX:PretenureSizeThreshold，默认为0<br>-XX:PretenureSizeThreshold只对Serial和ParNew收集器有效。</p>
</blockquote>
<p><strong>长期存活对象分配到老年代</strong></p>
<p>当 JVM 采用分代收集的思想来管理内存时，为了识别哪些对象应该放在新生代、哪些对象应该放在老年代，JVM 给每个对象定义了一个对象年龄计数器。</p>
<p>对象年龄计数器：如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，便可以被移动到Survivor空间中，年龄计数器将设置该对象的年龄为1。对于对象在Survivor区每经过一次Minor GC，年龄便增加1岁，当它的年龄增加到一定程度（可通过参数-XX:MaxTenuringThreshold设置）默认15，该对象便会进入到老年代中。成为老年代的对象。</p>
<p><strong>动态对象年龄判定</strong></p>
<p>事实上，有的虚拟机并不永远地要求对象的年龄必须达到MaxTeruringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Surivior空间的一半，年龄大于或等于该年龄的对象就可以直接进行老年代，无须等到MaxTeruringThreshold中所要求的年龄。</p>
<p><strong>空间分配担保</strong></p>
<p>在发生Minor GC之前，<strong>虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间</strong>，如果这个条件成立，那么Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。与生活中的贷款担保类似，老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以只好取之前每一次回收晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。虽然担保失败时绕的圈子是最大的，但大部分情况下都还是会将HandlePromotionFailure打开，避免Full GC过于频繁。</p>
<blockquote>
<p><a href="https://cloud.tencent.com/developer/article/1082730" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1082730</a></p>
</blockquote>
<h4 id="逃逸分析-Escape-Analysis-与栈上分配"><a href="#逃逸分析-Escape-Analysis-与栈上分配" class="headerlink" title="逃逸分析(Escape Analysis)与栈上分配"></a>逃逸分析(Escape Analysis)与栈上分配</h4><p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法——分析在程序的哪些地方可以访问到指针。它涉及到指针分析和形状分析。</p>
<p><strong>逃逸分析(Escape Analysis)</strong>是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p>
<p><strong>简单说，就是把没有发生逃逸的对象分配到栈空间上。</strong></p>
<p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为<strong>方法逃逸</strong>。</p>
<p>使用逃逸分析，编译器可以对代码做如下优化：</p>
<ol>
<li><p>同步省略。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
</li>
<li><p>将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。</p>
</li>
<li><p>分离对象或标量替换。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在CPU寄存器中。</p>
</li>
</ol>
<blockquote>
<p>JVM参数 XX:+DoEscapeAnalysis 和 -XX:-DoEscapeAnalysis，默认情况下开启。<br>以上三种优化中，栈上内存分配其实是依靠标量替换来实现的。</p>
</blockquote>
<hr>
<h3 id="GC回收器"><a href="#GC回收器" class="headerlink" title="GC回收器"></a>GC回收器</h3><img src="/2019/10/14/Java/JVM/Basic/深入学习%20JVM%20-%20%20GC/collectors-category.png">
<h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><img src="/2019/10/14/Java/JVM/Basic/深入学习%20JVM%20-%20%20GC/cms-process.png">
<p>分代回收：</p>
<ul>
<li>年轻代：采用 stop-the-world mark-copy 算法；</li>
<li>年老代：采用 Mostly Concurrent mark-sweep 算法；</li>
</ul>
<p>使用 Mark-Sweep GC Arithmetic，该算法不足之处在于：</p>
<ol>
<li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作。</li>
<li>效率问题：因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</li>
</ol>
<hr>
<p>GC Process：</p>
<ol>
<li>初始标记(STW)</li>
<li>并发标记(两阶段：并发标记 和 并发预处理)</li>
<li>重新标记(STW)</li>
<li>并发清理(两阶段：并发清理 和 并发重置)</li>
</ol>
<p>Advantage：</p>
<ol>
<li>并发GC；</li>
<li>低停顿；</li>
</ol>
<p>Weakness：</p>
<ol>
<li>占用较多CPU资源；</li>
<li>无法处理Floating Garbage，并发标记与并发清除过程会产生浮动垃圾，如果CMS之前预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将退化使用Serial Old收集器，重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>
<li>出现Concurrent Mode Failure问题，造成使用Serial Old GC进行回收老年代；</li>
<li>基于“标记-清除算法”，收集结束时会有大量空间碎片产生，导致明明剩余空间充足，却无法为大对象分配足够的连续内存。</li>
</ol>
<blockquote>
<p>Floating Garbage：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。在这期间用户可能创建新的对象。为了处理这部分浮动垃圾和对象，CMS在并发清理之前，需要预留出足够空间给并发清理期间的用户线程使用。一般会显示使用-XX:CMSInitiatingOccupancyFraction参数设置触发CMS时的老年代空间比例，如果老年代增长不是太快，可以适当提高比例，以减少Full GC的次数。<br>关于浮动垃圾和内存碎片的问题，HDFS namenode在堆内存达到100G规模时，通常设置75%触发Full GC，不开启压缩，优先考虑STW造成的延迟。<br>打开-XX:+UseCMSCompactAtFullCollection开关参数（默认打开）在进行Full GC之前整理内存碎片（称为“压缩”）；使用-XX:CMSFullGCsBeforeCompaction参数（默认0）设置多少次不带压缩的Full CG之后才进行一次带压缩的Full GC。内存整理无法并行，还需要STW，需要适当调整内存整理的频率，在GC性能与空间利用率之间平衡。</p>
</blockquote>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>GC Process：</p>
<ol>
<li>初始标记(initial mark，STW)：它标记了从GC Root开始直接可达的对象。</li>
<li>并发标记(Concurrent Marking)：这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。</li>
<li>最终标记(Remark，STW)：标记那些在并发标记阶段发生变化的对象，将被回收。</li>
<li>清除垃圾(Cleanup)：清除空Region（没有存活对象的），加入到free list。</li>
</ol>
<p>Advantage：</p>
<ol>
<li>并行与并发：G1 能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。</li>
<li>分代收集：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。它能够采用不同的方式去处理新创建的对象和已经存活了一段时间，熬过多次 GC 的旧对象以获取更好的收集效果。</li>
<li>空间整合：与 CMS 的“标记-清理”算法不同，G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li>
<li>可预测的停顿：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li>
</ol>
<p><strong>什么是RSet？</strong></p>
<p>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构（谁引用了我的对象）。RSet的价值在于使得垃圾收集器不需要扫描整个堆找到谁引用了当前分区中的对象，只需要扫描RSet即可。</p>
<img src="/2019/10/14/Java/JVM/Basic/深入学习%20JVM%20-%20%20GC/rset-example.jpg">
<p>Region1和Region3中的对象都引用了Region2中的对象，因此在Region2的RSet中记录了这两个引用。</p>
<p><strong>什么是CSet？</strong></p>
<p>一组可被回收的分区(Region)的集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自Eden空间、survivor空间、或者老年代。CSet会占用不到整个堆空间的1%大小。</p>
<h4 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h4><blockquote>
<p>读屏障(Load Barrier)</p>
</blockquote>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[深入理解JVM(2)——GC算法与内存分配策略] <a href="https://crowhawk.github.io/2017/08/10/jvm_2/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/10/jvm_2/</a></li>
<li>[JVM之逃逸分析] <a href="https://zhuanlan.zhihu.com/p/59215831" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/59215831</a></li>
<li>[对象和数组并不是都在堆上分配内存的] <a href="http://www.hollischuang.com/archives/2398" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2398</a></li>
<li>[JVM快速调优手册之三: 内存分配策略] <a href="https://ruozedata.github.io/2019/06/19/JVM%E5%BF%AB%E9%80%9F%E8%B0%83%E4%BC%98%E6%89%8B%E5%86%8C%E4%B9%8B%E4%B8%89_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/" target="_blank" rel="noopener">https://ruozedata.github.io/2019/06/19/JVM%E5%BF%AB%E9%80%9F%E8%B0%83%E4%BC%98%E6%89%8B%E5%86%8C%E4%B9%8B%E4%B8%89_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</a></li>
<li>[Java程序员的荣光，听R大论JDK11的ZGC] <a href="https://juejin.im/entry/5b86a276f265da435c4402d4" target="_blank" rel="noopener">https://juejin.im/entry/5b86a276f265da435c4402d4</a></li>
<li>[A first look into ZGC] <a href="http://dinfuehr.github.io/blog/a-first-look-into-zgc/" target="_blank" rel="noopener">http://dinfuehr.github.io/blog/a-first-look-into-zgc/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/10/14/Linux/Basic/Performance-Index/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/Linux/Basic/Performance-Index/" itemprop="url">Linux 性能指标</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-14T10:18:06+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/" itemprop="url" rel="index">
                    <span itemprop="name">Linux</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Linux/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><ol>
<li>CPU相关：/proc/stat</li>
<li>磁盘相关：/proc/mounts</li>
<li>megacli：megacli 工具读取 RAID 相关信息</li>
<li>smartctl：smartctl 工具读取磁盘 SMART 信息</li>
<li>分区读写监控：测试所有已挂载分区是否可读写，每个metric都会有一组tag描述，表示挂载点，比如mount=/home</li>
<li>I/O相关：/proc/diskstats</li>
<li>机器负载：/proc/loadavg</li>
<li>内存相关：/proc/meminfo</li>
<li>网络相关：/proc/net/dev</li>
<li>端口：通过ss -ln，来判断指定的端口是否处于listen状态。原始值类型，值要么是1：代表在监听，要么是0，代表没有在监听。</li>
<li>机器内核：/proc/sys/fs/file-max，/proc/sys/fs/file-nr，/proc/sys/kernel/pid_max</li>
<li>ntp：使用 ntpq -pn 获取本机时间相对于 ntp 服务器的 offset</li>
<li>进程监控</li>
<li>进程资源监控</li>
<li>ss命令输出：获取 socket 统计信息，它显示的内容和 netstat 类似。但 ss 的优势在于它能够显示更多更详细的有关 TCP 和连接状态的信息，而且比 netstat 更快。当服务器的 socket 连接数量变得非常大时，无论是使用 netstat 命令还是直接 cat /proc/net/tcp，执行速度都会很慢。ss 命令利用到了 TCP 协议栈中 tcp_diag。tcp_diag 是一个用于分析统计的模块，可以获得 Linux 内核中第一手的信息，因此 ss 命令的性能会好很多。</li>
</ol>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li>[Linux运维基础采集项] <a href="https://book.open-falcon.org/zh/faq/linux-metrics.html" target="_blank" rel="noopener">https://book.open-falcon.org/zh/faq/linux-metrics.html</a></li>
<li>[linux ss 命令] <a href="https://www.cnblogs.com/sparkdev/p/8421897.html" target="_blank" rel="noopener">https://www.cnblogs.com/sparkdev/p/8421897.html</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/64/">64</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jason - sulang357159@163.com">
          
            <p class="site-author-name" itemprop="name">Jason - sulang357159@163.com</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">637</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">264</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">691</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason - sulang357159@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
