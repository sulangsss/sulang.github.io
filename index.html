<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">



  <meta name="google-site-verification" content="true">








  <meta name="baidu-site-verification" content="true">







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="A Big Boy Blog -  Tech Articls & Notes" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta property="og:type" content="website">
<meta property="og:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:url" content="https://sulangsss.github.io/index.html">
<meta property="og:site_name" content="A Big Boy Blog -  Tech Articls &amp; Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="A Big Boy Blog -  Tech Articls &amp; Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.2',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://sulangsss.github.io/">





<meta name="baidu-site-verification" content="xV2vphJ53Q">


  <title>A Big Boy Blog -  Tech Articls & Notes</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?344f3e8f33d176fceb44e65d30a341dc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">A Big Boy Blog -  Tech Articls & Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">Python Java Android Django Web -> sulang357159@gmail.com</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/08/Java/Advance/Java-Bean-Memory/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/Java/Advance/Java-Bean-Memory/" itemprop="url">Java Bean Memory</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T13:13:06+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Advance/" itemprop="url" rel="index">
                    <span itemprop="name">Advance</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Java-Object-Structure"><a href="#Java-Object-Structure" class="headerlink" title="Java Object Structure"></a>Java Object Structure</h4><p>一个Java对象在Heap的表示，可以分为三部分：</p>
<ul>
<li>Object Header</li>
<li>Class Pointer</li>
<li>Fields</li>
</ul>
<p>每个普通Java对象在堆(heap)中都有一个头信息(object header)，头信息是必不可少的，记录着对象的状态。</p>
<img src="/2019/05/08/Java/Advance/Java-Bean-Memory/object_header.png">
<ul>
<li>32位：hash(25) + age(4) + lock(3) = 32bit</li>
<li>64位：unused(25+1) + hash(31) + age(4) + lock(3) = 64bit</li>
</ul>
<p>在Java中，一切皆对象；每个类都有一个父类，Class Pointer就是当前对象父类的一个指针，在32位系统中，这个指针为4byte；在64位系统中，如果开启指针压缩(-XX:+UseCompressedOops)或者JVM堆的最大值小于32G，这个指针也是4byte，否则是8byte。</p>
<p>关于字段(Fields)，这里指的是类的实例字段；也就是说不包括静态字段，因为这个字段是共享内存的，只会存在一份。</p>
<h4 id="java-lang-Integer"><a href="#java-lang-Integer" class="headerlink" title="java.lang.Integer"></a>java.lang.Integer</h4><p>在32位系统上，计算java.lang.Integer对象内存占用。</p>
<p>Object Header和Pointer都是固定的，4 + 4 = 8 byte，数值int占用4 byte，所以总共占用 4 + 4 + 4 = 12byte。此外，Heap的内存分配是按照 8byte 对齐的，因此该对象实际内存占用是 16byte。</p>
<h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>在Java中还有一种特殊的对象，数组！这个对象有点特殊，它比其他对象多了一个属性：长度(length)。所以我们计算数组长度的时候，需要额外加上一个长度的字段，即一个int的大小。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>4(object header) + 4(pointer) + 4(length) + 4*10(10个int大小) = 52byte，由于需要8位对齐，所以最终大小为 56byte。</p>
<hr>
<h3 id="节约内存原则"><a href="#节约内存原则" class="headerlink" title="节约内存原则"></a>节约内存原则</h3><h4 id="尽量使用基本类型，而不是包装类型"><a href="#尽量使用基本类型，而不是包装类型" class="headerlink" title="尽量使用基本类型，而不是包装类型"></a>尽量使用基本类型，而不是包装类型</h4><p>一个java.lang.Integer占用 16byte，而一个int占用 4byte，4:1 的比例！也就是说整数类的类型是基本类型内存的4倍！</p>
<h4 id="斟酌字段类型，在满足容量前提下，尽量用小字段"><a href="#斟酌字段类型，在满足容量前提下，尽量用小字段" class="headerlink" title="斟酌字段类型，在满足容量前提下，尽量用小字段"></a>斟酌字段类型，在满足容量前提下，尽量用小字段</h4><p>数据库建表的时候字段类型需要仔细推敲，同样JavaBean中的属性字段类型也需要仔细斟酌。不要吝啬使用short，byte，boolean，如果短类型能放下数据，尽量不要使用更长的类型。一个long比一个int才多4byte，但是你要想，如果内存中有100W个long，那就白白浪费了约4MB空间，不要小看这一点点的空间浪费，因为随便一个应用的JVM中，对象都能达到上千万！内存是节省出来的。</p>
<h4 id="如果可能，尽量用数组，少用集合"><a href="#如果可能，尽量用数组，少用集合" class="headerlink" title="如果可能，尽量用数组，少用集合"></a>如果可能，尽量用数组，少用集合</h4><p>你知道一个ArrayList集合，如果里面放了10个数字，占用多少内存吗？让我们算算：</p>
<p>ArrayList中有两个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>
<p>Object Header占 4byte，Pointer占 4byte，一个int字段(size)占 4byte，elementData数组本身占 12(4+4+4)byte，数组中10个Integer对象占 10 × 16 = 160byte。所以整个集合空间大小为 4 + 4 + 4 + 12 + 160 = 184byte。</p>
<p>如果我们用int[]代替集合呢，12 + 4 × 10 = 52byte，对其后 56byte。集合跟数组的比例是 184:56，超过3:1。</p>
<p>数组中是可以使用基本类型的，但是集合中只能放包装类型！</p>
<p>如果实在需要使用集合，推荐一个比较节约内存的集合工具，fastutil。这里面包含了JKD集合中绝大部分的实现，而且比较省内存。</p>
<h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>以下方法根具体场景的数据有关系，可以根据实际情况进行激进优化节省内存。</p>
<ul>
<li>时间用long/int表示，不用 Date 或者 String。</li>
<li>短字符串如果能穷举或者转换成ascii表示，可以用long或者int表示。</li>
</ul>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="http://blog.lichengwu.cn/java/2014/01/05/building-memory-efficient-javabean/" target="_blank" rel="noopener">http://blog.lichengwu.cn/java/2014/01/05/building-memory-efficient-javabean/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/08/Java/Math/Math/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/Java/Math/Math/" itemprop="url">Java Math</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T12:14:22+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Float-Double"><a href="#Float-Double" class="headerlink" title="Float / Double"></a>Float / Double</h3><h4 id="Math-ceil"><a href="#Math-ceil" class="headerlink" title="Math.ceil()"></a>Math.ceil()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="number">100.0675</span></span><br><span class="line">val d = <span class="number">100.675</span></span><br><span class="line">val e = <span class="number">100.500</span></span><br><span class="line">val f = <span class="number">100.0</span></span><br><span class="line">val g = <span class="number">90.0</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"Math.ceil($a) -&gt; $&#123;Math.ceil(a)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.ceil($d) -&gt; $&#123;Math.ceil(d)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.ceil($e) -&gt; $&#123;Math.ceil(e)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.ceil($f) -&gt; $&#123;Math.ceil(f)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.ceil($g) -&gt; $&#123;Math.ceil(g)&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.ceil(<span class="number">100.0675</span>) -&gt; <span class="number">101.0</span></span><br><span class="line">Math.ceil(<span class="number">100.675</span>) -&gt; <span class="number">101.0</span></span><br><span class="line">Math.ceil(<span class="number">100.5</span>) -&gt; <span class="number">101.0</span></span><br><span class="line">Math.ceil(<span class="number">100.0</span>) -&gt; <span class="number">100.0</span></span><br><span class="line">Math.ceil(<span class="number">90.0</span>) -&gt; <span class="number">90.0</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p>实现Flaot/Double同四舍五入效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="number">100.0675</span></span><br><span class="line">val d = <span class="number">100.675</span></span><br><span class="line">val e = <span class="number">100.500</span></span><br><span class="line">val f = <span class="number">100f</span></span><br><span class="line">val g = <span class="number">90f</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"Math.round($a) -&gt; $&#123;Math.round(a)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.round($d) -&gt; $&#123;Math.round(d)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.round($e) -&gt; $&#123;Math.round(e)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.round($f) -&gt; $&#123;Math.round(f)&#125;"</span>)</span><br><span class="line">println(<span class="string">"Math.round($g) -&gt; $&#123;Math.round(g)&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.round(<span class="number">100.0675</span>) -&gt; <span class="number">100</span></span><br><span class="line">Math.round(<span class="number">100.675</span>) -&gt; <span class="number">101</span></span><br><span class="line">Math.round(<span class="number">100.5</span>) -&gt; <span class="number">101</span></span><br><span class="line">Math.round(<span class="number">100.0</span>) -&gt; <span class="number">100</span></span><br><span class="line">Math.round(<span class="number">90.0</span>) -&gt; <span class="number">90</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><h4 id="Avoid-Overflow"><a href="#Avoid-Overflow" class="headerlink" title="Avoid Overflow"></a>Avoid Overflow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    val result = Math.multiplyExact(Long.MAX_VALUE, Long.MAX_VALUE)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Assert.fail()</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/06/BlockChain/共识机制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/BlockChain/共识机制/" itemprop="url">共识机制</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T01:30:18+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/BlockChain/" itemprop="url" rel="index">
                    <span itemprop="name">BlockChain</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h3 id="POW"><a href="#POW" class="headerlink" title="POW"></a>POW</h3><p>工作量证明（Proof of Work，简称PoW）为最早的证明方法，也是第一个虚拟币比特币运用的机制。</p>
<p>哈希函数是密码学上计算难度经过反复验证的东西，所以用它来做证明是最有效的，每发出一条信息上传区块链的时候，你要证明你付出了一定的算力，你的证据就是你区块里面的字符串，而加上这个字符串以后，你的区块的哈希值正好小于某个数。</p>
<p>哈希函数的特征告诉我们，你没有任何取巧的方法可以做到这一点，你只能一个个字符串的去尝试。形象来说就是系统为了找出谁有更强大的计算能力，每次会出一道数学题，只有最快解出这道题目的计算机才能进行记账。目前比特币和以太坊均采用此机制。</p>
<p>优点是完全去中心化，节点自有进出，比特币经过了进十年的发展中间经过了黑客攻击、政策限制等不利因素，仍然自我正常运行证明了该工作机制的伟大之处。</p>
<p>缺点POW依赖计算机通过数学运算获取记账权，造成了电力和计算机硬件资源消耗巨大，每次达成共识需要全网所有节点共同参与运算，运行效率低。</p>
<hr>
<h3 id="POS"><a href="#POS" class="headerlink" title="POS"></a>POS</h3><p>权益证明（Proof of Stake，简称PoS）它是PoW的一种升级，主要理念是<strong>节点记账权的获得难度与节点持有的权益成反比</strong>，根据每个节点所占代币的比例和时间，等比例地降低挖矿难度，从而加快找到随机数的速度。</p>
<p>用户可以购买等价的代币，并把这些代币当作押金放入PoS机制中，这样用户就有机会产生新区块而得到奖励。<strong>其在一定程度上减少了数学运算带来的资源消耗，性能也得到了相应的提升，但依然是基于哈希运算</strong>。</p>
<p>这个系统中存在一个持币人的集合，他们把手中的代币放入PoS机制中，这样他们就变成验证者。比如对区块链最前面的一个区块而言，PoS算法在验证者中随机选择一个（选择验证者的权重依据他们投入的代币量，比如一个投入押金为1W代币的验证者被选择的概率是一个投入1K代币验证者的10倍），给他权利产生下一个区块。如果在一定时间内，这个验证者没有产生一个区块，则选出第二个验证者代替产生新区块。与PoW一样，PoS以最长的链为准。</p>
<p>优点：在一定程度上缩短了共识达成的时间；不再需要大量消耗能源去挖矿。</p>
<p>缺点：还是需要挖矿，本质上没有解决商业应用的痛点；所有的确认都只是一个概率上的表达，而不是一个确定性的事情，理论上有可能存在其他攻击影响，例如以太坊的DAO攻击事件造成以太坊硬分叉，而ETC随之出现，事实上证明了此次硬分叉的失败。</p>
<hr>
<h3 id="DPOS"><a href="#DPOS" class="headerlink" title="DPOS"></a>DPOS</h3><p>股份授权证明（DPOS）从英文释义上就能看出是源于POS，它与PoS的主要区别在于节点选举若干代理人，由代理人验证和记账，但其合规监管、性能、资源消耗和容错性与PoS相似。类似于董事会投票，持币者投出一定数量的节点，进行代理验证和记账。</p>
<p>DPoS的工作原理如下：每个股东按其持股比例拥有相应的影响力，51%股东投票的结果将是不可逆且有约束力的，其挑战是通过及时而高效的方法达到“51%批准”。DPoS的投票模式可以每30秒产生一个新区块，并且在正常的网络条件下，区块链分叉的可能性极其小，即使发生也可以在几分钟内得到解决。</p>
<p>DPoS的优点：大幅缩小参与验证和记账节点的数量，可以达到秒级的共识验证。</p>
<p>DPoS的缺点：整个共识机制还是依赖于代币，而很多商业应用是不需要代币的。</p>
<hr>
<h3 id="Ripple-Consensus"><a href="#Ripple-Consensus" class="headerlink" title="Ripple Consensus"></a>Ripple Consensus</h3><p>瑞波共识机制（Ripple Consensus）算法使一组节点能够基于特殊节点列表形成共识。初始特殊节点列表就像一个俱乐部，要接纳一个新成员，必须由该俱乐部51%的会员投票通过。</p>
<p>共识遵循这些核心成员的“51%权利”，外部人员则没有影响力。由于该俱乐部由中心化开始，它将一直是中心化的，而如果它开始腐化，股东们什么也做不了。与比特币及Peercoin一样，瑞波系统将股东们与其投票权隔开，因此，它比其他系统更中心化。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://www.binance.vision/zh/blockchain/hybrid-pow-pos-consensus-explained" target="_blank" rel="noopener">https://www.binance.vision/zh/blockchain/hybrid-pow-pos-consensus-explained</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/05/Git/Error/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/Git/Error/" itemprop="url">Git Error</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T15:19:12+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Git/" itemprop="url" rel="index">
                    <span itemprop="name">Git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="error-some-local-refs-could-not-be-updated"><a href="#error-some-local-refs-could-not-be-updated" class="headerlink" title="error: some local refs could not be updated"></a>error: some local refs could not be updated</h4><p>git remote prune origin</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/" itemprop="url">Java Optimize GC Knowledge</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-04T14:01:22+08:00">
                2019-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h2><h3 id="Heap-Space"><a href="#Heap-Space" class="headerlink" title="Heap Space"></a>Heap Space</h3><p>选择堆的大小其实是一种平衡。如果分配的堆过于小，程序的大部分时间可能都消耗在 GC 上，没有足够的时间去运行应用程序的逻辑。但是，简单粗暴地设置一个特别大的堆也不是解决问题的方法。GC 停顿消耗的时间取决于堆的大小，如果增大堆的空间，停顿的持续时间也会变长。这种情况下，停顿的频率会变得更少，但是它们持续的时间会让程序的整体性能变慢。</p>
<p>使用超大堆还有另一个风险。操作系统使用虚拟内存机制管理机器的物理内存。一台机器可能有8G的物理内存，不过操作系统可能让你感觉有更多的可用内存。虚拟内存的数量取决于操作系统的设置，譬如操作系统可能让你感觉它的内存达到了16G。操作系统通过名为“交换”(swapping)(或者称之为分页)。你可以载入需要16G内存的应用程序，操作系统在需要时会将程序运行时不活跃的数据由内存复制到磁盘。再次需这部分内存的内容时，操作系统再将它们由磁盘重新载入到内存(为了腾出空间，通常它会先将另一部分内存的内容复制到磁盘)。</p>
<p>系统中运行着大量不同的应用程序时，这个流程工作得很顺畅，因为大多数的应用程序不会同时处于活跃状态。但是对于 Java 应用，它工作得并不那么好。如果一个 Java 应用使用了这个系统上大约 12G 的堆，操作系统可能在 RAM 上分配了 8G 的堆空间， 另外 4G 的空间存在于磁盘(这个假设对实际情况进行了一些简化，因为应用程序也会使用部分的RAM)。JVM 不会了解这些(操作系统完全屏蔽了内存交换的细节)。这样 JVM 愉快地填满了分配给它的 12G 堆空间。但这样就导致了严重的性能问题，因为操作系统需要将相当一部分的数据由磁盘交换到内存(这是一个昂贵操作的开始)。</p>
<p>另外就是，当发生 Full GC 的时候，JVM 必须访问整个堆的内容，此时如果触发了 swapping 操作，停顿时间将会比正常停顿时间更长(可能会是多个数量级增长)。同理可知，如果使用 Concurrent 收集器，后台线程在回收堆时，它的速度也可能会被拖慢，因为需要等待从磁盘复制数据到内存，结果导致发生代价昂贵的并发模式失效。</p>
<p>堆的大小由2个参数值控制：分别是初始值(通过 -Xms 设置)和最大值(通过 -Xmx 设置)。默认值的调节取决于多个因素，包括操作系统类型、系统内存大小、使用的 JVM。 其他的命令行标志也会对该值造成影响。</p>
<p><strong>堆大小的调节是 JVM 自适应调优的核心。</strong></p>
<p>JVM 的目标是依据系统可用的资源情况找到一个”合理的”默认初始值，当且仅当应用程序需要更多的内存(依据垃圾回收时消耗的时间来决定)时将堆的大小增大到一个合理的最大值。</p>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Xms</th>
<th>Xmx</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linux Client 32</td>
<td>16MB</td>
<td>256MB</td>
</tr>
<tr>
<td>Linux Server 32</td>
<td>64MB</td>
<td>Min(1GB, 1/4 physical memory)</td>
</tr>
<tr>
<td>Linux Server 64</td>
<td>Min(512MB, 1/64 physical memory)</td>
<td>Min(32GB, 1/4 physical memory)</td>
</tr>
<tr>
<td>MacOS Server 64</td>
<td>64MB</td>
<td>Min(1GB, 1/4 physical memory)</td>
</tr>
</tbody>
</table>
<p>如果 JVM 发现使用初始的堆大小，频繁地发生 GC，它就会尝试增大堆的空间，直到 JVM 的 GC 的频率回归到正常的范围，或者直到堆大小增大到它的上限值。</p>
<p>选择Heap Size的一个经验法则：<strong>完成 Full GC 后，应该释放出70%的空间，30%的空间仍然占用。</strong></p>
<p>注意，即使你设置了堆的最大值，还是会发生堆的自动调节：初始时堆以默认的大小开始运行，为了达到根据垃圾收集算法设置的性能目标，JVM 会逐步增大堆的大小。</p>
<p>将堆的大小设置得比实际需要更大不一定会带来性能损耗：堆并不会无限地增大，JVM 会调节堆的大小直到其满足 GC 的性能目标。</p>
<p>另一方面，如果你确切地了解应用程序需要多大的堆，那么你可以将堆的初始值和最大值直接设置成对应的数值(例如，-Xms4096m -Xmx4096m)。这种设置能稍微提高 GC 的运行效率，因为它不再需要估算堆是否需要调整大小了。</p>
<h4 id="ParallelScavenge-Throughput"><a href="#ParallelScavenge-Throughput" class="headerlink" title="ParallelScavenge(Throughput)"></a>ParallelScavenge(Throughput)</h4><p>ParallelScavenge 的调优几乎都是围绕停顿时间进行的，寻求堆的总体大小、新生代的大小以及老年代大小之间平衡。</p>
<p>调优方案时有两种取舍。首先比较经典的是编程技术上的取舍，即时间与空间的取舍。第二个取舍与完成垃圾回收所需的时长相关。</p>
<p>增大堆能够减少 Full GC 停顿发生的频率，但也有其局限性:由于 GC 时间变得更长，平均响应时间也会变长。类似地，为新生代分配更多的堆空间可以缩短 Full GC 的停顿时间，不过这又会增大老年代垃圾回收的频率(因为老年代空间保持不变或者变得更小了)。</p>
<img src="/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/scavenge_increase_heap_size.png" title="使用不同大小的堆时吞吐量的变化">
<p>使用 256 MB 的小堆时，应用服务器在垃圾回收上消耗了大量的时间(实际消耗的时间高达总时间的 36%)，吞吐量因此受到限制，比较低。随着堆大小的增加，吞吐量迅速提升——直到堆的容量增大到 1500 MB。这之后吞吐量的增速迅速减缓，这时应用程序实际已经不太受垃圾回收的影响(垃圾回收消耗的时间仅仅只占总时间的6%左右)。收益递减规律逐渐凸显出来：虽然应用程序可以通过增加内存的方式提升吞吐量，不过其效果已经很有限了。</p>
<p>堆的大小达到 4500 MB 后，吞吐量开始出现少量下滑。这时应用程序面临着第二个选择：增加的内存导致 GC 周期愈加冗长，虽然它们发生的频率小得多，但这些超长的 GC 周期也会影响系统整体的吞吐量。</p>
<p>这幅图中的数据取自关闭了自适应调整的 JVM，即它的最大、最小堆的容量设置成了同样的大小。对任何一种应用，我们都可以通过实验确定堆和代的最佳大小，但是让 JVM 自己来选择通常是更容易的方法(这也是最通常的做法，因为默认情况下自适应调整就是开启的)。</p>
<p>如果设置了 -XX:MaxGCPauseMillis=N 和 -XX:GCTimeRatio=N，ParallelScavenge 就会自适应地重新分配堆(包括代)的大小。</p>
<p>MaxGCPauseMillis 标志用于设定应用可承受的最大停顿时间。我们可以将其设置为0或者一些非常小的值，譬如50毫秒。<strong>请注意，这个标志设定的值同时影响 Minor GC 和 Full GC。</strong>如果设置的值非常小，那么应用的老年代最终就会非常小：譬如，你设定该参数希望应用在50毫秒内完成垃圾回收，这将会触发非常频繁的 Full GC，对应用程序的性能而言将是灾难性的。因此，设定该值时，请尽量保持理性，将该值设定为可达到的合理值。默认情况下，我们不设定该参数。</p>
<p>GCTimeRatio 标志可以设置你希望应用程序在垃圾回收上花费多少时间(与应用线程的运行时间相比较)。它是一个百分比，因此N值的计算稍微有些复杂。将N值代入下面的公 式可以计算出理想情况下应用线程的运行时间所占的百分比：</p>
<p><strong>ThroughputGoal = 1 - 1 / (1 + GCTimeRatio)</strong></p>
<p>GCTimeRatio 的默认值是99。将该值代入公式能得到0.99，这意味着应用程序的运行时间占总时间的99%，只有1%的时间消耗在垃圾回收上。但是，不要被列出的默认值搞糊涂。 譬如，GCTimeRatio 设置为95并不意味着会使用总时间的5%去做垃圾回收。它表示的是最多会使用总时间的1.94%去做垃圾回收。</p>
<p>建议先设定 ThroughputGoal 的期望值，通过 ThroughputGoal 去推算 GCTimeRatio 的值：</p>
<p><strong>GCTimeRatio = ThroughputGoal / (1 - ThroughputGoal)</strong></p>
<p>对于95%(0.95)的吞吐量目标，利用该公式计算出的 GCTimeRatio 是19。</p>
<p>JVM 使用这两个标志在堆的初始值(-Xms)和最大值(-Xmx)之间设置堆的大小。<strong>MaxGCPauseMillis 标志的优先级最高</strong>，如果设置了这个值，新生代和老年代会随之进行调整，直到满足对应停顿时间的目标。一旦这个目标达成，堆的总容量就开始逐渐增大，直到运行时间的比率达到设定值。这两个目标都达成后，JVM 会尝试缩减堆的大小，尽可能以最小的堆大小来满足这两个目标。</p>
<p>由于默认情况不设置停顿时间目标，通常自动堆调整的效果是堆(以及代空间)的大小会持续增大，直到满足设置的 GCTimeRatio 目标。不过，在实际操作中，该标志的默认设置已经相当优化了。每个人的使用经验各有不同，但是根据我以往的经验，如果应用程序在垃圾回收上消耗总时间的3%至6%，其效果会是相当不错的。</p>
<hr>
<h3 id="Generation-Space"><a href="#Generation-Space" class="headerlink" title="Generation Space"></a>Generation Space</h3><p>一旦堆的大小确定下来，接着就需要决定分配多少堆给新生代空间，多少给老年代空间。</p>
<p>我们应该清楚地了解代的划分对性能的影响：如果新生代分配得比较大，垃圾收集发生的频率就比较低，从新生代晋升到老年代的对象也更少。任何事物都有两面性，采用这种分配方法，老年代就相对比较小，比较容易被填满，会更频繁地触发 Full GC。</p>
<p>所有用于调整代空间的命令行标志调整的都是新生代空间，新生代空间剩下的所有空间都被老年代占用。</p>
<ul>
<li>-XX:NewRatio=N 设置新生代与老年代的空间占用比率，Default is 2。计算公式：Initial Young Gen Size = Initial Heap Size / (1 + NewRatio)，Default is 33%。</li>
<li>-XX:NewSize=N 设置新生代空间的初始大小。</li>
<li>-XX:MaxNewSize=N 设置新生代空间的最大大小。</li>
<li>-XmnN 将 NewSize 和 MaxNewSize 设定为同一个值的快捷方法。</li>
</ul>
<hr>
<h3 id="Permanent-Generation-and-Metaspace"><a href="#Permanent-Generation-and-Metaspace" class="headerlink" title="Permanent Generation and Metaspace"></a>Permanent Generation and Metaspace</h3><ul>
<li>Java 7：Permanent Generation</li>
<li>Java 8：Metaspace</li>
</ul>
<table>
<thead>
<tr>
<th>JVM Type</th>
<th>Min</th>
<th>Max</th>
<th>Limit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Client 32</td>
<td>12MB</td>
<td>64MB</td>
<td>Infinite</td>
</tr>
<tr>
<td>Server 32</td>
<td>16MB</td>
<td>64MB</td>
<td>Infinite</td>
</tr>
<tr>
<td>Server 64</td>
<td>20.75MB 82MB</td>
<td>Infinite</td>
</tr>
</tbody>
</table>
<p>对于永久代而言，可以通过 -XX:PermSize=N、-XX:MaxPermSize=N 标志调整大小。而元空间的大小可以通过 -XX:MetaspaceSize=N 和 -XX:MaxMetaspaceSize=N 调整。</p>
<blockquote>
<p>由于元空间默认的大小是没有作限制的，因此 Java 8(尤其是 32 位系统)的应用可能 由于元空间被填满而耗尽内存。如果元空间增长得过大，通过设置 MaxMetaspaceSize 你可以调整元空间的上限，将其限制为一个更小的值，不过这又会导 致应用程序最后由于元空间耗尽，发生 OutOfMemoryError 异常。解决这类问题的终极方 法还是定位出为什么类的元空间会变得如此巨大。</p>
</blockquote>
<p>如果程序在启动时发生大量的 Full GC(因为需要载入数量巨大的类)，通常都是由于永久代或者元空间发生了大小调 整，因此这种情况下为了改善启动速度，增大初始值是个不错的主意。对于定义了大量类的 Java 7 应用，同时还需要增大永久代空间的最大值。譬如，通常情况下应用服务器永久代的最大值会设置为128MB、192MB或者更多。</p>
<hr>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><h3 id="GC-Thread"><a href="#GC-Thread" class="headerlink" title="GC Thread"></a>GC Thread</h3><p>除 Serial 收集器之外几乎所有的垃圾收集器使用的算法都基于多线程。启动的线程数由<br><strong>-XX:ParallelGCThreads=N</strong> 参数控制。</p>
<p>受到该参数影响的 GC 分别是：</p>
<ul>
<li>-XX:+UseParallelGC 收集新生代空间</li>
<li>-XX:+UseParallelOldGC 收集老年代空间</li>
<li>-XX:+UseParNewGC 收集新生代空间</li>
<li>-XX:+UseG1GC 收集新生代空间</li>
<li>CMS的 STW 阶段(非 Full GC)</li>
<li>G1的 STW 阶段(非 Full GC)</li>
</ul>
<p>由于 GC 操作会暂停所有的应用程序线程，JVM 为了尽量缩短停顿时间就必须尽可能地利用更多的 CPU 资源。这意味着，默认情况下，JVM 会在机器的每个 CPU 上运行一个线程，最多同时运行 8 个。一旦达到这个上限，JVM 会调整算法，每超出 5/8 个 CPU 启动一个新的线程。所以总的线程数就是(这里的 N 代表 CPU 的数目):</p>
<p><strong>ParallelGCThreads = 8 + ((N - 8) * 5 / 8)</strong></p>
<blockquote>
<p>5 / 8 = 0.625</p>
</blockquote>
<p>有时候使用这个算法估算出来的线程数目会偏大。如果应用程序使用一个较小的堆(譬如大小为 1 GB)运行在一个八颗 CPU 的机器上，使用4个线程或者6个线程处理这个堆可能会更高效。在一个128颗 CPU 的机器上，启动83个垃圾收集线程可能也太多了，除非系统使用的堆已经达到了最大上限。</p>
<p>除此之外，如果机器上同时运行了多个 JVM 实例，限制所有 JVM 使用的线程总数是个不错的主意。这时，垃圾收集线程运行起来会更加高效，每个线程都能 100% 地利用各 CPU 的资源。在拥有更多 CPU、运行了多个 JVM 的机器上，通常出现的问题是有太多的垃圾回收 线程在同时并发运行。</p>
<p>以16核 CPU 的机器同时运行4个 JVM 实例为例，每个 JVM 默认会启动13个垃圾收集线程。如果4个 JVM 同时进行垃圾回收操作，机器上会启动大约52个 CPU 密集型线程竞争 CPU 资源。这会导致大量的冲突，如果能够限制每个 JVM 最多启动4个垃圾收集线程，效率会高很多。即使在同一个时刻，4个 JVM 中的线程不大可能同时进行 GC 操作， 一个 JVM 上同时运行13个线程也意味着其他 JVM 上的应用程序线程不得不在一台总共有16个 CPU，且其中13个 CPU 被繁忙的垃圾收集任务100%占用的机器上竞争资源。 这种情况下，将每个 JVM 的垃圾收集线程数限制到4个是一个比较合理的平衡。注意，这个标志不会对 CMS 收集器或者 G1 收集器的后台线程数作设定(虽然它们也会受设置的影响)。</p>
<hr>
<h2 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h2><h3 id="GC-Log"><a href="#GC-Log" class="headerlink" title="GC Log"></a>GC Log</h3><p>Enable Print Log Flag：</p>
<ul>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps：相对于 JVM 启动的时间的值。</li>
<li>-XX:+PrintGCDateStamps：实际的日期字符串。由于需要格式化时间，需要一点额外开销。</li>
<li>-Xloggc：filename：输出到文件。</li>
<li>-Xloggc：自动地开启基本日志模式。</li>
<li>-XX:+UseGCLogfileRotation、-XX:NumberOfGCLogfiles=N and -XX:GCLogfileSize=N：控制日志文件的循环。<blockquote>
<p>默认情况下，UseGCLogfileRotation 标志是关闭的。开启 UseGCLogfileRotation 标志后，默认的文件数目是0(意味着不作任 何限制)，默认的日志文件大小是0(同样也是不作任何限制)。因此，为了让日志循环功能真正生效，我们必须为所有这些标志设定值。需要注意的是，如果设定的数值不足 8 KB 的话，日志文件的大小会以 8 KB 为单位规整。</p>
</blockquote>
</li>
</ul>
<h4 id="ParallelScavenge-Log"><a href="#ParallelScavenge-Log" class="headerlink" title="ParallelScavenge Log"></a>ParallelScavenge Log</h4><p>ParallelScavenge 会进行两种操作：</p>
<ul>
<li>Minor GC </li>
<li>Full GC</li>
</ul>
<p><strong>Minor GC日志形式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17.806: [GC [PSYoungGen: 227983K-&gt;14463K(264128K)] 280122K-&gt;66610K(613696K), 0.0169320 secs] [Times: user=0.05 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure></p>
<p>这次 GC 在程序开始运行 17.806 秒后发生。现在新生代中对象占用的空间为 14463 KB (约为 14 MB，位于 Survivor 空间内)；GC 之前，新生代对象占用的空间为 227983 KB (约为 227 MB)。新生代这时总的大小为 264 MB。</p>
<blockquote>
<p>1000 KB = 1 MB</p>
</blockquote>
<p>与此同时，堆的空间总的使用情况(包含新生代和老年代)从 280 MB 减少到了 66 MB，这个时刻整个堆的大小为 613 MB。完成垃圾回收操作耗时 0.02 秒(排在输出最后的 Real 时间是 0.0 169 320 秒——实际时间进行了归整)。程序消耗的 CPU 时间比 Real 时间往往更多，原因是新生代垃圾回收会使用多个线程(GC使用了4个并行的线程)。</p>
<blockquote>
<p>PSYoungGen：-XX:+UseParallelOldGC，新生代和老年代都使用并行回收收集器。如果只启用-XX:+UseParallelGC，则表示新生代使用并行回收收集器，老年代使用串行收集器。<br>ParNew：-XX:+UseParNewGC，新生代使用并行收集器，老年代使用串行回收收集器。如果增加了-XX:+UseConcMarkSweepGC，则表示老年代使用CMS。<br>Throughput GC 通常是指 ParallelScavenge。它的目标是达到一个可控制的吞吐量(Throughput)，而CMS是尽可能地缩短在GC时用户线程的停顿时间。</p>
</blockquote>
<p><strong>Full GC日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">64.546: [Full GC [PSYoungGen: 15808K-&gt;0K(339456K)] [ParOldGen: 457753K-&gt;392528K(554432K)] 473561K-&gt;392528K(893888K) [PSPermGen: 56728K-&gt;56728K(115392K)], 1.3367080 secs] [Times: user=4.44 sys=0.01, real=1.34 secs]</span><br></pre></td></tr></table></figure>
<p>新生代的空间使用在经历 Full GC 之后变为 0 字节(新生代的大小为 339 MB)。老年代中的空间使用从 457 MB 减少到了 392 MB，因此整个堆的使用从 473 MB 减少到了 392 MB。</p>
<p>永久代空间的使用没有发生变化；在多数的 Full GC 中，永久代的对象都不会被回收。由于 Full GC 要进行大量的工作，所以消耗了约 1.3 秒的 Real 时间，4.4 秒的 CPU 时间(GC使用了4个并行的线程)。</p>
<blockquote>
<p>如果永久代空间耗尽，JVM 会发起 Full GC 回收永久代中的对象，这时你会观察到永久代空 间的变化——这是永久代进行回收唯一的情况。这个例子使用的是 Java 7；在 Java 8 中， 类似的信息可以在元空间中找到。</p>
</blockquote>
<hr>
<h4 id="CMS-Log"><a href="#CMS-Log" class="headerlink" title="CMS Log"></a>CMS Log</h4><p>CMS 的新生代垃圾收集与 ParallelScavenge 的新生代垃圾收集非常相似：对象从 Eden 空间移动到 Survivor 空间，或者移动到老年代空间。CMS GC 日志也非常相似。</p>
<p>注意点：</p>
<ul>
<li>CMS 垃圾回收有多个操作，但是期望的操作是 Minor GC 和 concurrent cycle，尽可能避免 Full GC。</li>
<li>CMS 回收过程中的并发模式失效以及晋升失败的代价都非常昂贵；应该尽量调优 CMS 以避免发生这些情况。</li>
<li>默认情况下 CMS 不会对永久代进行垃圾回收。</li>
</ul>
<p><strong>Minor GC日志形式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89.853: [GC 89.853: [ParNew: 629120K-&gt;69888K(629120K), 0.1218970 secs] 1303940K-&gt;772142K(2027264K), 0.1220090 secs]     [Times: user=0.42 sys=0.02, real=0.12 secs]</span><br></pre></td></tr></table></figure></p>
<p>这时的新生代空间大小为629MB。垃圾回收之后变成了 69MB(位于 Survivor 空间)。与 ParallelScavenge 日志类似，整个堆的大小为2027MB，其中 772MB在垃圾回收之后依然被占用。虽然并行的GC线程使用了0.42秒的 CPU 时间，但整个垃圾回收过程仅耗时 0.12秒。</p>
<p>回收新生代前后 Heap 变化如下：</p>
<img src="/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/cms_minor_gc_after.png">
<p>JVM 会依据堆的使用情况启动并发回收。当堆的占用达到某个程度时，JVM 会启动后台线程扫描堆，回收不用的对象。扫描结束的时候，堆的状况如上图的情况一样。</p>
<p>请注意，如果使用 CMS 回收器，老年代空间不会进行压缩整理：老年代空间由已经分配对象的空间和空闲空间共同组成。新生代垃圾收集将对象由 Eden 空间挪到老年代空间时，JVM 会尝试使用那些空闲的空间来保存这些晋升的对象。</p>
<p><strong>CMS-initial-mark 日志形式，STW</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89.976: [GC [1 CMS-initial-mark: 702254K(1398144K)] 772530K(2027264K), 0.0830120 secs] [Times: user=0.08 sys=0.00, real=0.08 secs]</span><br></pre></td></tr></table></figure>
<p>这个阶段的主要任务是找到堆中所有的垃圾回收根节点对象。从第一组数据中可以看到这个例子中对象占用了老年代空间 1398 MB(1398144K) 中的 702MB(702254K) 空间。第二组数据显示整个堆的大小为 2027MB(2027264K)，其中 772MB(772530K)被占用。应用程序线程在这个 CMS 回收周期中被暂停了0.08秒。</p>
<p><strong>CMS-concurrent-mark-start 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">90.059: [CMS-concurrent-mark-start]</span><br><span class="line">90.887: [CMS-concurrent-mark: 0.823/0.828 secs] [Times: user=1.11 sys=0.00, real=0.83 secs]</span><br></pre></td></tr></table></figure>
<p>标识阶段耗时 0.83秒(以及 1.11秒的 CPU 时间)。由于这个阶段进行的工作仅仅是标记，不会对堆的使用情况产生实质性的改变，所以没有任何相关的数据输出。如果这个阶段还有数据输出，很可能是由于这 0.83秒内新生代对象的分配导致了堆的增长，因为应用程序线程还在持续运行着。</p>
<p><strong>CMS-concurrent-preclean-start 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">90.887: [CMS-concurrent-preclean-start]</span><br><span class="line">90.892: [CMS-concurrent-preclean: 0.005/0.005 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p><strong>CMS-concurrent-abortable-preclean-start</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">90.892: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">92.392: [GC 92.393: [ParNew: 629120K-&gt;69888K(629120K), 0.1289040 secs] 1331374K-&gt;803967K(2027264K), 0.1290200 secs] [Times: user=0.44 sys=0.01, real=0.12 secs]</span><br><span class="line">94.473: [CMS-concurrent-abortable-preclean: 3.451/3.581 secs] [Times: user=5.03 sys=0.03, real=3.58 secs]</span><br><span class="line">94.474: [GC[YG occupancy: 466937 K (629120 K)]</span><br><span class="line">94.474: [Rescan (parallel) , 0.1850000 secs]</span><br><span class="line">94.659: [weak refs processing, 0.0000370 secs]</span><br><span class="line"><span class="comment"># STW 0.18s</span></span><br><span class="line">94.659: [scrub string table, 0.0011530 secs] [1 CMS-remark: 734079K(1398144K)] 1201017K(2027264K), 0.1863430 secs] [Times: user=0.60 sys=0.01, real=0.18 secs]</span><br></pre></td></tr></table></figure>
<p>这个”可中断预清理”(abortable preclean)阶段是做什么的呢?</p>
<p>使用可中断预清理阶段是由于标记阶段(严格说起来，它应该是最后的输出项)不是并发的，所有的应用线程进入标记阶段后都会被暂停。如果新生代收集刚刚结束，紧接着就是一个标记阶段的话，应用线程会遭遇2次连续的停顿操作，CMS 希望避免这样的情况发生。使用可中断预清理阶段的目的就是希望尽量缩短停顿的长度，避免连续的停顿。</p>
<p>因此，可中断预清理阶段会等到新生代空间占用到50%左右时才开始。理论上，这时离下一次新生代收集还有半程的距离，给了 CMS 最好的机会避免发生连续停顿。这个例子中，可中断预清理阶段在90.8秒开始，等待常规的新生代收集开始花了1.5秒(根据日志的记录，92.392秒开始)。CMS 根据以往的历史记录推算下一次新生代垃圾收集可能持续的时间。这个例子中，CMS 计算出的时长大约是4.2秒。所以2.1秒之后(即 94.4 秒)，CMS 收集器停止了预清理阶段(这种行为被称为“放弃”了这次回收，不过这可能是唯一能停止该次回收的方式)。这之后，CMS 终于开始了标记阶段的工作执行，标记阶段的回收工作将应用程序线程暂停了0.18秒(在可中断预清理过程中，应用程序线程不会被暂停)。</p>
<p><strong>CMS-concurrent-sweep-start 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">94.661: [CMS-concurrent-sweep-start]</span><br><span class="line">95.223: [GC 95.223: [ParNew: 629120K-&gt;69888K(629120K), 0.1322530 secs] 999428K-&gt;472094K(2027264K), 0.1323690 secs] [Times: user=0.43 sys=0.00, real=0.13 secs]</span><br><span class="line">95.474: [CMS-concurrent-sweep: 0.680/0.813 secs] [Times: user=1.45 sys=0.00, real=0.82 secs]</span><br></pre></td></tr></table></figure>
<p>这个阶段耗时0.82秒，回收线程与应用程序线程并发运行。碰巧这次的并发-清除过程被新生代垃圾回收中断了。新生代垃圾回收与清除阶段并没有直接的联系，将这个例子保留在这里是为了说明<strong>新生代的垃圾回收与老年代的垃圾回收可以并发进行</strong>。</p>
<img src="/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/cms_finish_gc.png">
<p>从上图可知，新生代的状态在并发收集的过程中发生了变化—清除过程中新生代可能发生了多次垃圾收集(至少发生了一次新生代垃圾回收，因为可中断的预清理至少会经历一次新生代垃圾回收)。</p>
<p><strong>CMS-concurrent-reset-start 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">95.474: [CMS-concurrent-reset-start]</span><br><span class="line">95.479: [CMS-concurrent-reset: 0.005/0.005 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure>
<p>这是并发运行的最后一个阶段。CMS 回收的周期至此告终，老年代空间中没有被引用的对象被回收。遗憾的是，我们无法从日志中了解到底有多少对象被回收。重置阶段的日志也没有提供更多的信息，最后还有多少堆空间被占用不得而知。为了发掘这些信息，我们尝试从新生代垃圾收集日志中找到一些蛛丝马迹，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">98.049: [GC 98.049: [ParNew: 629120K-&gt;69888K(629120K), 0.1487040 secs] 1031326K-&gt;504955K(2027264K), 0.1488730 secs]</span><br></pre></td></tr></table></figure>
<p>与89.853秒时(即 CMS 回收周期开始之前)老年代空间的占用情况相比较，那时的空间占用大约是703MB(整个堆的占用为 772MB，其中包含69MB的 Survivor 空间占用，因此老年代占用了剩下的703MB)。到98.049秒，垃圾收集结束，老年代空间占用大约为504MB，由此可以计算出 CMS 周期回收了大约199MB的内存。</p>
<p><strong>concurrent mode failure 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">267.006: [GC 267.006: [ParNew: 629120K-&gt;629120K(629120K), 0.0000200 secs]</span><br><span class="line">267.006: [CMS267.350: [CMS-concurrent-mark: 2.683/2.804 secs]</span><br><span class="line">             [Times: user=4.81 sys=0.02, real=2.80 secs]</span><br><span class="line">             (concurrent mode failure):</span><br><span class="line">                1378132K-&gt;1366755K(1398144K), 5.6213320 secs]</span><br><span class="line">                2007252K-&gt;1366755K(2027264K),</span><br><span class="line">                [CMS Perm : 57231K-&gt;57222K(95548K)], 5.6215150 secs]</span><br><span class="line">                [Times: user=5.63 sys=0.00, real=5.62 secs]</span><br></pre></td></tr></table></figure>
<p>新生代发生垃圾回收，同时<strong>老年代又没有足够的空间容纳晋升的对象</strong>时，CMS 回收就会退化成 Full GC。所有的应用线程都会被暂停，老年代中所有的无效对象都被回收，释放空间之后老年代的占用为1366MB——这次操作导致应用程序线程停顿长达5.6秒，这个操作是单线程的，这就是为什么它耗时如此之长的原因之一。</p>
<p><strong>promotion failed 日志形式</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6043.903: [GC 6043.903:</span><br><span class="line">            [ParNew (promotion failed): 614254K-&gt;629120K(629120K), 0.1619839 secs]</span><br><span class="line">             6044.217: [CMS: 1342523K-&gt;1336533K(2027264K), 30.7884210 secs]</span><br><span class="line">             2004251K-&gt;1336533K(1398144K),</span><br><span class="line">             [CMS Perm : 57231K-&gt;57231K(95548K)], 28.1361340 secs]</span><br><span class="line">             [Times: user=28.13 sys=0.38, real=28.13 secs]</span><br></pre></td></tr></table></figure>
<p>老年代有足够的空间可以容纳晋升的对象，但是由于<strong>空闲空间的碎片化</strong>，导致晋升失败。</p>
<p>CMS 启动了新生代垃圾回收，判断老年代似乎有足够的空闲空间可以容纳所有的晋升对象(否则，CMS 会报告发生并发模式失效)。但实际情况却不是如此：由于老年代空间的碎片化(或者，由于晋升实际要占用的内存超过了 CMS 的判断)，CMS 无法晋升这些对象。</p>
<p>因此，CMS 在新生代垃圾回收过程中(所有的应用线程都被暂停时)，对整个老年代空间进行了整理和压缩。好消息是，随着堆的压缩，碎片化问题解决了(至少在短期内不是问题了)。不过随之而来的是长达28秒的冗长的停顿时间。由于需要对整个堆进行整 理，这个时间甚至比 CMS 遭遇并发模式失效的时间还长的多，因为发生并发模式失效时，CMS 收集器只需要回收堆内无用的对象。</p>
<p>最终，CMS 日志中可能只有一条 Full GC 的记录，不含任何常规并发垃圾回收的日志。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">279.803: [Full GC 279.803:</span><br><span class="line">            [CMS: 88569K-&gt;68870K(1398144K), 0.6714090 secs] 558070K-&gt;68870K(2027264K),</span><br><span class="line">            [CMS Perm : 81919K-&gt;77654K(81920K)], 0.6716570 secs]</span><br></pre></td></tr></table></figure>
<p>应注意到，CMS 回收后永久代空间大小减小了。Java 8中，如果元空间需要调整，也会发生同样的情况。默认情况下，CMS 不会对永久代(或元空间)进行回收，因此，它一旦被用尽，就需要进行 Full GC，所有没有被引用的类都会被回收。</p>
<hr>
<h4 id="G1-Log"><a href="#G1-Log" class="headerlink" title="G1 Log"></a>G1 Log</h4><p><strong>Minor 日志形式，STW</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">23.430: [GC pause (young), 0.23094400 secs]</span><br><span class="line">     ...</span><br><span class="line">        [Eden: 1286M(1286M)-&gt;0B(1212M)</span><br><span class="line">             Survivors: 78M-&gt;152M Heap: 1454M(4096M)-&gt;242M(4096M)]</span><br><span class="line">        [Times: user=0.85 sys=0.05, real=0.23 secs]</span><br></pre></td></tr></table></figure>
<p>这里新生代垃圾收集的 Real 时间消耗是0.23秒，这期间，垃圾收集线程消耗了0.85秒的 CPU 时间，1286ßMB的对象移出了 Eden 空间(Eden 空间的大小调整到了1212MB)。这其中的74MB移动到了 Survivor 空间(Survivor 空间的大小从78 MB增加到了152MB)，其余的空间都被垃圾收集器回收掉了。</p>
<p>通过观察堆的总占用降低了1212MB我们知道，这些空间被释放了。通常情况下，一部分对象已经从 Survivor 空间移动到老年代空间，如果 Survivor 空间被填满，无法容纳新生代的晋升对象，部分 Eden 空间的对象会被直接晋升到老年代空间——这种情况下，老年代空间的占用也会增加。</p>
<img src="/2019/05/04/Java/JVM/Basic/Optimize-GC-Knowledge/g1_collect_new_generation.png" title="回收新生代前后对比">
<p><strong>initial-mark 日志形式，STW</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">50.541: [GC pause (young) (initial-mark), 0.27767100 secs]</span><br><span class="line">         [Eden: 1220M(1220M)-&gt;0B(1220M)</span><br><span class="line">             Survivors: 144M-&gt;144M Heap: 3242M(4096M)-&gt;2093M(4096M)]</span><br><span class="line">         [Times: user=1.02 sys=0.04, real=0.28 secs]</span><br></pre></td></tr></table></figure>
<p>同常规的新生代垃圾收集一样，初始—标记阶段中，应用线程被暂停(大约时长0.28秒)，之后新生代被清空(71MB的数据从新生代移到了老年代)。初始—标记阶段的输出日志表明后台并发周期启动。</p>
<p>由于初始—标记阶段也需要暂停所有的应用线程，G1 重用了新生代 GC 周期来完成这部分的工作。在新生代垃圾回收中添加初始标记阶段的影响并不大：与之前的垃圾收集相比较，CPU 周期的开销增加了大约20%，即便如此，停顿时间只有些微的增长(幸运的是，这台机器上有空闲的 CPU 周期可以运行并发 G1 回收线程，否则停顿时间会更长一些)。</p>
<p><strong>concurrent-root-region-scan-start 日志形式</strong></p>
<p>G1 扫描根分区(root region)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">50.819: [GC concurrent-root-region-scan-start]</span><br><span class="line">51.408: [GC concurrent-root-region-scan-end, 0.5890230]</span><br></pre></td></tr></table></figure>
<p>这个过程耗时0.58秒，不过扫描过程中不需要暂停应用线程，G1 使用后台线程进行扫描工作。不过，这个阶段中不能发生新生代垃圾收集，因此预留足够的 CPU 周期给后台线程运行是非常重要的。<strong>如果扫描根分区时，新生代空间刚巧用尽，新生代垃圾回收(会暂停所有的应用线程)必须等待根扫描结束才能完成。</strong>效果上，这意味着新生代垃圾收集的停顿时间会更长(远超过正常的耗时)。</p>
<p>如果出现上述情况，则输出的日志如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">350.994: [GC pause (young)</span><br><span class="line">351.093: [GC concurrent-root-region-scan-end, 0.6100090]</span><br><span class="line">351.093: [GC concurrent-mark-start], 0.37559600 secs]</span><br></pre></td></tr></table></figure>
<p>此处 GC 的停顿发生在根分区扫描之前，这意味着 GC 停顿还会继续等待，我们会看到 GC 日志中的相互交织的输出。GC 日志的时间戳显示应用线程等待了大概100毫秒——这就是新生代 GC 停顿时间比日志中其他停顿的平均持续时间还长100毫秒的原因。这是一个信号，说明你的 G1 需要进行调优。</p>
<p><strong>concurrent-mark-start 日志形式</strong></p>
<p>根分区扫描完成后，G1 就进入到并发标记阶段。这个阶段完全在后台运行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">111.382: [GC concurrent-mark-start]</span><br><span class="line">....</span><br><span class="line">120.905: [GC concurrent-mark-end, 9.5225160 sec]</span><br></pre></td></tr></table></figure>
<p>并发标记阶段是可以中断的，所以这个阶段中可能发生新生代垃圾收集。</p>
<p><strong>remark 日志形式，STW</strong></p>
<p>紧接在标记阶段之后的是重新标记(remarking)阶段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">120.910: [GC remark 120.959:</span><br><span class="line">         [GC ref-PRC, 0.0000890 secs], 0.0718990 secs]</span><br><span class="line">         [Times: user=0.23 sys=0.01, real=0.08 secs]</span><br><span class="line">120.985: [GC cleanup 3510M-&gt;3434M(4096M), 0.0111040 secs]</span><br><span class="line">         [Times: user=0.04 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure>
<p><strong>concurrent-cleanup-start 日志形式</strong></p>
<p>紧接着重新标记阶段的是清理阶段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">120.996: [GC concurrent-cleanup-start]</span><br><span class="line">120.996: [GC concurrent-cleanup-end, 0.0004520]</span><br></pre></td></tr></table></figure>
<p>至此，正常的 G1 周期结束了。清理阶段真正回收的内存数量很少，G1 到这个点为止真正做的事情是定位出哪些老的分区可回收垃圾最多。</p>
<hr>
<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><h4 id="Concurrent-Mode-Failure"><a href="#Concurrent-Mode-Failure" class="headerlink" title="Concurrent Mode Failure"></a>Concurrent Mode Failure</h4><p>调优 CMS 时最要紧的工作就是要避免发生并发模式失效以及晋升失败。正如我们在 CMS 回收日志中看到的那样，发生并发模式失效往往是由于 CMS 不能以足够快的速度清理老年代空间：新生代需要进行垃圾回收时，CMS 计算发现老年代没有足够的空闲空间可以容纳这些晋升对象，不得不先对老年代进行垃圾回收。</p>
<p>初始时老年代空间中对象是一个接一个整齐有序排列的。当老年代空间的占用达到某个程度(默认值为70%)时，并发回收就开始了。一个 CMS 后台线程开始扫描老年代空间，寻找无用的垃圾对象时，竞争就开始了：CMS 必须在老年代剩余的空间(30%)用 尽之前，完成老年代空间的扫描及回收工作。如果并发回收在这场速度的比赛中失利，CMS 就会发生并发模式失效。</p>
<p>解决思路：</p>
<ul>
<li>想办法增大老年代空间，要么只移动部分的新生代对象到老年代，要么增加更多的堆空间。</li>
<li>以更高的频率运行后台回收线程。</li>
<li>使用更多的后台回收线程。</li>
</ul>
<p>如果有更多的内存可用，更好的方案是增加堆的大小，否则可以尝试调整后台线程运行的方式来解决这个问题。</p>
<blockquote>
<p>CMS 收集器使用两个配置 MaxGCPauseMllis=N 和 GCTimeRatio=N 来确定使用多大的堆和多大的代空间。<br>CMS 回收方法与其他的GC回收方法一个显著的不同是除非发生 Full GC，否则 CMS 的新生代大小不会作调整。由于 CMS 的目标是尽量避免 Full GC，这意味着使用精细调优的 CMS 的应用程序永远不会调整它的新生代大小。<br>程序启动时可能频发并发模式失效，因为 CMS 需要调整堆和永久代(或者元空间)的大小。初始时采用一个比较大的堆(以及更大的永久代 / 元空间)是一个很好的主意，这是一个特例，增大堆的大小反而帮助避免了那些失效。</p>
</blockquote>
<hr>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="https://hllvm-group.iteye.com/group/topic/37095" target="_blank" rel="noopener">https://hllvm-group.iteye.com/group/topic/37095</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/05/03/Java/JVM/Basic/Prearraygement-Knowledge/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/03/Java/JVM/Basic/Prearraygement-Knowledge/" itemprop="url">Java JVM Prearrangement Knowledge</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-03T13:01:22+08:00">
                2019-05-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Basic/" itemprop="url" rel="index">
                    <span itemprop="name">Basic</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Ergonomics"><a href="#Ergonomics" class="headerlink" title="Ergonomics"></a>Ergonomics</h2><p>Ergonomics is the process by which the Java Virtual Machine (JVM) and garbage collection tuning, such as behavior-based(基于行为) tuning(调节，调整), improve application performance. </p>
<p>The JVM provides platform-dependent default selections for the garbage collector, heap size, and runtime compiler. These selections match the needs of different types of applications while requiring less command-line tuning. </p>
<p>In addition, behavior-based tuning dynamically tunes the sizes of the heap to meet a specified behavior of the application.</p>
<p>This section describes these default selections and behavior-based tuning. Use these defaults first before using the more detailed controls described in subsequent sections.</p>
<h3 id="Behavior-Based-Tuning"><a href="#Behavior-Based-Tuning" class="headerlink" title="Behavior-Based Tuning"></a>Behavior-Based Tuning</h3><h4 id="Maximum-Pause-Time-Goal"><a href="#Maximum-Pause-Time-Goal" class="headerlink" title="Maximum Pause Time Goal"></a>Maximum Pause Time Goal</h4><p><strong>The pause time is the duration during which the garbage collector stops the application and recovers space that is no longer in use.</strong> The intent of the maximum pause time goal is to limit the longest of these pauses. </p>
<p>An average time for pauses and a variance(方差) on that average is maintained by the garbage collector. The average is taken from the start of the execution but is weighted so that more recent pauses count more heavily. If the average plus the variance of the pause times is greater than the maximum pause time goal, then the garbage collector considers that the goal is not being met.</p>
<p>The maximum pause time goal is specified with the command-line option <strong>-XX:MaxGCPauseMillis=<nnn></nnn></strong>. This is interpreted(可理解的) as a hint to the garbage collector that pause times of <nnn> milliseconds or less are desired. The garbage collector will adjust the Java heap size and other parameters related to garbage collection in an attempt to keep garbage collection pauses shorter than <nnn> milliseconds. </nnn></nnn></p>
<p>By default there is no maximum pause time goal. These adjustments may cause garbage collector to occur more frequently, reducing the overall throughput of the application. The garbage collector tries to meet any pause time goal before the throughput goal. In some cases, though, the desired pause time goal cannot be met.</p>
<h4 id="Throughput-Goal"><a href="#Throughput-Goal" class="headerlink" title="Throughput Goal"></a>Throughput Goal</h4><p>The throughput goal is measured in terms of the time spent collecting garbage and the time spent outside of garbage collection (referred to as application time). </p>
<p>The goal is specified by the command-line option -XX:GCTimeRatio=<nnn>. The ratio of garbage collection time to application time is <strong>1 / (1 + <nnn>)</nnn></strong>. For example, -XX:GCTimeRatio=19 sets a goal of 1/20th or 5% of the total time for garbage collection.</nnn></p>
<p><strong>The time spent in garbage collection is the total time for both the young generation and old generation collections combined.</strong> If the throughput goal is not being met, then the sizes of the generations are increased in an effort to increase the time that the application can run between collections.</p>
<h4 id="Footprint-Goal"><a href="#Footprint-Goal" class="headerlink" title="Footprint Goal"></a>Footprint Goal</h4><p>If the throughput and maximum pause time goals have been met, then the garbage collector reduces the size of the heap until one of the goals (invariably(adv.总是) the throughput goal) cannot be met. The goal that is not being met is then addressed(处理，解决).</p>
<hr>
<h3 id="Tuning-Strategy"><a href="#Tuning-Strategy" class="headerlink" title="Tuning Strategy"></a>Tuning Strategy</h3><p>Do not choose a maximum value for the heap unless you know that you need a heap greater than the default maximum heap size. <strong>Choose a throughput goal that is sufficient for your application.</strong></p>
<p>The heap will grow or shrink to a size that will support the chosen throughput goal. A change in the application’s behavior can cause the heap to grow or shrink. For example, if the application starts allocating at a higher rate, the heap will grow to maintain the same throughput.</p>
<p>If the heap grows to its maximum size and the throughput goal is not being met, the maximum heap size is too small for the throughput goal. Set the maximum heap size to a value that is close to the total physical memory on the platform but which does not cause swapping of the application. Execute the application again. If the throughput goal is still not met, then the goal for the application time is too high for the available memory on the platform.</p>
<p>If the throughput goal can be met, but there are pauses that are too long, then select a maximum pause time goal. Choosing a maximum pause time goal may mean that your throughput goal will not be met, so choose values that are an acceptable compromise for the application.</p>
<p>It is typical that the size of the heap will oscillate(波动) as the garbage collector tries to satisfy competing goals. This is true even if the application has reached a steady state. The pressure to achieve a throughput goal (which may require a larger heap) competes with the goals for a maximum pause time and a minimum footprint (which both may require a small heap).</p>
<hr>
<h2 id="Arithmetic"><a href="#Arithmetic" class="headerlink" title="Arithmetic"></a>Arithmetic</h2><h3 id="对象存活判定算法"><a href="#对象存活判定算法" class="headerlink" title="对象存活判定算法"></a>对象存活判定算法</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>引用计数算法是在JVM中被摒弃的一种对象存活判定算法，不过它也有一些知名的应用场景（如Python、FlashPlayer）</p>
<p>用引用计数器判断对象是否存活的过程是这样的：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器加1；当引用失效时，计数器减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>引用计数算法的实现简单，判定效率也很高，大部分情况下是一个不错的算法。它没有被JVM采用的原因是它很难解决对象之间循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * testGC()方法执行后，objA和objB会不会被GC呢？ */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] bigSize = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">        objA.instance = objB;</span><br><span class="line">        objB.instance = objA;</span><br><span class="line"></span><br><span class="line">        objA = <span class="keyword">null</span>;</span><br><span class="line">        objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设在这行发生GC，objA和objB是否能被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这段代码中，对象objA 和对象objB都有字段instance，赋值令objA.instance = objB;、objB.instance = objA;，除此之外，这两个对象再无引用。如果JVM采用引用计数算法来管理内存，这两个对象不可能再被访问，但是他们互相引用着对方，导致它们引用计数不为0，所以引用计数器无法通知GC收集器回收它们。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>在主流商用程序语言的实现中，都是通过可达性分析（tracing GC）来判定对象是否存活的。</p>
<p>此算法的基本思路是：通过一系列的称为“GC Roots”的对象作为起点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是GC Roots到这个对象不可达）时，则证明此对象时不可用的。</p>

<p>对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象。</p>
<p>可以看到，GC Roots在对象图之外，是特别定义的“起点”，不可能被对象图内的对象所引用。</p>
<p>准确地说，GC Roots其实不是一组对象，而通常是一组特别管理的指向引用类型对象的指针，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，这也是tracing GC算法不会出现循环引用问题的基本保证。因此也容易得出，只有引用类型的变量才被认为是Roots，值类型的变量永远不被认为是Roots。只有深刻理解引用类型和值类型的内存分配和管理的不同，才能知道为什么root只能是引用类型。</p>
<p>在Java中，可作为GC Roots的对象包括以下几种：</p>
<ul>
<li><p>虚拟机栈（栈帧中的局部变量表，Local Variable Table）中引用的对象。</p>
</li>
<li><p>方法区中类静态属性引用的对象。</p>
</li>
<li><p>方法区中常量引用的对象。</p>
</li>
<li><p>本地方法栈中JNI（即一般说的Native方法）引用的对象。</p>
</li>
</ul>
<p>可以概括得出，可作为GC Roots的节点主要在全局性的引用与执行上下文中。要明确的是，tracing gc必须以当前存活的对象集为Roots，因此必须选取确定存活的引用类型对象。</p>
<p>GC管理的区域是Java堆，虚拟机栈、方法区和本地方法栈不被GC所管理，因此选用这些区域内引用的对象作为GC Roots，是不会被GC所回收的。</p>
<p>其中虚拟机栈和本地方法栈都是线程私有的内存区域，只要线程没有终止，就能确保它们中引用的对象的存活。</p>
<p>而方法区中类静态属性引用的对象是显然存活的。常量引用的对象在当前可能存活，因此，也可能是GC roots的一部分。</p>
<h4 id="两次标记与finalize-方法"><a href="#两次标记与finalize-方法" class="headerlink" title="两次标记与finalize()方法"></a>两次标记与finalize()方法</h4><p>即使在可达性分析算法中不可达的对象，也不是一定会死亡的，它们暂时都处于“缓刑”阶段，要真正宣告一个对象“死亡”，至少要经历两次标记过程：</p>
<p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finaliza()方法。</p>
<p>当对象没有覆盖finaliza()方法或者finaliza()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finaliza()方法，那么此对象将会放置在一个叫做 F-Queue 的队列中，并在稍后由一个虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发此方法，但并不承诺会等待它运行结束，原因是：如果一个对象在finaliza()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能导致F-Queue 队列中的其它对象永久处于等待，甚至导致整个内存回收系统崩溃。</p>
<p>finaliza()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue 队列中的对象进行第二次小规模的标记。如果对象想在finaliza()方法中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，例如把自己（this关键字）赋值给某个类变量或者对象的成员变量，这样在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，基本上它就真的被回收了</p>
<p>需要说明的是，使用finalize()方法来“拯救”对象是不值得提倡的，因为它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做的一个妥协。它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序。finalize() 能做的工作，使用try-finally或者其它方法都更适合、及时，所以笔者建议大家可以忘掉此方法存在。</p>
<hr>
<h3 id="GC-Arithmetic"><a href="#GC-Arithmetic" class="headerlink" title="GC Arithmetic"></a>GC Arithmetic</h3><h4 id="Mark-Sweep-标记-清除"><a href="#Mark-Sweep-标记-清除" class="headerlink" title="Mark-Sweep - 标记-清除"></a>Mark-Sweep - 标记-清除</h4><p>这是最基础的收集算法，顾名思义，算法分为两个阶段：</p>
<ul>
<li>标记：标记处所有需要回收的对象。</li>
<li>清除：统一回收所有被标记的对象。</li>
</ul>
<p>算法缺陷：</p>
<ul>
<li><p>效率问题，标记和清除两个过程的效率不高。</p>
<blockquote>
<p>因为内存碎片的存在，操作会变得更加费时，因为查找下一个可用空闲块已不再是一个简单操作。</p>
</blockquote>
</li>
<li><p>空间问题，标记清除之后会产生大量不连续的内存碎片。</p>
<blockquote>
<p>过多的内存碎片可能会造成后续在分配比较大的对象时，无法找到足够的连续内存而不得不提前触发另一次GC。</p>
</blockquote>
</li>
</ul>
<h4 id="Copying-复制"><a href="#Copying-复制" class="headerlink" title="Copying - 复制"></a>Copying - 复制</h4><p>该算法的出现是为了解决Mark-Sweep的效率问题。</p>
<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块内存上面，然后再把已使用过的内存空间一次性清理掉。</p>
<p>这样每次都只是对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。缺点是可用的内存空间缩小了一半。</p>
<h4 id="Mark-Compact-标记-整理"><a href="#Mark-Compact-标记-整理" class="headerlink" title="Mark-Compact - 标记-整理"></a>Mark-Compact - 标记-整理</h4><p>Copying算法在对象存活率较高时就要进行比较多的复制操作，效率将会降低。</p>
<p>更重要的是，如果不想浪费50%的空间，就需要额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，提出了Mark-Compact算法，标记过程与Mark-Sweep算法一样，但是清理过程不一样。</p>
<p>Mark-Compact算法的清理过程是<strong>让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存</strong>。</p>

<h4 id="Generational-Collection-分代收集"><a href="#Generational-Collection-分代收集" class="headerlink" title="Generational Collection - 分代收集"></a>Generational Collection - 分代收集</h4><p>这种算法并没有什么新的思想，只是根据对象存活周期的不同进行划分内存块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用适当的收集算法。</p>
<p>在新生代中，每次GC时都发现有大批对象死去，只有少量对象存活下来，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成回收。</p>
<p>在老年代中，因为对象的存活率高，没有额外空间对它进行分配担保，就必须使用Mark-Sweep或者Mark-Compact算法进行回收。</p>
<h4 id="Minor-GC与复制算法"><a href="#Minor-GC与复制算法" class="headerlink" title="Minor GC与复制算法"></a>Minor GC与复制算法</h4><p>现在的商业虚拟机都使用复制算法来回收新生代。新生代的GC又叫“Minor GC”，IBM公司的专门研究表明：新生代中的对象98%是“朝生夕死”的，所以Minor GC非常频繁，一般回收速度也比较快，同时“朝生夕死”的特性也使得Minor GC使用复制算法时不需要按照1:1的比例来划分新生代内存空间。</p>
<p><strong>Minor GC过程</strong></p>
<p>事实上，新生代将内存分为一块较大的Eden空间和两块较小的Survivor空间（From Survivor和To Survivor），每次Minor GC都使用Eden和From Survivor，当回收时，将Eden和From Survivor中还存活着的对象都一次性地复制到另外一块To Survivor空间上，最后清理掉Eden和刚使用的Survivor空间。</p>
<p>一次Minor GC结束的时候，Eden空间和From Survivor空间都是空的，而To Survivor空间里面存储着存活的对象。在下次MinorGC的时候，两个Survivor空间交换他们的标签，现在是空的“From” Survivor标记成为“To”，“To” Survivor标记为“From”。因此，在MinorGC结束的时候，Eden空间是空的，两个Survivor空间中的一个是空的，而另一个存储着存活的对象。</p>
<p>HotSpot虚拟机默认的 Eden:Survivor 的比例是 8:1，由于一共有两块Survivor，所以每次新生代中可用内存空间为整个新生代容量的90%（80%＋10%），只有10%的容量会被“浪费”。</p>
<p><strong>分配担保</strong></p>
<p>上文说的98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖老年代内存进行分配担保（Handle Promotion）。如果另外一块Survivor上没有足够空间存放上一次新生代收集下来的存活对象，这些对象将直接通过分配担保机制进入老年代。</p>
<hr>
<h3 id="GC-Collectors"><a href="#GC-Collectors" class="headerlink" title="GC Collectors"></a>GC Collectors</h3><p>GC需要完成的三件事：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>如果说收集算法是内存回收的方法论，那么垃圾回收器就是内存回收的具体实现。</p>

<ul>
<li>两个收集器之间存在连线：它们之间可以搭配使用。</li>
<li>虚拟机所处的区域：它属于新生代收集器还是老年代收集器。</li>
</ul>
<h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><p>Serial是最基本的，发展历史最悠久的Collector，在JDK 1.3.1之前，是虚拟机收集新生代的唯一选择。最适用于内存使用小于100MB的应用程序，这时候不论是CMS或G1都发挥不了太大的作用。</p>
<p>它是一个单线程的Collector，但它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条线程去完成GC，更重要的是在它进行GC时，必须暂停其他所有的工作线程(应用程序的线程)，直到它GC结束。</p>

<p>单线程是它的劣势，也是它的优势。</p>
<ul>
<li>简单而高效</li>
<li>对于限定单个CPU的环境来说，Serial没有线程交互开销，专心做GC工作自然可以获得最高的单线程GC效率。</li>
<li>在桌面应用场景中，Serial是JVM运行在Client模式下的一个很好的选择。</li>
</ul>
<h4 id="Serial-Old"><a href="#Serial-Old" class="headerlink" title="Serial Old"></a>Serial Old</h4><p>Serial Old是Serial的老年代版本，同样以单线程GC。它主要用于Client模式。</p>
<p>如果用于Sever模式，一种用途是在JDK 1.5之前版本中与Parallel Scavenge搭配使用，另一种用途就是作为CMS的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>

<h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><p>ParNew其实是Serial的多线程版本，除了以多线程GC外，其余行为和设置与Serial是一样的，比如控制参数(-XX:SuvivorRatio)、收集算法、STW对象分配规则、回收策略等等。</p>

<p>ParNew除了多线程GC之外，其他与Serial相比并没有太多创新之处，但它却是许多运行在Server模式下JVM首选的新生代Collector，其中还有一个与性能无关但很重要的原因是，除了Serial外，目前只有它可以与CMS配合使用。</p>
<h4 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h4><p>Parallel Scavenge是一个新生代的Collector，它使用的收集算法是Copying，以多线程进行GC。</p>
<p>它的目标是达到一个可控制的吞吐量(Throughput)，CMS是尽可能地缩短在GC时用户线程的停顿时间。</p>
<blockquote>
<p>吞吐量：CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 / (运行用户代码时间 + GC时间)。例如，虚拟机运行100分钟，其中GC花费了1分钟，那么吞吐量就是99%。</p>
</blockquote>
<p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>

<p>JVM调优关键参数：</p>
<ul>
<li>-XX:MaxGCPauseMillis：尽可能地保证GC的时间不超过该值。</li>
<li>-XX:GCTimeRatio：范围是0~100，GC时间占总时间的比率。例如，设置为19，即GC时间的最大占比为5%(1 / (1+19))，默认值为99，即GC最大占比为1%(1 / (1+99))</li>
<li>-XX:+UseAdaptiveSizePolicy：不需要手工指定新生代的大小、Eden与Survivor比例、晋升老年代对象年龄等等细节参数，JVM根据当前系统的运行情况进行动态调整这些参数以提供最适合的停顿时间和最大的吞吐量(GC自适应的调节策略 GC Ergonomics)。</li>
</ul>
<h4 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h4><p>Parallel Old是Parallel Scavenger的老年代版本，以多线程GC，使用Mark-Compact算法。</p>

<h4 id="CMS-Concurrent-Mark-Sweep"><a href="#CMS-Concurrent-Mark-Sweep" class="headerlink" title="CMS - Concurrent Mark Sweep"></a>CMS - Concurrent Mark Sweep</h4><p>Concurrent Low Pause Collector</p>
<p>CMS是一种期望得到最短GC时间为目标的Collector。CMS是基于Mark-Sweep实现的，整个过程分为以下几个步骤：</p>
<ul>
<li>初始标记(STW) - CMS initial mark，仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。</li>
<li>并发标记 - CMS concurrent mark，进行GC Roots Tracing的过程。</li>
<li>重新标记(STW) - CMS remark，为了修正并发标记期间因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，一般停顿时间比初始标记长一些，但远比并发标记短。</li>
<li>并发清除 - CMS concurrent sweep</li>
</ul>

<p>整个过程中最耗时的并发标记和并发清除过程都可以与用户线程一起运行。所以，从总体上来说，CMS内存回收过程与用户线程一起并发执行的。</p>
<p>与CMS配合使用的Collector：</p>
<ul>
<li>Young Generation：Serial、ParNew</li>
<li>Tenured Generation：SerialOld</li>
</ul>
<p>CMS缺点：</p>
<ul>
<li>对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分CPU资源而导致应用程序慢，总吞吐量会降低。CMS默认启动的GC线程数为(CPU + 3) / 4。</li>
<li>无法处理浮动垃圾(Floating Garbage)，可能出现Concurrent Mode Failure失败而导致另一次Full GC的产生。</li>
<li>空间碎片，因为它是基于Mark-Sweep算法实现的。</li>
</ul>
<h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><p>G1将堆空间划分成了互相独立的区块。每块区域既有可能属于O区、也有可能是Y区，且每类区域空间可以是不连续的（对比CMS的O区和Y区都必须是连续的）。这种将O区划分成多块的理念源于：当并发后台线程寻找可回收的对象时、有些区块包含可回收的对象要比其他区块多很多。虽然在清理这些区块时G1仍然需要暂停应用线程、但可以用相对较少的时间优先回收包含垃圾最多区块。这也是为什么G1命名为Garbage First的原因：第一时间处理垃圾最多的区块。</p>
<p>G1相对于CMS的区别在：</p>
<ul>
<li>G1在压缩空间方面有优势；</li>
<li>G1通过将内存空间分成区域（Region）的方式避免内存碎片问题；</li>
<li>Eden, Survivor, Old区不再固定、在内存使用效率上来说更灵活；</li>
<li>G1可以通过设置预期停顿时间（Pause Time）来控制垃圾收集时间避免应用雪崩现象；</li>
<li>G1在回收内存后会马上同时做合并空闲内存的工作、而CMS默认是在STW（stop the world）的时候做；</li>
<li>G1会在Young GC中使用，而CMS只能在O区使用。</li>
</ul>
<hr>
<h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><p>Java堆（Heap）是Java虚拟机所管理的内存中最大的一块，它被所有线程共享的，在虚拟机启动时创建。此内存区域唯一的目的是存放对象实例，几乎所有的对象实例都在这里分配内存，且每次分配的空间是不定长的。</p>
<p>在Heap中分配一定的内存来保存对象实例，实际上只是保存对象实例的属性值，属性的类型和对象本身的类型标记等，并不保存对象的方法（方法是指令，保存在Stack中），在Heap中分配一定的内存保存对象实例和对象的序列化比较类似。</p>
<p>对象实例在Heap中分配好以后，需要在Stack中保存一个4字节的Heap 内存地址，用来定位该对象实例在Heap中的位置，便于找到该对象实例。</p>
<p>Java虚拟机规范中描述道：所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都在堆上分配的定论也并不“绝对”了。</p>
<p>Java堆是垃圾收集器管理的主要区域，因此也被称为”GC堆(Garbage Collected Heap)”。从内存回收的角度看内存空间可如下划分：</p>

<ul>
<li>新生代（Young）</li>
</ul>
<p>新生成的对象优先存放在新生代中，新生代对象朝生夕死，存活率很低。在新生代中，常规应用进行一次垃圾收集一般可以回收70% ~ 95% 的空间，回收效率很高。</p>
<p>新生代又可细分为Eden空间、From Survivor空间、To Survivor空间，默认比例为8:1:1。</p>
<ul>
<li>老年代（Tenured/Old）</li>
</ul>
<p>在新生代中经历了多次（具体看虚拟机配置的阀值）GC后仍然存活下来的对象会进入老年代中。老年代中的对象生命周期较长，存活率比较高，在老年代中进行GC的频率相对而言较低，而且回收的速度也比较慢。</p>
<ul>
<li>永久代（Perm）</li>
</ul>
<p>永久代存储类信息、常量、静态变量、即时编译器编译后的代码等数据，对这一区域而言，Java虚拟机规范指出可以不进行垃圾收集，一般而言不会进行垃圾回收。</p>
<p><strong>新生代和老年代组成了Java堆的全部内存区域，而永久代不属于堆空间，它在JDK 1.8以前被Sun HotSpot虚拟机用作方法区的实现</strong></p>
<h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但这部分内存也被频繁运用，而却可能导致OutOfMemoryError异常出现，所以这里放到一起讲解。</p>
<p>以NIO（New Input/Output）类为例，NIO引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能避免在Java堆和Native堆中来回复制数据，在一些场景里显著提高性能。</p>
<p>本机直接内存的分配不会受到Java堆大小的限制，但是既然是内存，还是会受到本机总内存（包括RAM以及SWAP区或分页文件）大小以及处理器寻址空间的限制。服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统的限制），从而导致动态扩展时出现OutOfMemoryError异常。</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域。</p>
<p>Object Class Data(类定义数据)是存储在方法区的，此外，常量、静态变量、JIT编译后的代码也存储在方法区。正因为方法区所存储的数据与堆有一种类比关系，所以它还被称为 Non-Heap。</p>
<ul>
<li>JDK 1.8以前的永久代（PermGen）</li>
</ul>
<p>Java虚拟机规范对方法区的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集，也就是说，Java虚拟机规范只是规定了方法区的概念和它的作用，并没有规定如何去实现它。</p>
<p>对于JDK 1.8之前的版本，HotSpot虚拟机设计团队选择把GC分代收集扩展至方法区，即用永久代来实现方法区，这样HotSpot的垃圾收集器可以像管理Java堆一样管理这部分内存，能够省去专门为方法区编写内存管理代码的工作。对于其他的虚拟机（如Oracle JRockit、IBM J9等）来说是不存在永久代的概念的。</p>
<p>如果运行时有大量的类产生，可能会导致方法区被填满，直至溢出。常见的应用场景如：</p>
<ol>
<li><p>Spring和ORM框架使用CGLib操纵字节码对类进行增强，增强的类越多，就需要越大的方法区来保证动态生成的Class可以加载入内存。</p>
</li>
<li><p>大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）。</p>
</li>
<li><p>基于OSGi的应用（即使是同一个类文件，被不同的类加载器加载也会视为不同的类）</p>
</li>
</ol>
<p>这些都会导致方法区溢出，报出java.lang.OutOfMemoryError: PermGen space</p>
<ul>
<li>JDK 1.8的元空间（Metaspace）</li>
</ul>
<p>在JDK 1.8中，HotSpot虚拟机设计团队为了促进HotSpot与 JRockit的融合，修改了方法区的实现，移除了永久代，选择使用本地化的内存空间（而不是JVM的内存空间）存放类的元数据，这个空间叫做元空间（Metaspace）。</p>
<p>做了这个改动以后，java.lang.OutOfMemoryError: PermGen的空间问题将不复存在，并且不再需要调整和监控这个内存空间。</p>
<p>虚拟机需要为方法区设计额外的GC策略：如果类元数据的空间占用达到参数“MaxMetaspaceSize”设置的值，将会触发对死亡对象和类加载器的垃圾回收。</p>
<p>为了限制垃圾回收的频率和延迟，适当的监控和调优元空间是非常有必要的。元空间过多的垃圾收集可能表示类、类加载器内存泄漏或对你的应用程序来说空间太小了。</p>
<p>元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p>
<p>准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。</p>
<ul>
<li>运行时常量池（Runtime Constant Pool）</li>
</ul>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。</p>
<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池存放。</p>
<p>运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才能产生，也就是并非置入Class文件中的常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，此特性被开发人员利用得比较多的便是String类的intern() 方法。</p>
<hr>
<h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><h3 id="GC-Arithmetic-1"><a href="#GC-Arithmetic-1" class="headerlink" title="GC Arithmetic"></a>GC Arithmetic</h3><p>Conditions：</p>
<ul>
<li>-XX:+UseSerialGC, -XX:+UseParallelGC, -XX:+UseConcMarkSweepGC, -XX:ParallelCMSThreads=2, -XX:ParallelCMSThreads=4, -XX:+UseG1GC</li>
<li>每次运行大概花55分钟</li>
<li>-Xmx2048M -server</li>
<li>OpenJDK version: 1.8.0_51</li>
<li>Software: Linux version 4.0.4-301.fc22.x86_64</li>
<li>Hardware: Intel® Core™ i7-4790 CPU @ 3.60GHz</li>
<li>每次通过optaplanner解决13个问题，每个问题大概5分钟，并且前30秒的JVM预热时间不计算在内。</li>
<li>解决问题时不会发生IO，运行过程中，单个CPU完全饱和，并且会一直创建很多生命周期很短的对象，然后GC负责收集它们。</li>
<li>基准测试测量每毫秒能被计算的分数，越高表示越好。需要说明的是，计算一个分数可不是一件容易的事情，它涉及很多计算，有兴趣的话，可以去optaplanner查看它们的源码。</li>
</ul>
<hr>

<p>结果非常清晰，JDK8默认的ParallelGC是最快的，其他垃圾回收器相比默认的ParallelGC都会有不同程度的衰减，并且G1表现最差，是最慢的。</p>
<hr>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><blockquote>
<p><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="noopener">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a><br><a href="http://blog.jobbole.com/109170/" target="_blank" rel="noopener">http://blog.jobbole.com/109170/</a><br><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a><br><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a><br><a href="https://mp.weixin.qq.com/s/2H2ce_n2NQXWxueImpKaMA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/2H2ce_n2NQXWxueImpKaMA</a><br><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref5" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/ergonomics.html#sthref5</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/30/Java/JVM/Case/Check-CPU-Overload/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/Java/JVM/Case/Check-CPU-Overload/" itemprop="url">Check CPU Overload</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T17:31:22+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><h4 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h4><p>Problem Code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">"PID: $&#123;ManagementFactory.getRuntimeMXBean().name&#125;"</span>)</span><br><span class="line">val random = Random(System.currentTimeMillis())</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">    random.nextInt() * random.nextInt()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Top-CPU"><a href="#Top-CPU" class="headerlink" title="Top CPU"></a>Top CPU</h4><ul>
<li>Mac<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">top -o cpu</span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">- Linux</span><br><span class="line">``` bash</span><br><span class="line">top -c</span><br><span class="line"><span class="comment">#显示进程运行信息列表。按下P,进程按照cpu使用率排序</span></span><br><span class="line"></span><br><span class="line">top -Hp pid</span><br><span class="line"><span class="comment">#显示一个进程的线程运行信息列表。按下P,进程按照cpu使用率排序</span></span><br><span class="line"></span><br><span class="line">cat pid.stack | grep <span class="string">'ThreadId'</span> -C 8</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Dump-Process-Stack"><a href="#Dump-Process-Stack" class="headerlink" title="Dump Process Stack"></a>Dump Process Stack</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack -l PID &gt; pid.stack</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.181-b13 mixed mode):</span><br><span class="line"></span><br><span class="line"><span class="string">"Attach Listener"</span> <span class="comment">#11 daemon prio=9 os_prio=31 tid=0x00007ff4cf882800 nid=0x5903 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Service Thread"</span> <span class="comment">#10 daemon prio=9 os_prio=31 tid=0x00007ff4d2838000 nid=0x5703 runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C1 CompilerThread3"</span> <span class="comment">#9 daemon prio=9 os_prio=31 tid=0x00007ff4d2047800 nid=0x5503 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread2"</span> <span class="comment">#8 daemon prio=9 os_prio=31 tid=0x00007ff4d2047000 nid=0x4003 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread1"</span> <span class="comment">#7 daemon prio=9 os_prio=31 tid=0x00007ff4d2046000 nid=0x3e03 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"C2 CompilerThread0"</span> <span class="comment">#6 daemon prio=9 os_prio=31 tid=0x00007ff4cf842800 nid=0x3c03 waiting on condition [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Monitor Ctrl-Break"</span> <span class="comment">#5 daemon prio=5 os_prio=31 tid=0x00007ff4cf839000 nid=0x3a03 runnable [0x0000700005020000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at java.net.SocketInputStream.socketRead0(Native Method)</span><br><span class="line">	at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:171)</span><br><span class="line">	at java.net.SocketInputStream.read(SocketInputStream.java:141)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.readBytes(StreamDecoder.java:284)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.implRead(StreamDecoder.java:326)</span><br><span class="line">	at sun.nio.cs.StreamDecoder.read(StreamDecoder.java:178)</span><br><span class="line">	- locked &lt;0x000000071584d860&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.InputStreamReader.read(InputStreamReader.java:184)</span><br><span class="line">	at java.io.BufferedReader.fill(BufferedReader.java:161)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:324)</span><br><span class="line">	- locked &lt;0x000000071584d860&gt; (a java.io.InputStreamReader)</span><br><span class="line">	at java.io.BufferedReader.readLine(BufferedReader.java:389)</span><br><span class="line">	at com.intellij.rt.execution.application.AppMainV2<span class="variable">$1</span>.run(AppMainV2.java:64)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Signal Dispatcher"</span> <span class="comment">#4 daemon prio=9 os_prio=31 tid=0x00007ff4d2816800 nid=0x4303 runnable [0x0000000000000000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Finalizer"</span> <span class="comment">#3 daemon prio=8 os_prio=31 tid=0x00007ff4cf818000 nid=0x4b03 in Object.wait() [0x0000700004e1a000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000715588ed0&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:144)</span><br><span class="line">	- locked &lt;0x0000000715588ed0&gt; (a java.lang.ref.ReferenceQueue<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.ReferenceQueue.remove(ReferenceQueue.java:165)</span><br><span class="line">	at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.run(Finalizer.java:216)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"Reference Handler"</span> <span class="comment">#2 daemon prio=10 os_prio=31 tid=0x00007ff4d0807000 nid=0x3503 in Object.wait() [0x0000700004d17000]</span></span><br><span class="line">   java.lang.Thread.State: WAITING (on object monitor)</span><br><span class="line">	at java.lang.Object.wait(Native Method)</span><br><span class="line">	- waiting on &lt;0x0000000715586bf8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.Object.wait(Object.java:502)</span><br><span class="line">	at java.lang.ref.Reference.tryHandlePending(Reference.java:191)</span><br><span class="line">	- locked &lt;0x0000000715586bf8&gt; (a java.lang.ref.Reference<span class="variable">$Lock</span>)</span><br><span class="line">	at java.lang.ref.Reference<span class="variable">$ReferenceHandler</span>.run(Reference.java:153)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007ff4d0006800 nid=0x2703 runnable [0x00007000040f3000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt:9)</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Thread"</span> os_prio=31 tid=0x00007ff4cf007000 nid=0x4c03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#0 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf006000 nid=0x1f07 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#1 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4d000f800 nid=0x2a03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#2 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf803000 nid=0x2c03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#3 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf804000 nid=0x5303 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#4 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf804800 nid=0x2d03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#5 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf805000 nid=0x5003 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#6 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf805800 nid=0x4f03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#7 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4d0802800 nid=0x4e03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#8 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf806800 nid=0x3103 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"GC task thread#9 (ParallelGC)"</span> os_prio=31 tid=0x00007ff4cf807000 nid=0x4d03 runnable</span><br><span class="line"></span><br><span class="line"><span class="string">"VM Periodic Task Thread"</span> os_prio=31 tid=0x00007ff4cf845800 nid=0xa803 waiting on condition</span><br><span class="line"></span><br><span class="line">JNI global references: 15</span><br></pre></td></tr></table></figure>
<p>抽出关键部分</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"main"</span> <span class="comment">#1 prio=5 os_prio=31 tid=0x00007ff4d0006800 nid=0x2703 runnable [0x00007000040f3000]</span></span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt:9)</span><br><span class="line">	at com.demo.death.CPUOverloadKt.main(CPUOverload.kt)</span><br><span class="line"></span><br><span class="line">   Locked ownable synchronizers:</span><br><span class="line">	- None</span><br></pre></td></tr></table></figure>
<p>其中 nid=0x2703 是线程ID号，换算成十进制是9987</p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="https://wsgzao.github.io/post/htop/" target="_blank" rel="noopener">https://wsgzao.github.io/post/htop/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/30/Java/Math/Double/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/30/Java/Math/Double/" itemprop="url">Java Double</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-30T16:01:22+08:00">
                2019-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/Math/" itemprop="url" rel="index">
                    <span itemprop="name">Math</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val a = <span class="number">1f</span></span><br><span class="line">val b = <span class="number">0.9f</span></span><br><span class="line">val r = a - b</span><br><span class="line">println(r)  <span class="comment">//  0.100000024</span></span><br></pre></td></tr></table></figure>
<p><strong>为什么会出现这个误差？</strong>接下来我们一步一步解答这个问题。</p>
<h4 id="科学计数法"><a href="#科学计数法" class="headerlink" title="科学计数法"></a>科学计数法</h4><p>在数学中，采用科学计数法来近似表示一个极大或极小且位数较多的数。</p>
<img src="/2019/04/30/Java/Math/Double/scientific_notation.png">
<p>科学计数法组成部分：</p>
<ul>
<li>有效数字：从第1个非零数字开始的全部数字；</li>
<li>指数：决定小数点的位置；</li>
<li>符号：表示正负数。</li>
</ul>
<p>科学计数法可以唯一的表示任何一个数字，且所占用的存储空间会更少。浮点数表示方式：</p>
<img src="/2019/04/30/Java/Math/Double/float_component.png">
<hr>
<p>存储时的组成部分：</p>
<img src="/2019/04/30/Java/Math/Double/store_component.png">
<p>Float类型的内存分布：</p>
<img src="/2019/04/30/Java/Math/Double/float_type_memory_component.png">
<p>Double类型的内存分布：</p>
<img src="/2019/04/30/Java/Math/Double/double_type_memory_component.png">
<hr>
<p>目前业界流行的浮点数标准是 IEEE754，规定了4种浮点数类型：</p>
<ul>
<li>单精度</li>
<li>双精度</li>
<li>延伸单精度</li>
<li>延伸双精度</li>
</ul>
<blockquote>
<p>其中前两种类型是最常用的。</p>
</blockquote>
<img src="/2019/04/30/Java/Math/Double/float_precision.png" title="单双精度取值范围">
<h4 id="单精度"><a href="#单精度" class="headerlink" title="单精度"></a>单精度</h4><img src="/2019/04/30/Java/Math/Double/single_float_format.png">
<p>数制从十进制到二进制，还要考虑内存硬件设备的实现方式。指数称为”阶码”，有效数字称为”尾数”。所以用于存储符号、阶码、尾数的二进制位分别称为符号位、阶码位、尾数位。</p>
<ol>
<li>符号位</li>
</ol>
<p>在最高二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数。</p>
<ol start="2">
<li>阶码位</li>
</ol>
<p>在符号位右侧分配8位用来存储指数，IEEE754 标准规定阶码位存储的是指数对应的移码，而不是指数的原码或补码。</p>
<ol start="3">
<li>尾数位</li>
</ol>
<p>最右侧分配连续的23位用来存储有效数字，IEEE754 标准规定尾数以原码表示。</p>
<p>正指数和有效数字的最大值决定了32位存储空间能够表示浮点数的十进制最大值。</p>
<p>指数最大值为2^127 约等于 1.7 x 10^38。</p>
<p>有效数字部分最大值是二进制的 1.11···1(小数点后23个1)，是个无限接近于2的数字，所以得到最大的十进制数为2 × 1.7 × 10^38，再加上最左1位的符号，最终得到32位浮点数最大值为 3.4e+38。</p>
<img src="/2019/04/30/Java/Math/Double/decimal_binary_format.png">
<h4 id="为什么8位阶码的偏置为127？"><a href="#为什么8位阶码的偏置为127？" class="headerlink" title="为什么8位阶码的偏置为127？"></a>为什么8位阶码的偏置为127？</h4><p>8位移码的取值范围为0~255（00000000~11111111），但在浮点数的阶码中，00000000与11111111被保留用作特殊情况，所以阶码可用范围只有1~254，总共有254个值。</p>
<p>8位有符号数取值范围为-128~+127（10000000~01111111），这里的二进制用补码表示，其中特别规定补码10000000没有原码，为-128的补码，总共有256个值。</p>
<p>如果采用偏置128，在表达+127(2的7次方=127)时会产生上溢（移码11111111被保留），所以在阶码中偏置为（128-1），与此同时，在表达-127时会产生下溢（移码00000000被保留），所以阶码中去掉-127与-128，取值范围为-126~127，总共254个值。</p>
<h4 id="原码、补码、反码"><a href="#原码、补码、反码" class="headerlink" title="原码、补码、反码"></a>原码、补码、反码</h4><p>计算机保存最原始的数字，不区分正负数，即无符号数字。如果我们在内存分配4位(bit)去存放无符号数字，是下面这样子的：</p>
<table>
<thead>
<tr>
<th>十进制</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
</tr>
<tr>
<td>3</td>
<td>0011</td>
</tr>
<tr>
<td>4</td>
<td>0100</td>
</tr>
<tr>
<td>5</td>
<td>0101</td>
</tr>
</tbody>
</table>
<p>后来在生活中为了表示“欠别人钱”这个概念，就从无符号数中，划分出了“正数”和“负数”。<strong>为了表示正与负，人们发明了”原码”，把生活应该有的正负概念，原原本本的表示出来。</strong></p>
<table>
<thead>
<tr>
<th>正数</th>
<th>二进制</th>
<th>负数</th>
<th>二进制</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000</td>
<td>-0</td>
<td>1000</td>
</tr>
<tr>
<td>1</td>
<td>0001</td>
<td>-1</td>
<td>1001</td>
</tr>
<tr>
<td>2</td>
<td>0010</td>
<td>-2</td>
<td>1010</td>
</tr>
</tbody>
</table>
<p>但使用“原码”储存的方式，方便了看的人类，却苦了计算机。们希望(+1)和(-1)相加是0，但计算机只能算出0001+1001=1010(-2)，这个结果并不是我们想要的。此外，0的表示有两种方式：+0 和 -0。</p>
<p><strong>为了解决”正负相加等于0”的问题，在”原码”的基础上，人们发明了”反码”。</strong>“反码”表示方式是用来处理负数的，符号位置不变，其余位置相反：</p>
<img src="/2019/04/30/Java/Math/Double/fan_ma_vs_yuan_ma.png">
<p>当“原码”变成“反码”时，完美的解决了“正负相加等于0”的问题。+1 和 -1 相加，变成了0001 + 1101 = 1111，刚好反码表示方式中，1111象征-0。</p>
<p>人们总是进益求精，历史遗留下来的问题—— 有两个零存在：+0 和 -0，我们希望只有一个0，所以发明了”补码”，同样是针对”负数”做处理的。</p>
<p>“补码”的意思是，从原来”反码”的基础上，补充一个新的代码：+1。</p>
ß<br><br>有得必有失，在补一位1的时候，要丢掉最高位。<br><br>我们要处理”反码”中的”-0”，当1111再补上一个1之后，变成了10000，丢掉最高位就是0000，刚好和左边正数的0相同。<br><br>这样就解决了+0和-0同时存在的问题，另外”正负数相加等于0”的问题，同样得到满足：<br><br>例如，3 和 -3 相加，0011 + 1101 = 10000，丢掉最高位，就是0000(0)。<br><br>同样有失必有得，我们失去了-0，收获了-8。<br><br><br><br>#### Range<br><br><strong>基本类型：int 二进制位数：32</strong><br>包装类：java.lang.Integer<br>最小值：Integer.MIN_VALUE= -2147483648 （-2的31次方）<br>最大值：Integer.MAX_VALUE= 2147483647  （2的31次方-1）<br><br><strong>基本类型：short 二进制位数：16</strong><br>包装类：java.lang.Short<br>最小值：Short.MIN_VALUE=-32768 （-2的15此方）<br>最大值：Short.MAX_VALUE=32767 （2的15次方-1）<br><br><strong>基本类型：long 二进制位数：64</strong><br>包装类：java.lang.Long<br>最小值：Long.MIN_VALUE=-9223372036854775808 （-2的63次方）<br>最大值：Long.MAX_VALUE=9223372036854775807 （2的63次方-1）<br><br><strong>基本类型：float 二进制位数：32</strong><br>包装类：java.lang.Float<br>最小值：Float.MIN_VALUE=1.4E-45 （2的-149次方）<br>最大值：Float.MAX_VALUE=3.4028235E38 （2的128次方-1）<br><br><strong>基本类型：double 二进制位数：64</strong><br>包装类：java.lang.Double<br>最小值：Double.MIN_VALUE=4.9E-324 （2的-1074次方）<br>最大值：Double.MAX_VALUE=1.7976931348623157E308 （2的1024次方-1）<br><br><br><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>### Memory Usage<br><br>- Double: 8 Byte，range(1.4E-45 ~ 3.4028235E38)<br>- Float: 4 Byte，range(4.9E-324 ~ 1.7976931348623157E308)<br><br><br><br><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong><br>### Comparison<br><br>#### Check whether value is zero<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isZero</span><span class="params">(<span class="keyword">double</span> value, <span class="keyword">double</span> threshold)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt;= -threshold &amp;&amp; value &lt;= threshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Case-Simple-comparison"><a href="#Case-Simple-comparison" class="headerlink" title="Case - Simple comparison"></a>Case - Simple comparison</h4><p>First look at the simple comparison to understand what exactly is wrong with comparing double with == operator. In given program, I am creating same floating point number (i.e. 1.1) using two methods:</p>
<ul>
<li>Add .1, 11 times.</li>
<li>Multiply .1 to 11.</li>
</ul>
<p>In theory, both operations should produce the number 1.1. And when we compare the results of both methods, it should match.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Method 1</span></span><br><span class="line">var f1 = .<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 += .<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//  It's acutally 1.1</span></span><br><span class="line"><span class="comment">//  f1 is computed to 1.0999999999999999. Its exactly the problem which rounding off causes internally. </span></span><br><span class="line"><span class="comment">//  That’s why, floating point comparison with '==' operator is not recommended.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Method 2</span></span><br><span class="line">val f2 = .<span class="number">1</span> * <span class="number">11</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1 == f2 -&gt; $&#123;f1 == f2&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.0999999999999999, f2 1.1</span><br><span class="line">f1 == f2 -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Use BigDecimal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1</span></span><br><span class="line">var f1 = BigDecimal(<span class="string">"0.0"</span>)</span><br><span class="line">val pointOne = BigDecimal(<span class="string">"0.1"</span>)</span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 = f1.add(pointOne)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2</span></span><br><span class="line">var f2 = BigDecimal(<span class="string">"0.1"</span>)</span><br><span class="line">val eleven = BigDecimal(<span class="string">"11"</span>)</span><br><span class="line">f2 = f2.multiply(eleven)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1.compareTo(f2) -&gt; $&#123;f1.compareTo(f2) == 0&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.1, f2 1.1</span><br><span class="line">f1.compareTo(f2) -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Case-Threshold-based-comparison-lt-—-Recommended"><a href="#Case-Threshold-based-comparison-lt-—-Recommended" class="headerlink" title="Case - Threshold based comparison &lt;— Recommended"></a>Case - Threshold based comparison &lt;— Recommended</h4><p>Using programming, we cannot change the way these floating point numbers are stored or computed. So we have to adapt a solution where we agree that a determine the differences in both values which we can tolerate and still consider the numbers equal. This agreed upon difference in values is called the <strong>threshold</strong> or <strong>epsilon</strong>.</p>
<p>So now to use ‘threshold based floating point comparison‘, we can use the Math.abs() method to compute a difference between the two numbers and compare the difference to a threshold value.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val threshold = <span class="number">0.0001</span></span><br><span class="line"><span class="comment">//Method 1</span></span><br><span class="line">var f1 = .<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (i in <span class="number">1</span>..<span class="number">11</span>) &#123;</span><br><span class="line">    f1 += .<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Method 2</span></span><br><span class="line">val f2 = .<span class="number">1</span> * <span class="number">11</span></span><br><span class="line"></span><br><span class="line">println(<span class="string">"f1 $f1, f2 $f2"</span>)</span><br><span class="line">println(<span class="string">"f1 == f2 -&gt; $&#123;Math.abs(f1 - f2) &lt; threshold&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 1.0999999999999999, f2 1.1</span><br><span class="line">f1 == f2 -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Case-Compare-with-BigDecimal-lt-—-Recommended"><a href="#Case-Compare-with-BigDecimal-lt-—-Recommended" class="headerlink" title="Case - Compare with BigDecimal &lt;— Recommended"></a>Case - Compare with BigDecimal &lt;— Recommended</h4><p>In BigDecimal class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved.</p>
<p>Best part is that BigDecimal numbers are <strong>immutable</strong> i.e. if you create a BigDecimal BD with value “1.23”, that object will remain “1.23” and can never be changed. This class provide many methods which can be used to do numerical operations on it’s value.</p>
<p>You can use it’s <strong>compareTo()</strong> method to compare to BigDecimal numbers. It ignore the scale while comparing.</p>
<blockquote>
<p>Special Note：Never use the equals() method to compare BigDecimal instances. That is because this equals function will compare the scale. If the scale is different, equals() will return false, even if they are the same number mathematically.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val a = BigDecimal(<span class="string">"2.00"</span>)</span><br><span class="line">val b = BigDecimal(<span class="string">"2.0"</span>)</span><br><span class="line"></span><br><span class="line">println(<span class="string">"a == b --&gt; $&#123;a == b&#125;"</span>)</span><br><span class="line">println(<span class="string">"a.compareTo(b) --&gt; $&#123;a.compareTo(b) == 0&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a == b --&gt; <span class="literal">false</span></span><br><span class="line">a.compareTo(b) --&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="NaN-and-INFINITY"><a href="#NaN-and-INFINITY" class="headerlink" title="NaN and INFINITY"></a>NaN and INFINITY</h3><ul>
<li>Once a NaN always a NaN</li>
<li>Double.MAX_VALUE overflow into POSITIVE_INFINITY, The same goes for Double.MIN_VALUE except that it will overflow to Double.NEGATIVE_INFINITY.</li>
</ul>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = Math.sqrt(-<span class="number">1.0</span>)</span><br><span class="line">println(<span class="string">"Math.sqrt(-1.0) -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"Double.NaN == result -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(-1.0) -&gt; NaN</span><br><span class="line">Double.NaN == result -&gt; <span class="literal">true</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="NEGATIVE-INFINITY"><a href="#NEGATIVE-INFINITY" class="headerlink" title="NEGATIVE_INFINITY"></a>NEGATIVE_INFINITY</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = -Double.MAX_VALUE * Double.MAX_VALUE</span><br><span class="line">println(<span class="string">"Double.MAX_VALUE * Double.MAX_VALUE -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"Double.NaN == result -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Double.MAX_VALUE * Double.MAX_VALUE -&gt; -Infinity</span><br><span class="line">Double.NaN == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">true</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br></pre></td></tr></table></figure></p>
<h4 id="POSITIVE-INFINITY"><a href="#POSITIVE-INFINITY" class="headerlink" title="POSITIVE_INFINITY"></a>POSITIVE_INFINITY</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val result = <span class="number">5.0</span> / <span class="number">0</span></span><br><span class="line">println(<span class="string">"5.0 / 0 -&gt; $result"</span>)</span><br><span class="line">println(<span class="string">"isNaN -&gt; $&#123;result.isNaN()&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.NEGATIVE_INFINITY == result -&gt; $&#123;Double.NEGATIVE_INFINITY == result&#125;"</span>)</span><br><span class="line">println(<span class="string">"Double.POSITIVE_INFINITY == result -&gt; $&#123;Double.POSITIVE_INFINITY == result&#125;"</span>)</span><br></pre></td></tr></table></figure>
<p>Output：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5.0 / 0 -&gt; Infinity</span><br><span class="line">isNaN -&gt; <span class="literal">false</span></span><br><span class="line">Double.NEGATIVE_INFINITY == result -&gt; <span class="literal">false</span></span><br><span class="line">Double.POSITIVE_INFINITY == result -&gt; <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://blog.csdn.net/a327369238/article/details/52354811" target="_blank" rel="noopener">https://blog.csdn.net/a327369238/article/details/52354811</a></li>
<li><a href="https://howtodoinjava.com/java/basics/correctly-compare-float-double/" target="_blank" rel="noopener">https://howtodoinjava.com/java/basics/correctly-compare-float-double/</a></li>
<li><a href="https://www.avocado.com.au/resources/tech-tips/java-double-nan-weirdness/" target="_blank" rel="noopener">https://www.avocado.com.au/resources/tech-tips/java-double-nan-weirdness/</a></li>
<li><a href="https://www.zhihu.com/question/20159860" target="_blank" rel="noopener">https://www.zhihu.com/question/20159860</a></li>
<li><a href="https://blog.51cto.com/zangyanan/1854836" target="_blank" rel="noopener">https://blog.51cto.com/zangyanan/1854836</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Case/CustomClassLoader造成YGC越来越慢/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Case/CustomClassLoader造成YGC越来越慢/" itemprop="url">CustomClassLoader造成YGC越来越慢，为什么？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T23:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://lovestblog.cn/blog/2016/03/15/ygc-classloader/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2016/03/15/ygc-classloader/</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://sulangsss.github.io/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jason - sulang357159@163.com">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="A Big Boy Blog -  Tech Articls & Notes">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/" itemprop="url">StringTable造成YGC越来越慢，为什么？</a></h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-27T21:31:22+08:00">
                2019-04-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/" itemprop="url" rel="index">
                    <span itemprop="name">JVM</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/JVM/Case/" itemprop="url" rel="index">
                    <span itemprop="name">Case</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringYGC</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getUUID</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().intern()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val stringYGC = StringYGC()</span><br><span class="line">    val times = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1</span>..times) &#123;</span><br><span class="line">        stringYGC.getUUID()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JVM Options：-XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -Xmx2G -Xms2G -Xmn100M</p>
<p>这里特意将新生代设置比较小，老生代设置比较大，让代码在执行过程中更容易突出问题来，大量做ygc，期间不做CMS GC。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8306K(92160K), 0.0087308 secs] 81920K-&gt;8306K(2086912K), 0.0087759 secs] [Times: user=0.06 sys=0.01, real=0.01 secs]</span><br><span class="line">.....</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10240K(92160K), 0.1632875 secs] 1089021K-&gt;1017720K(2086912K), 0.1633312 secs] [Times: user=1.51 sys=0.02, real=0.16 secs]</span><br></pre></td></tr></table></figure>
<p>从输出的Log来看，发现YGC不断发生，并且每次YGC时间不断在增长，从9ms慢慢增长到了163ms，甚至还会继续涨下去。原因是什么？</p>
<hr>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h3><p>我们先来了解下intern方法的实现，这是String提供的一个方法，JVM提供这个方法的目的是希望对于某个同名字符串使用非常多的场景，在JVM里只保留一份，比如我们不断new String(“Hello”)，其实在java heap里会有多个String的对象，并且值都是Hello，如果我们只希望内存里只保留一个Hello，或者希望我接下来用到的地方都返回同一个Hello，那就可以用String.intern这个方法了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val h1 = <span class="string">"Hello"</span>.intern()</span><br><span class="line">val h2 = h1.intern()</span><br></pre></td></tr></table></figure>
<p>这样 h1 和 h2 都是指向内存里的同一个String对象，那JVM里到底怎么做到的呢？</p>
<p>intern这个方法其实是一个native方法，具体对应到JVM里的逻辑是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">oop StringTable::intern(oop <span class="built_in">string</span>, TRAPS)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> length;</span><br><span class="line">  <span class="function">Handle <span class="title">h_string</span> <span class="params">(THREAD, <span class="built_in">string</span>)</span></span>;</span><br><span class="line">  jchar* chars = java_lang_String::as_unicode_string(<span class="built_in">string</span>, length);</span><br><span class="line">  oop result = intern(h_string, chars, length, CHECK_NULL);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oop StringTable::intern(Handle string_or_null, jchar* name,</span><br><span class="line">                        <span class="keyword">int</span> len, TRAPS) &#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hashValue = hash_string(name, len);</span><br><span class="line">  <span class="keyword">int</span> index = the_table()-&gt;hash_to_index(hashValue);</span><br><span class="line">  oop found_string = the_table()-&gt;lookup(index, name, len, hashValue);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Found</span></span><br><span class="line">  <span class="keyword">if</span> (found_string != <span class="literal">NULL</span>) <span class="keyword">return</span> found_string;</span><br><span class="line"></span><br><span class="line">  debug_only(StableMemoryChecker smc(name, len * <span class="keyword">sizeof</span>(name[<span class="number">0</span>])));</span><br><span class="line">  assert(!Universe::heap()-&gt;is_in_reserved(name) || GC_locker::is_active(),</span><br><span class="line">         <span class="string">"proposed name of symbol must be stable"</span>);</span><br><span class="line"></span><br><span class="line">  Handle <span class="built_in">string</span>;</span><br><span class="line">  <span class="comment">// try to reuse the string if possible</span></span><br><span class="line">  <span class="keyword">if</span> (!string_or_null.is_null() &amp;&amp; (!JavaObjectsInPerm || string_or_null()-&gt;is_perm())) &#123;</span><br><span class="line">    <span class="built_in">string</span> = string_or_null;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">string</span> = java_lang_String::create_tenured_from_unicode(name, len, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Grab the StringTable_lock before getting the_table() because it could</span></span><br><span class="line">  <span class="comment">// change at safepoint.</span></span><br><span class="line">  <span class="function">MutexLocker <span class="title">ml</span><span class="params">(StringTable_lock, THREAD)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, add to symbol to table</span></span><br><span class="line">  <span class="keyword">return</span> the_table()-&gt;basic_add(index, <span class="built_in">string</span>, name, len,</span><br><span class="line">                                hashValue, CHECK_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在JVM里存在一个叫做StringTable的数据结构，这个数据结构是一个Hashtable，在我们调用String.intern的时候其实就是先去这个StringTable里查找是否存在一个同名的项，如果存在就直接返回对应的对象，否则就往这个table里插入一项，指向这个String对象，那么再下次通过intern再来访问同名的String对象的时候，就会返回上次插入的这一项指向的String对象。</p>
<blockquote>
<p>JVM里提供一个参数专门来控制这个table的size，-XX:StringTableSize，既然有这个参数，那么意味着StringTable是size是固定的。</p>
</blockquote>
<p>当发生Hash碰撞的时候，你就要对其对应的桶挨个遍历，超过了100个还是没有找到对应的同名的项，那就会设置一个flag，让下次进入到safepoint的时候做一次rehash动作，尽量减少碰撞的发生，但是当恶化到一定程度的时候，其实也没啥办法啦，因为你的数据量实在太大，桶子数就那么多，那每个桶再怎么均匀也会带着一个很长的链表，所以此时我们通过修改上面的StringTableSize将桶数变大，可能会一定程度上缓解，但是如果是java代码的问题导致泄露，那就只能定位到具体的代码进行改造了。</p>
<blockquote>
<p>在JDK6及之前的版本，字符串常量池是放在Perm Gen（也就是方法区）中。<br>在JDK7版本，字符串常量池被移到了堆中了。至于为什么移到堆内，大概是由于方法区的内存空间太小了。</p>
</blockquote>
<hr>
<h3 id="StringTable为什么会影响YGC"><a href="#StringTable为什么会影响YGC" class="headerlink" title="StringTable为什么会影响YGC"></a>StringTable为什么会影响YGC</h3><p>YGC中对StringTable处理的具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_process_strong_tasks-&gt;is_task_claimed(SH_PS_StringTable_oops_do)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (so &amp; SO_Strings || (!collecting_perm_gen &amp;&amp; !JavaObjectsInPerm)) &#123;</span><br><span class="line">        <span class="comment">//  actually, invoke here</span></span><br><span class="line">        StringTable::oops_do(roots);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (JavaObjectsInPerm) &#123;</span><br><span class="line">      <span class="comment">// Verify the string table contents are in the perm gen</span></span><br><span class="line">      NOT_PRODUCT(StringTable::oops_do(&amp;assert_is_perm_closure));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为YGC过程不涉及到对perm做回收，因此collecting_perm_gen是false，而JavaObjectsInPerm默认情况下也是false，表示String.intern返回的字符串是不是在perm里分配，如果是false，表示是在heap里分配的，因此StringTable指向的字符串是在heap里分配的，所以YGC过程需要对StringTable做扫描，以保证处于新生代的String代码不会被回收掉。</p>
<p>设想一下如果StringTable非常庞大，那是不是意味着YGC过程扫描的时间也会变长呢？这也就是解释了为什么StringTable会影响YGC了，</p>
<p>另外一个问题是StringTable什么时候清理？</p>
<p>YGC过程不会对StringTable做清理，这也就是我们demo里的情况会让Stringtable越来越大，但是在FGC或者CMS GC的过程中会对StringTable进行清理。</p>
<blockquote>
<p>如何证明？命令 jmap -histo:live <pid> 触发FGC</pid></p>
</blockquote>
<hr>
<h3 id="输出SringTable统计信息"><a href="#输出SringTable统计信息" class="headerlink" title="输出SringTable统计信息"></a>输出SringTable统计信息</h3><p>JVM Option：-XX:+PrintStringTableStatistics</p>
<p>Testing Code：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringYGC</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">getUUID</span><span class="params">()</span>: String </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UUID.randomUUID().toString().intern()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val stringYGC = StringYGC()</span><br><span class="line">    val times = <span class="number">10000000</span></span><br><span class="line">    <span class="keyword">for</span> (i in <span class="number">1</span>..times) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == times / <span class="number">2</span>) &#123;</span><br><span class="line">            System.exit(<span class="number">9</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        stringYGC.getUUID()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>GC日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8477K(92160K), 0.0069494 secs] 81920K-&gt;8477K(2086912K), 0.0069858 secs] [Times: user=0.05 sys=0.01, real=0.01 secs]</span><br><span class="line">....</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10238K(92160K), 0.0846080 secs] 611372K-&gt;540071K(2086912K), 0.0846461 secs] [Times: user=0.80 sys=0.02, real=0.09 secs]</span><br></pre></td></tr></table></figure>
<p>SymbolTable statistics：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :     60013 =    480104 bytes, avg   8.000</span><br><span class="line">Number of entries       :   5002671 = 120064104 bytes, avg  24.000</span><br><span class="line">Number of literals      :   5002671 = 560195376 bytes, avg 111.979</span><br><span class="line">Total footprint         :           = 680739584 bytes</span><br><span class="line">Average bucket size     :    83.360</span><br><span class="line">Variance of bucket size :    83.687</span><br><span class="line">Std. dev. of bucket size:     9.148</span><br><span class="line">Maximum bucket size     :       130</span><br></pre></td></tr></table></figure>
<ul>
<li>Average bucket size：bucket中LinkedList的平均size。</li>
<li>Maximum bucket size：表示bucket中LinkedList最大的size。</li>
<li>Number of entries：Hashtable的entry数量。</li>
<li>Number of buckets：bucket数量。 </li>
</ul>
<p>Average bucket size越大，说明Hashtable碰撞越严重，由于bucket数量固定为60013，随着StringTable添加的引用越来越多，碰撞越来越严重，YGC时间越来越长。</p>
<h4 id="Comparing-Testing"><a href="#Comparing-Testing" class="headerlink" title="Comparing Testing"></a>Comparing Testing</h4><p>GC日志：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [ParNew: 81920K-&gt;8819K(92160K), 0.0083969 secs] 81920K-&gt;8819K(2086912K), 0.0084334 secs] [Times: user=0.06 sys=0.00, real=0.01 secs]</span><br><span class="line">...</span><br><span class="line">[GC (Allocation Failure) [ParNew: 92158K-&gt;10238K(92160K), 0.0611064 secs] 609735K-&gt;538845K(2086912K), 0.0611351 secs] [Times: user=0.57 sys=0.01, real=0.06 secs]</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">StringTable statistics:</span><br><span class="line">Number of buckets       :   2500000 =  20000000 bytes, avg   8.000</span><br><span class="line">Number of entries       :   5002673 = 120064152 bytes, avg  24.000</span><br><span class="line">Number of literals      :   5002673 = 560195520 bytes, avg 111.979</span><br><span class="line">Total footprint         :           = 700259672 bytes</span><br><span class="line">Average bucket size     :     2.001</span><br><span class="line">Variance of bucket size :     2.002</span><br><span class="line">Std. dev. of bucket size:     1.415</span><br><span class="line">Maximum bucket size     :        11</span><br></pre></td></tr></table></figure>
<p>对比上面的结果，Average bucket size降低很明显。</p>
<p>设置StringTableSize一个合适的值，即bucket数量为期望的数量后，碰撞的概率明显降低，由Average bucket size和Maximum bucket size的值明显小于未配置StringTableSize参数时的值可知，且YGC时间也明显降低。另外, 最好通过BTrace分析是哪里频繁调用String.intern(), 确实String.intern()没有滥用的前提下, 再增大StringTableSize的值。</p>
<hr>
<h3 id="为什么StringTable不能扩大？"><a href="#为什么StringTable不能扩大？" class="headerlink" title="为什么StringTable不能扩大？"></a>为什么StringTable不能扩大？</h3><p>既然StringTable是Hashtable数据结构，那为什么不能自己通过rehash扩大bucket数量来提高性能呢？JVM中StringTable的rehash有点不一样，JVM中StringTable的rehash不会扩大bucket数量，而是在bucket不变的前提下，通过一个新的seed尝试摊平每个bucket中LinkedList的长度。</p>
<p>rehash大概是一个如下图所示的过程，rehash前后bucket数量不变，这是重点：</p>
<p>假设reash前数据分布(23，4，8，2，1，5)<br><img src="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/refresh_before.png"></p>
<p>假设reash前数据分布(6，8，8，9，5，7)<br><img src="/2019/04/27/Java/JVM/Case/StringTable造成YGC越来越慢/refresh_after.png"></p>
<hr>
<h3 id="Disable-Jackson-String-intern"><a href="#Disable-Jackson-String-intern" class="headerlink" title="Disable Jackson String.intern"></a>Disable Jackson String.intern</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  com.fasterxml.jackson.core.util.InternCache.intern(InternCache.java:45)</span></span><br><span class="line"><span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = input.intern();</span><br><span class="line">    put(result, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>jackson之所以用intern去处理，本来是想节省点cache的内存，没想到业务场景是每次都不一样的字符串，这样直接就导致了String.intern后StringTable的大小暴涨，所以在这种场景中，这样做反而得不偿失，还好jackson代码支持通过接口来把调用intern的部分关掉。</p>
<p><strong>CANONICALIZE_FIELD_NAMES (default: true)</strong></p>
<ul>
<li>Means that once name String is decoded from input (byte or char stream), it will be added in a symbol table, to reduce overhead of decoding same name next time it is seen (by any parser constructed by same factory)</li>
</ul>
<p><strong>INTERN_FIELD_NAMES (default: true)</strong></p>
<ul>
<li>If canonicalization is enabled, this feature determines whether String decoded is also interned (using String.intern()) or not – doing that can help further improve deserialization performance since identity comparison may be used.</li>
<li>If names are unlikely to repeat, or if sheer number of distinct names is huge (in tens of thousands or above), it may make sense to disable this feature.</li>
</ul>
<p>Disable using String.intern() method：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val factory = JsonFactory().disable(JsonFactory.Feature.INTERN_FIELD_NAMES)</span><br><span class="line">val mapper = ObjectMapper(factory).setTimeZone(TimeZone.getDefault())</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote>
<p><a href="http://lovestblog.cn/blog/2016/11/06/string-intern/" target="_blank" rel="noopener">http://lovestblog.cn/blog/2016/11/06/string-intern/</a><br><a href="https://juejin.im/post/5ab99afff265da23a2291dee" target="_blank" rel="noopener">https://juejin.im/post/5ab99afff265da23a2291dee</a><br>Refresh：<a href="https://coolshell.cn/articles/9606.html" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html</a><br><a href="https://www.jianshu.com/p/5524fce8b08f" target="_blank" rel="noopener">https://www.jianshu.com/p/5524fce8b08f</a><br><a href="http://hellojava.info/?p=514" target="_blank" rel="noopener">http://hellojava.info/?p=514</a><br>Jackson触发的String.intern()：<a href="https://www.cnblogs.com/halberts/p/7473857.html" target="_blank" rel="noopener">https://www.cnblogs.com/halberts/p/7473857.html</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/54/">54</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="Jason - sulang357159@163.com">
          
            <p class="site-author-name" itemprop="name">Jason - sulang357159@163.com</p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">536</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">233</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">592</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jason - sulang357159@163.com</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  

  

  

  

</body>
</html>
