<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sulang blog</title>
  
  <subtitle>python java android django web</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulangsss.github.io/"/>
  <updated>2019-01-05T03:43:35.969Z</updated>
  <id>https://sulangsss.github.io/</id>
  
  <author>
    <name>sulang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Resize Metaspace Cause Of Full GC</title>
    <link href="https://sulangsss.github.io/2018/12/28/Java/JVM/Case/ResizeMetaspaceCauseOfFullGC/"/>
    <id>https://sulangsss.github.io/2018/12/28/Java/JVM/Case/ResizeMetaspaceCauseOfFullGC/</id>
    <published>2018-12-28T05:30:22.000Z</published>
    <updated>2019-01-05T03:43:35.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Why-Remove-the-Permanent-Generation-From-Hotspot-JVM"><a href="#Why-Remove-the-Permanent-Generation-From-Hotspot-JVM" class="headerlink" title="Why Remove the Permanent Generation From Hotspot JVM"></a>Why Remove the Permanent Generation From Hotspot JVM</h3><blockquote><p><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">http://openjdk.java.net/jeps/122</a></p></blockquote><p>PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。</p><p>PermGen 被移除，方法区移至 Metaspace，字符串常量移至 Java Heap。</p><ol><li>PermGen 大小是在启动时固定好的，很难进行调优。</li><li><p>由于 PermGen 内存经常会溢出，引发恼人的 java.lang.OutOfMemoryError: PermGen，因此 JVM 的开发者希望这一块内存可以更灵活地被管理，不要再经常出现这样的OOM。</p><blockquote><p>PermGen 为什么会内存溢出？PermGen主要用于存放 Class 和 Meta 的信息，即加载的 Class 会被放入 PermGen space 区域。<br>Pergen和存放Instance的Heap区域不同，所以如果你的APP加载过多 Class 就很可能出现PermGen space错误。例如，在Web服务器对JSP进行pre compile的时候就经常会发生。</p></blockquote></li><li><p>移除 PermGen 可以促进 HotSpot JVM 与 JRockit VM 的融合，因为 JRockit 没有永久代。</p></li></ol><hr><h3 id="What’s-Metaspace"><a href="#What’s-Metaspace" class="headerlink" title="What’s Metaspace"></a>What’s Metaspace</h3><p>In JDK 8, classes metadata is now stored in the native heap and this space is called Metaspace.</p><p>Advantage:</p><ul><li>OOM问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大。</li><li>take advantage of Java Language Specification property : Classes and associated metadata lifetimes match class loader’s</li><li>Linear allocation only</li><li>No individual reclamation (except for RedefineClasses and class loading failure)</li><li>No GC scan or compaction</li><li>No relocation for metaspace objects</li></ul><p>如果Metaspace的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器。根据JDK 8的特性，G1和CMS都会很好地收集Metaspace区(一般都伴随着Full GC)。</p><p>为了减少垃圾回收的频率及时间，控制吞吐量，对Metaspace进行适当的监控和调优是非常有必要的。如果在Metaspace区发生了频繁的Full GC，那么可能表示存在内存泄露或Metaspace区的空间太小了。</p><hr><h3 id="Notice"><a href="#Notice" class="headerlink" title="Notice"></a>Notice</h3><ul><li>默认情况下，Metaspace 容量受限于本地内存(Native Memory)，默认是几乎无穷大，如果 Metaspace 发生内存泄漏，可以把系统内存耗尽。</li><li>MaxMetaspaceSize JVM Option用于限制 Metaspace 本地内存大小，如果没有设置该选项，JVM会根据程序的运行情况，进行动态调整 Metaspace 的大小。</li><li>如果 Metaspace 使用大小达到了 MaxMetaspaceSize，会触发Full GC回收，回收无用的类和类加载器。在完成Full GC后，会增加 Metaspace 的大小，延迟下次Full GC的时间。</li><li>为了控制在 Metaspace 的GC频率，调整 Metaspace 的大小是非常必要的，频繁的在 Metaspace 是类和类加载器发生内存泄漏的征兆，同时也说明你的程序的 Metaspace 大小不合适，需要进行适当地调整。</li><li>JVM的参数 PermSize 和 MaxPermSize 会被忽略并给出警告。</li></ul><hr><h3 id="JVM-Options"><a href="#JVM-Options" class="headerlink" title="JVM Options"></a>JVM Options</h3><ul><li>-XX:MetaspaceSize：初始值。垃圾回收过后，MetaspaceSize可能会扩大。</li><li>-XX:MaxMetaspaceSize：最大值，超过此值就会触发Full GC。此值默认没有限制，取决于系统内存的大小。JVM会动态地改变此值。</li><li>-XX:MinMetaspaceFreeRatio：</li><li>-XX:MaxMetaspaceFreeRatio：</li></ul><hr><h3 id="Analyze-CMS-Case"><a href="#Analyze-CMS-Case" class="headerlink" title="Analyze CMS Case"></a>Analyze CMS Case</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><ol><li><p>每次docker container启动都会触发一次CMS GC，刚开始以为是分配给container的内存太小，后来检查发现分配给contianer的内存为4G，基本排除因为分配内存太小而造成的。</p></li><li><p>每次发布应用后，应用还没有启动完毕就会触发一次CMS GC，此时老年代使用量为0K。</p></li></ol><h4 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Java HotSpot(TM) 64-Bit Server VM (25.65-b01) for linux-amd64 JRE (1.8.0_65-b17), built on Oct  6 2015 17:16:12 by "java_re" with gcc 4.3.0 20080428 (Red Hat 4.3.0-8)</span><br><span class="line">Memory: 4k page, physical 131779324k(4738628k free), swap 0k(0k free)</span><br><span class="line">CommandLine flags: -XX:CMSInitiatingOccupancyFraction=70 -XX:+CMSParallelRemarkEnabled -XX:+DisableExplicitGC -XX:InitialHeapSize=4294967296 -XX:LargePageSizeInBytes=134217728 -XX:MaxHeapSize=4294967296 -XX:MaxNewSize=2684354560 -XX:MaxTenuringThreshold=6 -XX:NewSize=2684354560 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:ThreadStackSize=256 -XX:+UseCMSCompactAtFullCollection -XX:+UseCMSInitiatingOccupancyOnly -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseFastAccessorMethods -XX:+UseParNewGC</span><br><span class="line">2.133: [GC (CMS Initial Mark) [1 CMS-initial-mark: 0K(1572864K)] 796919K(3932160K), 0.0577900 secs] [Times: user=0.08 </span><br><span class="line">//  老年代已经使用为0K，最大可用大小为1572864K</span><br><span class="line">//  Heap已经使用大小796919K，Heap最大可用大小为3932160K</span><br><span class="line">2.191: [CMS-concurrent-mark-start]</span><br><span class="line">2.191: [CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">2.191: [CMS-concurrent-preclean-start]</span><br><span class="line">2.195: [CMS-concurrent-preclean: 0.003/0.003 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br><span class="line">2.195: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">4.144: [GC (GCLocker Initiated GC) 2018-08-20T11:38:38.811+0800: 4.145: [ParNew: 2097152K-&gt;30361K(2359296K), 0.0289636 secs] 0.0296327 secs] [Times: user=0.36 sys=0.11, real=0.03 secs]</span><br><span class="line">//  年轻代变化情况2097152K-&gt;30361K，最大可用为2359296K</span><br><span class="line">5.358: [CMS-concurrent-abortable-preclean: 0.892/3.164 secs] [Times: user=8.26 sys=0.57, real=3.16 secs]</span><br><span class="line">5.359: [GC (CMS Final Remark) [YG occupancy: 1218768 K (2359296 K)]2018-08-20T11:38:40.025+0800: 5.359: [Rescan (parallel) , :38:40.096+0800: 5.429: [weak refs processing, 0.0000365 secs]2018-08-20T11:38:40.096+0800: 5.429: [class unloading, 0.0069690 +0800: 5.436: [scrub symbol table, 0.0036416 secs]5.440: [scrub string table, 0.0006395 secs][1 18768K(3932160K), 0.0839617 secs] [Times: user=1.94 sys=0.01, real=0.08 secs]</span><br><span class="line">5.443: [CMS-concurrent-sweep-start]</span><br><span class="line">5.443: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">5.443: [CMS-concurrent-reset-start]</span><br><span class="line">5.450: [CMS-concurrent-reset: 0.007/0.007 secs] [Times: user=0.02 sys=0.01, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>2.133: [GC (CMS Initial Mark) [1 CMS-initial-mark: 0K(1572864K)] 796919K(3932160K), 0.0577900 secs]，可知老年代已经使用0K，最大可用大小为1572864K，Heap已经使用796919K，Heap最大可用大小为3932160K。</p><p>4.144: [GC (GCLocker Initiated GC) 2018-08-20T11:38:38.811+0800: 4.145: [ParNew: 2097152K-&gt;30361K(2359296K)，可知年轻代变化情况2097152K-&gt;30361K，最大可用为2359296K。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx4g -Xms4g -Xmn2g -XX:PermSize=128m -Xss256k </span><br><span class="line">-XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled </span><br><span class="line">-XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods </span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 </span><br><span class="line">-XX:+PrintGCDetails -XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure><p>注意看JVM参数，-XX:+DisableExplicitGC已经显式禁止程序调用System.gc()进行回收操作，可以排除程序主动触发的GC回收操作。</p><p>如果不是程序触发的GC回收，那就是JVM触发的，JVM在内存不够用的时候才会触发该操作。但是我们在启动的时候已经设置了-XX:PermSize=128m。</p><p>使用命令jstat -gc pid 1000查看，结果如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C         S1C    S0U    S1U      EC       EU        OC         OU         MC     MU    CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">262144.0</span> <span class="number">262144.0</span>  <span class="number">0.0</span>   <span class="number">1601.7</span> <span class="number">2097152.0</span> <span class="number">687465.5</span> <span class="number">1572864.0</span>   <span class="number">522538.5</span>  <span class="number">47724.0</span> <span class="number">46235.0</span> <span class="number">5288.0</span> <span class="number">4900.6</span>   <span class="number">3141</span>   <span class="number">45.946</span>   <span class="number">2</span>      <span class="number">0.142</span>   <span class="number">46.087</span></span><br></pre></td></tr></table></figure><p>MC，MU显示 perm 实际使用大小都不到50MB。再检查JDK版本，实际使用的是JDK 8，对于该版本来说，permSize和maxPermSize已经失效。</p><blockquote><p>MC: Metaspace capacity (kB)，MU: Metacspace utilization (kB).</p></blockquote><table><thead><tr><th>参数</th><th style="text-align:center">含义</th><th style="text-align:right">默认值</th></tr></thead><tbody><tr><td>-XX:MetaspaceSize</td><td style="text-align:center">Metaspace扩容时触发FullGC的初始化阈值，也是最小的阈值</td><td style="text-align:right">依照系统而区别，可以在运行时查看，线上机子大概在20MB</td></tr><tr><td>-XX:MaxMetaspaceSize</td><td style="text-align:center">jdk8 MaxMetaspace上限，配置太小会触发OOM</td><td style="text-align:right">默认是几乎无穷大，如果Metaspace发生内存泄漏，可以把系统内存吃掉</td></tr></tbody></table><p>因为使用的是JDK 8，配置的 XX:PermSize 无效，应用启动之后，meta区很快到达默认值(20MB)，然后触发Full GC，GC完后 Metaspace 被扩容。</p><p>建议解决方案：稳定运行一段时间后通过<strong>jstat -gc pid</strong>确认 Metaspace 的值，一般情况下，设置 128MB 或者 256Mb 即可。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p>Metaspace 之一：Metaspace整体介绍（永久代被替换原因、元空间特点、元空间内存查看分析方法）: <a href="https://www.cnblogs.com/duanxz/p/3520829.html" target="_blank" rel="noopener">https://www.cnblogs.com/duanxz/p/3520829.html</a><br><a href="https://lishoubo.github.io/2018/08/25/%E4%B8%80%E6%AC%A1CMS%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/" target="_blank" rel="noopener">https://lishoubo.github.io/2018/08/25/%E4%B8%80%E6%AC%A1CMS%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/</a><br><a href="https://www.sczyh30.com/posts/Java/jvm-metaspace/" target="_blank" rel="noopener">https://www.sczyh30.com/posts/Java/jvm-metaspace/</a><br>Java 8-从持久代到metaspace: <a href="https://juejin.im/post/59e969ca51882561a05a3340" target="_blank" rel="noopener">https://juejin.im/post/59e969ca51882561a05a3340</a><br>一次CMS问题排除: <a href="https://lishoubo.github.io/2018/08/25/%E4%B8%80%E6%AC%A1CMS%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/" target="_blank" rel="noopener">https://lishoubo.github.io/2018/08/25/%E4%B8%80%E6%AC%A1CMS%E9%97%AE%E9%A2%98%E6%8E%92%E9%99%A4/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Why-Remove-the-Permanent-Generation-From-Hotspot-JVM&quot;&gt;&lt;a href=&quot;#Why-Remove-the-Permanent-Generation-From-Hotspot-JVM&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="CMS" scheme="https://sulangsss.github.io/tags/CMS/"/>
    
  </entry>
  
  <entry>
    <title>Introduction to CMS - Concurrent Mark Sweep Collector</title>
    <link href="https://sulangsss.github.io/2018/12/28/Java/JVM/Basic/CMS/"/>
    <id>https://sulangsss.github.io/2018/12/28/Java/JVM/Basic/CMS/</id>
    <published>2018-12-27T16:10:22.000Z</published>
    <updated>2019-01-05T03:43:38.087Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The Concurrent Mark Sweep Collector (“CMS Collector”) of the HotSpot JVM has one primary goal: <strong>low application pause times</strong>.</p><p>CMS被设计成在大多数时间能与应用程序线程并行执行，仅仅会有一点(短暂的)停顿时间。GC与应用程序并行的缺点是可能会出现各种同步和数据不一致的问题。为了实现安全且正确的并发执行，CMS收集器的GC周期被分为了好几个连续的阶段。</p><h3 id="Theory"><a href="#Theory" class="headerlink" title="Theory"></a>Theory</h3><p>CMS收集器的GC周期由6个阶段组成。其中4个阶段(名字以Concurrent开始的)与实际的应用程序是并发执行的，而其他2个阶段需要暂停应用程序线程。</p><p>CMS收集器的过程：</p><ol><li>初始标记(STW)：为了收集应用程序的对象引用需要暂停应用程序线程，该阶段完成后，应用程序线程再次启动。</li><li>并发标记：从第一阶段收集到的对象引用开始，遍历所有其他的对象引用。</li><li>并发预清理：改变当运行第二阶段时，由应用程序线程产生的对象引用，以更新第二阶段的结果。</li><li>重标记：由于第三阶段是并发的，对象引用可能会发生进一步改变。因此，应用程序线程会再一次被暂停以更新这些变化，并且在进行实际的清理之前确保一个正确的对象引用视图。这一阶段十分重要，因为必须避免收集到仍被引用的对象。</li><li>并发清理(STW)：所有不再被应用的对象将从堆里清除掉。</li><li>并发重置：收集器做一些收尾的工作，以便下一次GC周期能有一个干净的状态。</li></ol><p>一个常见的误解是，CMS收集器运行是完全与应用程序并发的。事实并非如此，即使“stop-the-world”阶段相对于并发阶段的时间很短。</p><p>应该指出，尽管CMS收集器为老年代垃圾回收提供了几乎完全并发的解决方案，然而年轻代仍然通过“stop-the-world”方法来进行收集。对于交互式应用，停顿也是可接受的，背后的原理是年轻带的垃圾回收时间通常是相当短的。</p><p>在使用CMS时候，需要解决两个问题：</p><ul><li><p>堆碎片</p><blockquote><p>CMS收集器并没有任何碎片整理的机制，因此，应用程序有可能出现这样的情形，即使总的堆大小远没有耗尽，但却不能分配对象——仅仅是因为没有足够连续的空间完全容纳对象。</p></blockquote></li><li><p>对象分配率高</p><blockquote><p>如果创建对象实例的频率高于收集器清除堆里死对象的频率，并发算法将失败。从某种程度上说，老年代将没有足够的可用空间来容纳一个从年轻代提升过来的对象。这种情况被称为“并发模式失败”，并且JVM会执行堆碎片整理：触发Full GC。</p></blockquote></li></ul><h3 id="Young-Generation-Garbage-Collection"><a href="#Young-Generation-Garbage-Collection" class="headerlink" title="Young Generation Garbage Collection"></a>Young Generation Garbage Collection</h3><p><strong>为什么调整新生代的参数会对应用的性能如此重要？</strong></p><p>单纯从JVM的功能考虑，并不需要新生代，完全可以针对整个堆进行操作。新生代存在的唯一理由是<strong>优化垃圾回收(GC)的性能</strong>。更具体说，把堆划分为新生代和老年代的好处：</p><ul><li>简化了新对象的分配(只在新生代分配内存)</li><li>可以更有效的清除不再需要的对象(即死对象)(新生代和老年代使用不同的GC算法)</li></ul><p>通过广泛研究面向对象实现的应用，发现一个共同特点：<strong>很多对象的生存时间都很短</strong>。同时研究发现，新生对象很少引用生存时间长的对象。</p><img src="/2018/12/28/Java/JVM/Basic/CMS/eden-survivor.png" title="黄色表示死对象，绿色表示剩余空间，红色表示幸存对象"><p>结合这两个个特点，很明显GC会频繁访问新生对象，例如在堆中一个单独的区域，称之为新生代。在新生代中，GC可以快速标记回收”死对象”，而不需要扫描整个Heap中的存活一段时间的”老对象”。</p><p>HotSpot JVM又把新生代进一步划分为3个区域：一个相对大点的区域，称为”Eden”；两个相对小点的区域称为”From survivor”和”To survivor”。按照规定，新对象会首先分配在Eden中(如果新对象过大，会直接分配在老年代中)。在GC中，Eden中没有被回收的对象会被移动到survivor中，直至对象满足一定的年纪(定义为熬过GC的次数)，会被移动到老年代。</p><p>基于大多数新生对象都会在GC中被收回的假设。新生代的GC使用复制算法。在GC前To survivor保持清空，当前的对象保存在Eden和From survivor中。GC运行时，Eden中的幸存对象被复制到To survivor。复制阶段完成后，Eden 和From survivor中只保存死对象，可以直接回收清空。如果在复制过程中To survivor被填满了，剩余的对象会被复制到老年代中。最后From survivor和 To survivor会调换下名字，在下次GC时，To survivor会变为From survivor。</p><blockquote><p>对于From survivor中的幸存对象，会考虑对象年龄，如果年龄没达到阀值(tenuring threshold，15 GC cycles)，对象会被复制到To survivor。如果达到阀值对象被复制到老年代。</p></blockquote><p>总结一下，对象一般出生在Eden区，年轻代GC过程中，对象在两个survivor之间移动，如果对象存活到适当的年龄，会被移动到老年代。当对象在老年代死亡时，就需要更高级别的GC，更重量级的GC算法(复制算法不适用于老年代，因为没有多余的空间用于复制)</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://blog.codecentric.de/en/2013/10/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2013/10/useful-jvm-flags-part-7-cms-collector/</a><br><a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="noopener">http://ifeve.com/useful-jvm-flags-part-7-cms-collector/</a><br><a href="https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/" target="_blank" rel="noopener">https://blog.codecentric.de/en/2012/08/useful-jvm-flags-part-5-young-generation-garbage-collection/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The Concurrent Mark Sweep Coll
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="CMS" scheme="https://sulangsss.github.io/tags/CMS/"/>
    
  </entry>
  
  <entry>
    <title>Design Pattern 6 Principles</title>
    <link href="https://sulangsss.github.io/2018/12/27/CS/DesignPattern/6%20Principles/"/>
    <id>https://sulangsss.github.io/2018/12/27/CS/DesignPattern/6 Principles/</id>
    <published>2018-12-26T16:28:18.000Z</published>
    <updated>2018-12-26T16:40:29.876Z</updated>
    
    <content type="html"><![CDATA[<h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>对扩展开放，对修改关闭，多使用抽象类和接口</p><h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ol><li>为什么要遵循开闭原则？<blockquote><p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p></blockquote></li></ol><hr><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>基类可以被子类替换，使用抽象类继承，不使用具体类继承</p><hr><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>要依赖于抽象，不要依赖于具体，针对接口编程，不针对实现编程</p><hr><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>使用多个隔离的接口，比使用单个接口好，建立最小的接口</p><hr><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系</p><hr><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>尽量使用合成/聚合，而不是使用继承</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://blog.csdn.net/q291611265/article/details/48465113" target="_blank" rel="noopener">https://blog.csdn.net/q291611265/article/details/48465113</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a&gt;开闭原则&lt;/h3&gt;&lt;p&gt;对扩展开放，对修改关闭，多使用抽象类和接口&lt;/p&gt;
&lt;h4 id=&quot;QA&quot;&gt;&lt;a href=&quot;#QA&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="Design Pattern" scheme="https://sulangsss.github.io/categories/Design-Pattern/"/>
    
    
      <category term="Design Pattern" scheme="https://sulangsss.github.io/tags/Design-Pattern/"/>
    
      <category term="Principles" scheme="https://sulangsss.github.io/tags/Principles/"/>
    
  </entry>
  
  <entry>
    <title>StandardDeviation 标准差</title>
    <link href="https://sulangsss.github.io/2018/12/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%A0%87%E5%87%86%E5%B7%AE/"/>
    <id>https://sulangsss.github.io/2018/12/26/读书笔记/标准差/</id>
    <published>2018-12-26T08:22:22.000Z</published>
    <updated>2018-12-26T08:23:09.743Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>标准差（StandardDeviation），在概率统计中最常使用作为统计分布程度（statisticaldispersion）上的测量。</p><p>标准差定义是总体各单位标准值与其平均数离差平方的算术平均数的平方根。它反映组内个体间的离散程度。测量到分布程度的结果，原则上具有两种性质</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;标准差（StandardDeviation），在概率统计中最
      
    
    </summary>
    
      <category term="读书" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="标准差" scheme="https://sulangsss.github.io/tags/%E6%A0%87%E5%87%86%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>JVM Parameters</title>
    <link href="https://sulangsss.github.io/2018/12/26/Java/JVM/Basic/JVM-Parameter/"/>
    <id>https://sulangsss.github.io/2018/12/26/Java/JVM/Basic/JVM-Parameter/</id>
    <published>2018-12-26T07:31:22.000Z</published>
    <updated>2019-01-05T03:12:38.136Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>HotSpot JVM提供了三类参数：</p><ul><li>第一类包括了标准参数。顾名思义，标准参数中包括功能和输出的参数都是很稳定的，很可能在将来的JVM版本中不会改变。你可以用java命令（或者是用<strong>java -help</strong>）检索出所有标准参数。例如，-server。</li><li>第二类是X参数，非标准化的参数在将来的版本中可能会改变。所有的这类参数都以-X开始，并且可以用<strong>java -X</strong>来检索。注意，不能保证所有参数都可以被检索出来，其中就没有-Xcomp。</li><li>第三类是包含XX参数（到目前为止最多的），它们同样不是标准的。然而，在实际情况中X参数和XX参数并没有什么不同。X参数的功能是十分稳定的，然而很多XX参数仍在实验当中（主要是JVM的开发者用于debugging和调优JVM自身的实现）。<blockquote><p>对于布尔类型的参数，有”+”或”-“，然后才设置JVM选项的实际名称。例如，-XX:+<name>用于激活<name>选项，而-XX:-<name>用于注销选项。<br>对于需要非布尔值的参数，如String或者Integer，我们先写参数的名称，后面加上”=”，最后赋值。例如，-XX:<name>=<value>给<name>赋值<value>。<br>documentation: <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a></value></name></value></name></name></name></name></p></blockquote></li></ul><hr><h3 id="Log-File"><a href="#Log-File" class="headerlink" title="Log File"></a>Log File</h3><ul><li>-XX:+PrintGC：</li><li>-XX:+PrintGCDetails：</li><li>-XX:+PrintGCTimeStamps：<blockquote><p>注意：-XX:+PrintGCTimeStamps该选项打印的是JVM以启动时间为基准的相对时间，对于troubleshooting来说非常困难。使用PrintGCDateStamps代替PrintGCTimeStamps，打印出来的就是真实的日期了。</p></blockquote></li><li>-XX:+PrintGCDateStamps：</li><li>-XX:+PrintGCApplicationStoppedTime：</li><li>-XX:+PrintHeapAtGC：</li><li>-Xloggc:filename：</li></ul><hr><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><ul><li><p>-Xms：初始堆大小，默认值为物理内存的1/64。大小通常被视为堆内存大小的下界。</p><blockquote><p>-XX:InitialHeapSize</p></blockquote></li><li><p>-Xmx：最大堆大小，默认值为物理内存的1/4</p><blockquote><p>-XX:MaxHeapSize</p></blockquote></li><li><p>-XX:+HeapDumpOnOutOfMemoryError：让JVM在发生内存溢出时自动的生成堆内存快照。</p><blockquote><p>默认情况下，堆内存快照会保存在JVM的启动目录下名为java_pid<pid>.hprof的文件里（<pid>是JVM进程的进程号）。可以通过设置-XX:HeapDumpPath=<path>来改变默认的堆内存快照生成路径，<path>可以是相对或者绝对路径。<br>堆内存快照文件有可能很庞大，特别是当内存溢出错误发生的时候。因此，推荐将堆内存快照生成路径指定到一个拥有足够磁盘空间的地方。</path></path></pid></pid></p></blockquote></li><li><p>XX:OnOutOfMemoryError：当内存溢发生时，可以执行一些指令。</p><blockquote><p>当内存溢出错误发生的时候，我们会将堆内存快照写到/tmp/heapdump.hprof 文件并且在JVM的运行目录执行脚本cleanup.sh<br>java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof -XX:OnOutOfMemoryError =”sh ~/cleanup.sh” MyApp</p></blockquote></li><li><p>-XX:NewSize：指定新生代大小</p></li><li>-XX:MaxNewSize：设置该参数时，应该考虑到新生代只是整个堆的一部分，新生代设置的越大，老年代区域就会减少。一般不允许新生代比老年代还大，因为要考虑GC时最坏情况，所有对象都晋升到老年代。最大可以设置为-Xmx/2。</li><li>-XX:NewRatio：设置新生代和老年代的相对大小。这种方式的优点是新生代大小会随着整个堆大小动态扩展。<blockquote><p>例如-XX:NewRatio=3指定老年代/新生代为3/1，老年代占堆大小的3/4，新生代占1/4。</p></blockquote></li><li><p>-XX:SurvivorRatio：指定Eden与survivor大小比例。</p><blockquote><p>例如-XX:SurvivorRatio=10，表示伊Eden是To/From survivor大小的10倍。所以Eden占新生代大小的10/12，To survivor和From survivor各占新生代的1/12。</p></blockquote></li><li><p>-XX:PermSize：</p></li><li><p>-XX:MaxPermSize</p><blockquote><p>请注意，PermSize和MaxPermSize设置的永久代大小并不会被包括在使用参数-XX:MaxHeapSize设置的堆内存大小中。<br>The JDK 8 HotSpot JVM is now using native memory for the representation of class metadata and is called Metaspace.<br>The permanent generation has been removed. The PermSize and MaxPermSize are ignored and a warning is issued if they are present on the command line.<br>Java HotSpot(TM) 64-Bit Server VM warning: ignoring option PermSize/MaxPermSize; support was removed in 8.0<br>Example: -Xmx512m -XX:MaxPermSize=128m -&gt; -Xmx512m</p></blockquote></li><li><p>-XX:InitialCodeCacheSize</p></li><li><p>-XX:ReservedCodeCacheSize</p><blockquote><p>JVM一个有趣的，但往往被忽视的内存区域是“代码缓存”，它是用来存储已编译方法生成的本地代码。代码缓存确实很少引起性能问题，但是一旦发生其影响可能是毁灭性的。如果代码缓存被占满，JVM会打印出一条警告消息，并切换到interpreted-only 模式：JIT编译器被停用，字节码将不再会被编译成机器码。因此，应用程序将继续运行，但运行速度会降低一个数量级，直到有人注意到这个问题。</p></blockquote></li><li><p>-XX:+UseCodeCacheFlushing：当代码缓存被填满时让JVM放弃一些编译代码。</p></li><li>Xss：设置单个线程栈的大小</li></ul><hr><h3 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h3><ul><li>-XX:+UseParallelGC：</li><li>-XX:ParallelGCThreads：</li><li>-XX:MaxGCPauseMillis：</li><li>-XX:+UseAdaptiveSizePolicy：</li><li>-XX:GCTimeRatio：设置垃圾回收时间占程序运行时间的百分比，公式：1/(1+n)</li><li>-XX:+ScavengeBeforeFullGC：Full GC前调用YGC，默认为true</li><li>-XX:+MaxTenuringThreshold：Sets the maximum tenuring threshold for use in adaptive GC sizing.<blockquote><p>Parallel Scavenge中默认值为15，CMS中默认值为6，G1中默认值为15。<br>为什么最大为15？因为对象头信息里面只分配了4bit来保存对象的age信息。<br>这个仅仅表示最大值，因为对象的晋升还与当时Survivor内存大小和存活对象有关，有可能有些对象不需要达到这个阈值就已经晋升到old。</p></blockquote></li></ul><hr><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><ul><li>-XX:+UseConcMarkSweepGC：激活CMS收集器，默认HotSpot JVM使用的是并行收集器。</li><li><p>-XX:+UseParNewGC：当使用CMS收集器时，该标志激活年轻代使用多线程并行执行垃圾回收。</p><blockquote><p>对于CMS收集器，年轻代GC算法和老年代GC算法是不同的，因此年轻代GC有两种不同的实现，并且是两个不同的标志。<br>注意最新的JVM版本，当使用-XX：+UseConcMarkSweepGC时，-XX：UseParNewGC会自动开启。因此，如果年轻代的并行GC不想开启，可以通过设置-XX:-UseParNewGC来关掉。</p></blockquote></li><li><p>-XX:+CMSConcurrentMTEnabled：当该标志被启用时，并发的CMS阶段将以多线程执行(因此，多个GC线程会与所有的应用程序线程并行工作)。</p></li><li><p>-XX:+CMSIncrementalMode：该标志将开启CMS收集器的增量模式。</p><blockquote><p>增量模式经常暂停CMS过程，以便对应用程序线程作出完全的让步。因此，收集器将花更长的时间完成整个收集周期。因此，只有通过测试后发现正常CMS周期对应用程序线程干扰太大时，才应该使用增量模式。由于现代服务器有足够的处理器来适应并发的垃圾收集，所以这种情况发生得很少。</p></blockquote></li><li><p>-XX:ConcGCThreads：定义并发CMS过程运行时的线程数。比如value=4意味着CMS周期的所有阶段都以4个线程来执行。</p><blockquote><p>尽管更多的线程会加快并发CMS过程，但其也会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加CMS线程数是否真的能够带来性能的提升。<br>如果没有设置该标记，JVM会根据并行收集器中的-XX:ParallelGCThreads参数的值来计算出默认的并行CMS线程数。该公式是ConcGCThreads = (ParallelGCThreads + 3)/4。<br>因此，对于CMS收集器，-XX:ParallelGCThreads标志不仅影响“stop-the-world”垃圾收集阶段，还影响并发阶段。</p></blockquote></li><li><p>-XX:+ExplicitGCInvokesConcurrent：前提使用CMS收集器，命令JVM无论什么时候调用系统GC都执行CMS GC，而不是Full GC。</p></li><li>-XX:+DisableExplicitGC：禁止代码显式调用System.gc()。</li><li>-XX:+CMSClassUnloadingEnabled：CMS收集器默认不会对永久代进行垃圾回收。如果希望对永久代进行垃圾回收，可设置该标志。</li><li>-XX:CMSFullGCsBeforeCompaction：多少次后进行内存压缩</li><li>-XX:+CMSParallelRemarkEnabled：降低标记停顿</li><li>-XX+UseCMSCompactAtFullCollection：在FULL GC的时候，对年老代的压缩</li><li>-XX:CMSInitiatingOccupancyFraction=70:使用CMS作为垃圾回收，当使用70％后开始CMS收集</li><li>-XX:+PrintOptoAssembly：由编译器线程生成的本地代码被输出并写到“hotspot.log”文件中。使用这个参数要求运行的服务端VM是debug版本。我们可以研究-XX:+PrintOptoAssembly的输出，以至于了解JVM实际执行什么样的优化。</li></ul><hr><h3 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h3><ul><li>-XX:+PrintCompilation</li><li>-XX:+CITime</li><li>-XX:+LogCompilation</li><li>-XX:+PrintOptoAssembly</li></ul><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -server -XX:+PrintCompilation hello.jar</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">57    1       3       java.lang.String::hashCode (55 bytes)</span><br><span class="line">58    2       3       java.lang.String::length (6 bytes)</span><br><span class="line">58    3       3       java.lang.String::charAt (29 bytes)</span><br><span class="line">59    4       3       java.lang.String::equals (81 bytes)</span><br><span class="line">59    6       3       java.lang.String::indexOf (70 bytes)</span><br><span class="line">59    5       3       java.lang.Object::&lt;init&gt; (1 bytes)</span><br><span class="line">59    7     n 0       java.lang.System::arraycopy (native)   (static)</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p>Java HotSpot VM Options: <a href="https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html</a><br>JVM实用参数（七）CMS收集器: <a href="http://ifeve.com/useful-jvm-flags-part-7-cms-collector/" target="_blank" rel="noopener">http://ifeve.com/useful-jvm-flags-part-7-cms-collector/</a><br>JVM实用参数（四）内存调优: <a href="http://ifeve.com/useful-jvm-flags-part-4-heap-tuning/" target="_blank" rel="noopener">http://ifeve.com/useful-jvm-flags-part-4-heap-tuning/</a><br><a href="http://www.10tiao.com/html/677/201708/2650887093/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/677/201708/2650887093/1.html</a><br><a href="http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">http://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;HotSpot JVM提供了三类参数：&lt;/p&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="Parameters" scheme="https://sulangsss.github.io/tags/Parameters/"/>
    
  </entry>
  
  <entry>
    <title>Testing Web Tools</title>
    <link href="https://sulangsss.github.io/2018/12/26/Testing/Web/TestingWebTools/"/>
    <id>https://sulangsss.github.io/2018/12/26/Testing/Web/TestingWebTools/</id>
    <published>2018-12-26T02:00:18.000Z</published>
    <updated>2019-01-03T10:17:23.325Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Siege"><a href="#Siege" class="headerlink" title="Siege"></a>Siege</h3><p>Siege是Linux下的一个web系统的压力测试工具，支持多链接，支持get和post请求，可以对web系统进行多并发下持续请求的压力测试。</p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><blockquote><p><a href="https://www.cnblogs.com/magicianyin/p/8528952.html" target="_blank" rel="noopener">https://www.cnblogs.com/magicianyin/p/8528952.html</a></p></blockquote><hr><h3 id="wrk"><a href="#wrk" class="headerlink" title="wrk"></a>wrk</h3><p>wrk是一款采用异步并发模型的HTTP基准测试工具：采用异步并发模型，能够发送更大且可控的压力;内置LuaJIT，能够通过lua脚本模拟常见的业务行为，模拟更加真实的场景;相比常见的HTTP基准测试工具，占用更少CPU、更少内存;</p><h4 id="Usage-1"><a href="#Usage-1" class="headerlink" title="Usage"></a>Usage</h4><p>对于POST请求，需要使用lua脚本，测试命令：<strong>wrk -c1 -t1 -d 1s -s ./post.lua url</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wrk.method = <span class="string">"POST"</span></span><br><span class="line">wrk.body   = <span class="string">"&#123;\"type\":\"Limit\",\"symbol\":\"btcusd\",\"clientOrderId\":\"\",\"side\":\"buy\",\"quantity\":\"1\",\"limitPrice\":\"100.0\",\"timeInForce\":\"GoodTillCancel\",\"selfTradePrevention\":\"DecreaseAndCancel\"&#125;"</span></span><br><span class="line">wrk.headers[<span class="string">"Content-Type"</span>] = <span class="string">"application/json"</span></span><br><span class="line">wrk.headers[<span class="string">"Authorization"</span>] = <span class="string">"Bearer "</span></span><br></pre></td></tr></table></figure><ul><li>latency: 延时</li><li>req/sec: 每秒钟处理的请求量</li><li>stdev: 标准差</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Siege&quot;&gt;&lt;a href=&quot;#Siege&quot; class=&quot;headerlink&quot; title=&quot;Siege&quot;&gt;&lt;/a&gt;Siege&lt;/h3&gt;&lt;p&gt;Siege是Linux下的一个web系统的压力测试工具，支持多链接，支持get和post请求，可以对web系统进行多
      
    
    </summary>
    
      <category term="Testing" scheme="https://sulangsss.github.io/categories/Testing/"/>
    
      <category term="Web" scheme="https://sulangsss.github.io/categories/Testing/Web/"/>
    
    
      <category term="Tools" scheme="https://sulangsss.github.io/tags/Tools/"/>
    
      <category term="Testing" scheme="https://sulangsss.github.io/tags/Testing/"/>
    
      <category term="Web" scheme="https://sulangsss.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>MacOS Performance Testing</title>
    <link href="https://sulangsss.github.io/2018/12/26/Mac/Solution/PerformanceTesting/"/>
    <id>https://sulangsss.github.io/2018/12/26/Mac/Solution/PerformanceTesting/</id>
    <published>2018-12-26T01:45:18.000Z</published>
    <updated>2018-12-26T01:47:04.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>打开终端，输入“yes &gt; /dev/null &amp;”，即可创建一项名为“yes”的进程，这种进程会耗费一定量的CPU使用率，你可以再连续输入“yes &gt; /dev/null &amp;”命令，创建更多的“yes”进程，直到CPU使用率达到100%。</p><p>完事后赶快清除“yes”进程哦，输入“killall yes”瞬间搞定！</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://www.waerfa.com/stress-test-a-mac-by-overload-cpu" target="_blank" rel="noopener">https://www.waerfa.com/stress-test-a-mac-by-overload-cpu</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;h4 id=&quot;Solution-1&quot;&gt;&lt;a href=&quot;#Solution-1&quot; class=&quot;headerlink&quot; title=&quot;S
      
    
    </summary>
    
      <category term="MacOS" scheme="https://sulangsss.github.io/categories/MacOS/"/>
    
    
      <category term="MacOS" scheme="https://sulangsss.github.io/tags/MacOS/"/>
    
      <category term="PerformanceTesting" scheme="https://sulangsss.github.io/tags/PerformanceTesting/"/>
    
  </entry>
  
  <entry>
    <title>JWT与Session的作用</title>
    <link href="https://sulangsss.github.io/2018/12/25/DistributedSystem/JWT%E4%B8%8ESession%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://sulangsss.github.io/2018/12/25/DistributedSystem/JWT与Session的作用/</id>
    <published>2018-12-25T04:29:18.000Z</published>
    <updated>2019-01-03T15:58:13.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="What’s-Session"><a href="#What’s-Session" class="headerlink" title="What’s Session"></a>What’s Session</h4><p>In computer science, in particular networking, <strong>a session is a temporary and interactive information interchange(交换)</strong> between two or more communicating devices, or between a computer and user (see login session).</p><p>sessions consist of three phases:</p><ol><li>The client establishes a TCP connection (or the appropriate connection if the transport layer is not TCP).</li><li>The client sends its request, and waits for the answer.</li><li>The server processes the request, sending back its answer, providing a status code and appropriate data.</li></ol><p>As of HTTP/1.1, <strong>the connection is no longer closed after completing the third phase</strong>, and the client is now granted a further request: this means the second and third phases can now be performed any number of times.</p><p><strong>Theory</strong></p><img src="/2018/12/25/DistributedSystem/JWT与Session的作用/session-theory.png"><p>当client通过用户名密码请求server并通过身份认证后，server就会生成身份认证相关的session数据，并且保存在内存或者内存数据库。并将对应的sesssion_id返回给client，client会把保存session_id（可以加密签名下防止篡改在cookie。</p><p>此后client的所有请求都会附带该session_id（毕竟默认会把cookie传给server），以确定server是否存在对应的session数据以及检验登录状态以及拥有什么权限，如果通过校验就该干嘛干嘛，否则重新登录。</p><p>对比JWT的优势：</p><ul><li>最大的优势就在于可以主动清除session了；</li><li>session保存在服务器端，相对较为安全；</li><li>结合cookie使用，较为灵活，兼容性较好；</li></ul><p>劣势：</p><ul><li>cookie + session 在跨域场景表现并不好；</li><li>如果是分布式部署，需要做多机共享session机制，实现方法可将session存储到数据库中或者redis中；</li><li>基于cookie的机制很容易被CSRF；</li><li>查询session信息可能会有数据库查询操作；</li><li>服务之间依赖访问不好处理。每个服务需要有单独的cookies。</li></ul><h4 id="What’s-JWT"><a href="#What’s-JWT" class="headerlink" title="What’s JWT"></a>What’s JWT</h4><p>JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact(契约) and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.</p><p>if the token is sent in the Authorization header, Cross-Origin Resource Sharing (CORS) won’t be an issue as it doesn’t use cookies.</p><p>The following diagram shows how a JWT is obtained and used to access APIs or resources:</p><img src="/2018/12/25/DistributedSystem/JWT与Session的作用/request-jwt-token.png"><ol><li>The application or client requests authorization to the authorization server. This is performed through one of the different authorization flows. For example, a typical OpenID Connect compliant web application will go through the /oauth/authorize endpoint using the authorization code flow.</li><li>When the authorization is granted, the authorization server returns an access token to the application.</li><li>The application uses the access token to access a protected resource (like an API).</li></ol><blockquote><p>using it on HTTP Headers, Authorization: Bearer <token></token></p></blockquote><p>对比Session的优势：</p><ul><li>可扩展性，方便服务进行扩展。</li><li>安全性</li><li>RESTful API 服务</li></ul><p>劣势：</p><ul><li>传输开销比 Session 大，特别是大量数据编码在JWT里面的时候。</li><li>实效性，无状态JWT的实效性相比session太差，只有等到过期才可销毁，而session则可手动销毁。</li></ul><hr><p>JSON Web Token structure:</p><ul><li><p>Header</p><blockquote><p>The header typically consists of two parts: the <strong>type</strong> of the token, which is JWT, and the <strong>signing algorithm</strong> being used, such as HMAC SHA256 or RSA</p></blockquote></li><li><p>Payload</p><blockquote><p>The second part of the token is the payload, which contains the <strong>claims</strong>. Claims are statements about an entity (typically, the user) and additional data. There are three types of claims: registered, public, and private claims.</p></blockquote></li><li><p>Signature</p><blockquote><p>To create the signature part you have to take the encoded header, the encoded payload, a secret, the algorithm specified in the header, and sign that.</p></blockquote></li></ul><hr><h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="当用户注销时，如何使该Token失效"><a href="#当用户注销时，如何使该Token失效" class="headerlink" title="当用户注销时，如何使该Token失效"></a>当用户注销时，如何使该Token失效</h4><p>因为JWT无状态，不保存用户设备信息，没法单纯使用它完成以上问题，因此需要利用数据库保存一些状态完成。</p><ul><li>session: 只需要把user_id对应的token清掉即可</li><li>JWT: 使用Redis，维护一张黑名单，用户注销时加入黑名单(签名)，其中key的过期时间与JWT的过期时间保持一致，确保注销后的Token不能再被使用。</li></ul><hr><h4 id="如何允许用户只能在一个设备登录，如微信"><a href="#如何允许用户只能在一个设备登录，如微信" class="headerlink" title="如何允许用户只能在一个设备登录，如微信"></a>如何允许用户只能在一个设备登录，如微信</h4><ul><li>session: 假设使用MySQL，对用户数据库表添加token字段并加索引，每次登陆重置token字段。每次请求需要权限接口时，根据token查找user_id。</li><li>JWT: 假设使用MySQL，对用户数据库表添加token字段(不需要添加索引)，每次登陆重置token字段。每次请求需要权限接口时，根据JWT获取user_id，根据user_id查用户表获取token判断token是否一致。另外也可以使用计数器的方法。</li></ul><hr><h4 id="如何允许用户只能在最近五个设备登录"><a href="#如何允许用户只能在最近五个设备登录" class="headerlink" title="如何允许用户只能在最近五个设备登录"></a>如何允许用户只能在最近五个设备登录</h4><ul><li>session: 假设使用MySQL，创建token数据库表，有id、token和user_id三个字段，user与token表为1:m关系。每次登录添加一行记录。根据token获取user_id，再根据user_id获取该用户有多少设备登录，超过5个，则删除最小id一行。</li><li>JWT: 假设使用MySQL，使用计数器，在用户表中添加字段count，默认值为0，每次登录count字段自增1，每次登录创建的JWT的Payload中携带数据current_count为用户的count值。每次请求权限接口时，根据JWT获取count以及current_count，根据user_id查用户表获取count，判断与current_count差值是否小于5。</li></ul><hr><h4 id="如何允许用户只能在最近五个设备登录，而且使某一用户踢掉除现有设备外的其它所有设备"><a href="#如何允许用户只能在最近五个设备登录，而且使某一用户踢掉除现有设备外的其它所有设备" class="headerlink" title="如何允许用户只能在最近五个设备登录，而且使某一用户踢掉除现有设备外的其它所有设备"></a>如何允许用户只能在最近五个设备登录，而且使某一用户踢掉除现有设备外的其它所有设备</h4><ul><li>session: 在上一个问题的基础上，删掉该设备以外其它所有的token记录。</li><li>JWT: 在上一个问题的基础上，对count+5，并对该设备重新赋值为新的count。</li></ul><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>从以上问题得知，如果不需要控制登录设备数量以及设备信息，无状态的JWT是一个不错的选择。一旦涉及到了设备信息，就需要对JWT添加额外的状态支持，增加了认证的复杂度，此时选用session是一个不错的选择。JWT不是万能的，是否采用JWT，需要根据业务需求来确定。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p>A typical HTTP session: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Session" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Session</a><br>Session (computer science): <a href="https://en.wikipedia.org/wiki/Session_(computer_science)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Session_(computer_science)</a><br>What is JSON Web Token: <a href="https://jwt.io/introduction/" target="_blank" rel="noopener">https://jwt.io/introduction/</a><br>jwt 实践以及与 session 对比: <a href="https://juejin.im/post/5b532492e51d455d6825c0cc" target="_blank" rel="noopener">https://juejin.im/post/5b532492e51d455d6825c0cc</a><br>聊一聊JWT与session: <a href="https://juejin.im/post/5a437441f265da43294e54c3" target="_blank" rel="noopener">https://juejin.im/post/5a437441f265da43294e54c3</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;What’s-Session&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="Distributed" scheme="https://sulangsss.github.io/categories/Distributed/"/>
    
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/tags/DistributedSystem/"/>
    
      <category term="JWT" scheme="https://sulangsss.github.io/tags/JWT/"/>
    
      <category term="Session" scheme="https://sulangsss.github.io/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>Register And Discover Centra</title>
    <link href="https://sulangsss.github.io/2018/12/24/DistributedSystem/RegisterAndDiscover/"/>
    <id>https://sulangsss.github.io/2018/12/24/DistributedSystem/RegisterAndDiscover/</id>
    <published>2018-12-24T14:22:18.000Z</published>
    <updated>2018-12-27T07:36:06.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>在聊注册与发现中心之前，请先看以下几个问题：</p><ul><li>注册的IP和端口怎么确定？</li><li>实现服务治理还需要注册哪些信息？</li><li>如何进行优雅的服务注册与服务下线？</li><li>注册服务的健康检查是如何做的？</li><li>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知？</li><li>是否方便地查看某个应用发布和订阅了哪些服务，以及所订阅的服务有哪些节点吗？</li></ul><p>看完这些问题后，你也许会发现，对于服务注册与发现，首先应该关注的是服务注册发现本身的功能，然后才是性能和高可用。<strong>一个好的服务注册发现中间件，应该是能完整地满足服务开发和治理的基础功能，然后才是性能和高可用。</strong>如果没有想清楚前面的功能，再高的可用性和性能都是浮云。最后，安全也同样重要。</p><p>在其他方面，我们应该关注什么？</p><ul><li>服务端的性能如何？</li><li>服务发现的容灾策略是怎样的？</li><li>当我的应用和服务发现中心的网络连接出现问题时，会对我的调用产生什么影响？</li><li>服务注册中心某台机器宕机或者全部宕机时，会对我的调用产生什么影响？</li><li>服务注册和发现的链路安全吗，有没有做好权限控制？</li></ul><hr><h3 id="Register-Service"><a href="#Register-Service" class="headerlink" title="Register Service"></a>Register Service</h3><h4 id="如何确定注册的IP和端口"><a href="#如何确定注册的IP和端口" class="headerlink" title="如何确定注册的IP和端口"></a>如何确定注册的IP和端口</h4><ol><li>如何确定IP</li></ol><ul><li>最简单粗暴的方式，手动配置需要注册的IP。当然这种方式基本无法在生产环境使用，因为微服务基本都是支持水平扩容多机部署的，在配置中写死 IP 地址的方式无法支持一份代码水平扩容，会给运维带来极大的成本。</li><li>通过遍历网卡的方式去获取，找到第一个不为本地环回地址的 IP 地址。绝大多数情况下，这个方式比较好用，dubbo等框架采用的就是这种方法。</li><li>在一些网络规划比较好的标准化机房中，我们还可以通过手动指定网卡名，即interfaceName的方式来指定使用哪一块网卡所对应的IP地址进行注册。</li><li>当上述三种方式都不能有效解决问题的时候，有一个方法就是直接与服务注册中心建立socket连接，然后通过socket.getLocalAddress()这种方式来获取本机的IP。</li></ul><hr><ol start="2"><li>如何确定端口</li></ol><ul><li>如果是RPC应用，启动的时候都有一个配置来指定服务监听的端口，注册的时候直接使用配置项的端口值。</li><li>传统的WEB容器所提供的HTTP的应用，同样也存在一个配置文件来配置容器的监听端口，注册时候直接使用配置项的端口值。</li><li>特别的，在Java应用的Spring Boot框架中，可以通过EmbeddedServletContainerInitializedEvent.getEmbeddedServletContainer().getPort()来获取(Spring Boot版本为1.x)。</li></ul><hr><h4 id="实现服务治理还需要注册哪些信息"><a href="#实现服务治理还需要注册哪些信息" class="headerlink" title="实现服务治理还需要注册哪些信息"></a>实现服务治理还需要注册哪些信息</h4><ul><li>最基本的注册信息是IP和Port，可以满足基本的服务调用的需求</li><li>想知道某个HTTP服务是否开启了TLS</li><li>对相同服务下的不同节点设置不同的权重，进行流量调度</li><li>将服务分成预发环境和生产环境，方便进行ABTest功能</li><li>不同机房的服务注册时加上机房的标签，以实现同机房优先的路由规则</li></ul><p>这些高级功能的实现，本质上是依赖于客户端调用时候的负载均衡策略和调用策略，但是如果服务元数据没有注册上来，也只能是巧妇难为无米之炊。一个良好的服务注册中心在设计最初就应该支持这些扩展字段。</p><hr><h4 id="如何进行优雅的服务注册与服务下线"><a href="#如何进行优雅的服务注册与服务下线" class="headerlink" title="如何进行优雅的服务注册与服务下线"></a>如何进行优雅的服务注册与服务下线</h4><ol><li>优雅发布</li></ol><p>虽然服务注册一般发生在服务的启动阶段，但是细分的话，服务注册应该在服务已经完全启动成功，并准备对外提供服务之后才能进行注册。</p><ul><li>有些RPC框架自身提供了方法来判断服务是否已经启动完成，如Thrift，我们可以通过Server.isServing()来判断</li><li>有一些RPC框架本身没有提供服务是否启动完成的方式，这时我们可以通过检测端口是否已经处于监听状态来判断</li><li>对于HTTP服务，服务是否启动完毕也可以通过端口是否处于监听状态来判断<blockquote><p>特别的，在Java应用的Spring Boot框架中，可以通过事件通知的形式来通知容器已经启动完毕，EmbeddedServletContainerInitializedEvent事件来通知容器已经启动完成 (Spring Boot版本为1.x)</p></blockquote></li></ul><hr><ol><li>优雅下线</li></ol><p>绝大多数的服务注册中心都提供了健康检查功能，在应用停止后会自动摘除服务所对应的节点。但是我们也不能完全依赖此功能，应用应该在停止时主动调用服务注册中心的服务下线接口。</p><ul><li>在Java 应用中，通用的服务下线接口调用一般使用JVM Shutdown Hook的方式来实现。</li><li>特别的，在Java应用中的Spring框架中，可以通过Spring Bean LifeCycle来实现应用停止时主动调用服务下线接口。<blockquote><p>当然上述两种方式还不够优雅，因为不能确保不出现kill -9这种粗暴的停止方式，而且应用调用服务下线接口也是尝试去调用，对于网络不通等异常场景并没有做异常处理。因此，调用客户端仍应该做好负载均衡与failover的处理。</p></blockquote></li><li>更优雅的方式，先将即将停止的应用所对应的权重调成0，此时上游将不再调用此应用。这时候的停止应用的操作对服务订阅者完全没有影响，当然这种场景需要订阅者实现按权重的负载均衡和运维部署工具深度结合。</li></ul><hr><h4 id="服务的健康检查是如何做的"><a href="#服务的健康检查是如何做的" class="headerlink" title="服务的健康检查是如何做的"></a>服务的健康检查是如何做的</h4><p>健康检查分为客户端心跳和服务端主动探测两种方式.</p><ol><li>客户端心跳</li></ol><ul><li>客户端每隔一定时间主动发送“心跳”的方式来向服务端表明自己的服务状态正常，心跳可以是TCP的形式，也可以是HTTP的形式。</li><li>也可以通过维持客户端和服务端的一个socket长连接自己实现一个客户端心跳的方式。</li><li>ZooKeeper并没有主动的发送心跳，而是依赖了组件本身提供的临时节点的特性，通过ZooKeeper连接的session来维持临时节点。</li></ul><p>但是客户端心跳中，长连接的维持和客户端的主动心跳都只是表明链路上的正常，不一定是服务状态正常。</p><hr><ol start="2"><li>服务端主动探测</li></ol><ul><li>服务端调用服务发布者某个HTTP接口来完成健康检查。</li><li>对于没有提供HTTP服务的RPC应用，服务端调用服务发布者的接口来完成健康检查。</li><li>可以通过执行某个脚本的形式来进行综合检查。</li></ul><p>服务端主动调用服务进行健康检查是一个较为准确的方式，返回结果成功表明服务状态确实正常。</p><p>但是这种方式也存在一些问题：服务注册中心主动调用RPC服务的某个接口无法做到通用性；在很多场景下服务注册中心到服务发布者的网络是不通的，服务端无法主动发起健康检查。</p><p>所以如何取舍，还是需要根据实际情况来决定，根据不同的场景，选择不同的策略。</p><hr><h3 id="Discover-Service"><a href="#Discover-Service" class="headerlink" title="Discover Service"></a>Discover Service</h3><h4 id="怎么找到服务发现服务端的地址"><a href="#怎么找到服务发现服务端的地址" class="headerlink" title="怎么找到服务发现服务端的地址"></a>怎么找到服务发现服务端的地址</h4><ul><li>在应用的配置文件中指定服务注册中心的地址，类似于zookeeper和eureka。</li><li>指定一个地址服务器的地址，然后通过这个地址服务器来获取服务注册中心的地址，地址服务器返回的结果会随着服务注册中心的扩缩容及时更新。</li></ul><hr><h4 id="当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知"><a href="#当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知" class="headerlink" title="当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知"></a>当服务有节点退出或新的节点加入时，订阅者能不能及时收到通知</h4><p>很经典的Push和Pull问题。Push的经典实现有两种，基于socket长连接的notify，典型的实现如zookeeper；另一种为HTTP连接所使用Long Polling。</p><p>但是基于socket长连接的notify和基于HTTP协议的Long Polling都会存在notify消息丢失的问题。</p><p>所以通过Pull的方式定时轮询也必不可少，时间间隔的选择也很关键，频率越高服务注册中心所承受的压力也越大。需要结合服务端的性能和业务的规模进行权衡。</p><p>还有一种方式，真实的Push，客户端开启一个UDPserver，服务注册中心通过UDP的方式进行数据推送，当然这个也受限于网络的连通性。</p><hr><h4 id="我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗"><a href="#我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗" class="headerlink" title="我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗"></a>我能方便地查看我发布和订阅了哪些服务，订阅的服务有哪些节点吗</h4><p>一个好的产品，用户使用体验和运维体验必须是优雅的，如果查看本机发布和订阅的服务，只能通过查看日志，甚至是jmap的方式来获取，显然体验非常糟糕。</p><p>服务注册中心应该提供了丰富的接口，支持根据应用名、IP、订阅服务名、发布服务名，来进行多层次的组合查询。同时，客户端的内存里，同样也应该保留服务发布与订阅的各种信息，并提供方式供人方便地查询。</p><p>比如在Java中的Spring Boot的应用，可以结合actuator endpoint，通过HTTP的方式来提供本机服务查询功能，查询此应用发布的服务，以及订阅的服务及各服务的对应节点。</p><hr><h3 id="容灾和高可用"><a href="#容灾和高可用" class="headerlink" title="容灾和高可用"></a>容灾和高可用</h3><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>当服务节点数越来越多时，服务注册中心的性能会成为瓶颈，这时候就需要通过水平扩容来提升服务注册中心集群的性能。</p><p>对于那些采用了类Paxos协议的强一致性的组件，如ZooKeeper，由于每次写操作需要过半的节点确认。水平扩容不能提升整个集群的写性能，只能提升整个集群的读性能。而对于采用最终一致性的组件来说，水平扩容可以同时提升整个集群的写性能和读性能。</p><hr><h4 id="客户端容灾策略"><a href="#客户端容灾策略" class="headerlink" title="客户端容灾策略"></a>客户端容灾策略</h4><ul><li>首先，本地内存缓存，当运行时与服务注册中心的连接丢失或服务注册中心完全宕机，仍能正常地调用服务。</li><li>然后，本地缓存文件，当应用与服务注册中心发生网络分区或服务注册中心完全宕机后，应用进行了重启操作，内存里没有数据，此时应用可以通过读取本地缓存文件的数据来获取到最后一次订阅到的内容。</li><li>最后，本地容灾文件夹。正常的情况下，容灾文件夹内是没有内容的。当服务端完全宕机且长时间不能恢复，同时服务提供者又发生了很大的变更时，可以通过在容灾文件夹内添加文件的方式来开启本地容灾。此时客户端会忽略原有的本地缓存文件，只从本地容灾文件中读取配置。</li></ul><hr><h4 id="服务端容灾与高可用"><a href="#服务端容灾与高可用" class="headerlink" title="服务端容灾与高可用"></a>服务端容灾与高可用</h4><ul><li>当有新节点加入集群时，节点启动后能自动添加到地址服务器中，并通过地址服务器找到其他节点，自动从其他节点同步数据，以达到数据的最终一致性。</li><li>当某个节点宕机时，此服务注册中心节点的信息会自动地址服务器中摘除，客户端能及时感知到此节点已下线。</li></ul><p>服务端的无状态性保证了服务的容灾和高可用可以做的很薄。</p><hr><h3 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h3><p>链路安全，对于使用HTTP连接的服务注册中心，保护链路安全的最好方式是使用HTTPS。而使用TCP连接的服务注册中心来说，由于应用层协议一般使用的是私有协议，不一定存在现成的TLS支持方案。</p><p>在业务安全方面，应该在每一次的发布、订阅、心跳，都带上鉴权的信息就行验签和鉴权，确保业务信息的安全性。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/" target="_blank" rel="noopener">http://jm.taobao.org/2018/06/26/%E8%81%8A%E8%81%8A%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%8E%E5%8F%91%E7%8E%B0/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;在聊注册与发现中心之前，请先看以下几个问题：&lt;/p&gt;
&lt;ul
      
    
    </summary>
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/categories/DistributedSystem/"/>
    
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/tags/DistributedSystem/"/>
    
      <category term="Register" scheme="https://sulangsss.github.io/tags/Register/"/>
    
      <category term="Discover" scheme="https://sulangsss.github.io/tags/Discover/"/>
    
      <category term="Centra" scheme="https://sulangsss.github.io/tags/Centra/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Controller Session</title>
    <link href="https://sulangsss.github.io/2018/12/24/Java/SpringBoot/Session/Controller-Session/"/>
    <id>https://sulangsss.github.io/2018/12/24/Java/SpringBoot/Session/Controller-Session/</id>
    <published>2018-12-24T11:00:22.000Z</published>
    <updated>2018-12-24T11:05:53.387Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"/hello"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">home</span><span class="params">(HttpSession session)</span> </span>&#123;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Custom-Session"><a href="#Custom-Session" class="headerlink" title="Custom Session"></a>Custom Session</h3><blockquote><p><a href="https://stackoverflow.com/questions/48353967/how-to-modify-or-custom-sessionid-in-spring-session-project" target="_blank" rel="noopener">https://stackoverflow.com/questions/48353967/how-to-modify-or-custom-sessionid-in-spring-session-project</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="SpringBoot" scheme="https://sulangsss.github.io/categories/Java/SpringBoot/"/>
    
      <category term="Session" scheme="https://sulangsss.github.io/categories/Java/SpringBoot/Session/"/>
    
    
      <category term="Session" scheme="https://sulangsss.github.io/tags/Session/"/>
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="SpringBoot" scheme="https://sulangsss.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>HTTP Nonce</title>
    <link href="https://sulangsss.github.io/2018/12/24/Network/Nonce/"/>
    <id>https://sulangsss.github.io/2018/12/24/Network/Nonce/</id>
    <published>2018-12-24T10:28:19.000Z</published>
    <updated>2018-12-24T10:54:58.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Why-need-it"><a href="#Why-need-it" class="headerlink" title="Why need it?"></a>Why need it?</h4><p>All requests must contain a <strong>nonce</strong>, a number that will never be repeated and must increase between requests. </p><p>This is to <strong>prevent an attacker who has captured a previous request from simply replaying that request</strong>. We recommend using a timestamp at millisecond or higher precision. The nonce need only be increasing with respect to the session that the message is on.</p><blockquote><p>A single account may have multiple API keys provisioned. In this document, we’ll refer to these as “sessions”. All orders will be recorded with the session that created them. The nonce associated with a request needs to be increasing with respect to the session that the nonce is used on.This allows multithreaded or distributed trading systems to place orders independently of each other, without needing to synchronize clocks to avoid race conditions.<br>In addition, some operations (such as Cancel All Session Orders) act on the orders associated with a specific session.<br>简单来说，每个session关联一个nonce，nonce必须递增。在应用程序里面，一个Thread对应一个Session，多Thread对应多个Session，进而确保nonce是递增不重复的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;Why-need-it&quot;&gt;&lt;a href=&quot;#Wh
      
    
    </summary>
    
      <category term="Network" scheme="https://sulangsss.github.io/categories/Network/"/>
    
    
      <category term="HTTP" scheme="https://sulangsss.github.io/tags/HTTP/"/>
    
      <category term="Network" scheme="https://sulangsss.github.io/tags/Network/"/>
    
      <category term="Nonce" scheme="https://sulangsss.github.io/tags/Nonce/"/>
    
  </entry>
  
  <entry>
    <title>Maven Multiple Module Management</title>
    <link href="https://sulangsss.github.io/2018/12/24/Java/Maven/Module/"/>
    <id>https://sulangsss.github.io/2018/12/24/Java/Maven/Module/</id>
    <published>2018-12-24T08:01:22.000Z</published>
    <updated>2019-01-02T12:09:19.786Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><ol><li>Parent pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.anda.library<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>common<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>network<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- Gloable Dependencies --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- declare dependencies --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- declare dependencies version --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.esotericsoftware<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kryo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Network Module pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.anda.library.network<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>network<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- Network Module dependent on Common Module --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.anda.library.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Common Module pom.xml</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.anda.library.common<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>common<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Parent pom.xml&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight x
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Maven" scheme="https://sulangsss.github.io/categories/Java/Maven/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Maven" scheme="https://sulangsss.github.io/tags/Maven/"/>
    
      <category term="Module" scheme="https://sulangsss.github.io/tags/Module/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP Model</title>
    <link href="https://sulangsss.github.io/2018/12/23/Network/TCP-IP-Model/"/>
    <id>https://sulangsss.github.io/2018/12/23/Network/TCP-IP-Model/</id>
    <published>2018-12-23T04:12:19.000Z</published>
    <updated>2018-12-23T04:12:59.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/33797520" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33797520</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhi
      
    
    </summary>
    
      <category term="Network" scheme="https://sulangsss.github.io/categories/Network/"/>
    
    
      <category term="Network" scheme="https://sulangsss.github.io/tags/Network/"/>
    
      <category term="TCP/IP" scheme="https://sulangsss.github.io/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Markdown Syntax</title>
    <link href="https://sulangsss.github.io/2018/12/23/Markdown/Markdown-Syntax/"/>
    <id>https://sulangsss.github.io/2018/12/23/Markdown/Markdown-Syntax/</id>
    <published>2018-12-23T03:08:18.000Z</published>
    <updated>2018-12-23T03:16:28.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>First ordered list item</span><br><span class="line"><span class="bullet">2. </span>Another item</span><br><span class="line">⋅⋅* Unordered sub-list. </span><br><span class="line"><span class="bullet">1. </span>Actual numbers don't matter, just that it's a number</span><br><span class="line">⋅⋅1. Ordered sub-list</span><br><span class="line"><span class="bullet">4. </span>And another item.</span><br><span class="line"></span><br><span class="line">⋅⋅⋅You can have properly indented paragraphs within list items. Notice the blank line above, and the leading spaces (at least one, but we'll use three here to also align the raw Markdown).</span><br><span class="line"></span><br><span class="line">⋅⋅⋅To have a line break without a paragraph, you will need to use two trailing spaces.⋅⋅</span><br><span class="line">⋅⋅⋅Note that this line is separate, but within the same paragraph.⋅⋅</span><br><span class="line">⋅⋅⋅(This is contrary to the typical GFM line break behaviour, where trailing spaces are not required.)</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>Unordered list can use asterisks</span><br><span class="line"><span class="bullet">- </span>Or minuses</span><br><span class="line"><span class="bullet">+ </span>Or pluses</span><br></pre></td></tr></table></figure><img src="/2018/12/23/Markdown/Markdown-Syntax/lists-1.png"><h3 id="Links"><a href="#Links" class="headerlink" title="Links"></a>Links</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">I'm an inline-style link</span>](<span class="link">https://www.google.com</span>)</span><br><span class="line"></span><br><span class="line">Or leave it empty and use the [link text itself].</span><br><span class="line">[<span class="symbol">link text itself</span>]: <span class="link">http://www.reddit.com</span></span><br></pre></td></tr></table></figure><hr><h3 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Colons can be used to align columns.</span><br><span class="line"></span><br><span class="line">| Tables        | Are           | Cool  |</span><br><span class="line">| ------------- |:-------------:| -----:|</span><br><span class="line">| col 3 is      | right-aligned | $1600 |</span><br><span class="line">| col 2 is      | centered      |   $12 |</span><br><span class="line">| zebra stripes | are neat      |    $1 |</span><br><span class="line"></span><br><span class="line">There must be at least 3 dashes separating each header cell.</span><br><span class="line">The outer pipes (|) are optional, and you don't need to make the </span><br><span class="line">raw Markdown line up prettily. You can also use inline Markdown.</span><br><span class="line"></span><br><span class="line">Markdown | Less | Pretty</span><br><span class="line">--- | --- | ---</span><br><span class="line"><span class="emphasis">*Still*</span> | <span class="code">`renders`</span> | <span class="strong">**nicely**</span></span><br><span class="line">1 | 2 | 3</span><br></pre></td></tr></table></figure><img src="/2018/12/23/Markdown/Markdown-Syntax/tables-1.png"><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="noopener">https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lists&quot;&gt;&lt;a href=&quot;#Lists&quot; class=&quot;headerlink&quot; title=&quot;Lists&quot;&gt;&lt;/a&gt;Lists&lt;/h3&gt;&lt;figure class=&quot;highlight markdown&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="Markdown" scheme="https://sulangsss.github.io/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="https://sulangsss.github.io/tags/Markdown/"/>
    
      <category term="Syntax" scheme="https://sulangsss.github.io/tags/Syntax/"/>
    
  </entry>
  
  <entry>
    <title>JVM CMS Phases</title>
    <link href="https://sulangsss.github.io/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/"/>
    <id>https://sulangsss.github.io/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/</id>
    <published>2018-12-22T09:20:22.000Z</published>
    <updated>2019-01-05T03:43:33.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>CMS：Concurrent Mark and Sweep，Mostly Concurrent Mark and Sweep Garbage Collector。</p><p>设计目标：年老代收集的时候避免长时间的暂停；</p><ul><li>年轻代：采用 stop-the-world mark-copy 算法；</li><li>年老代：采用 Mostly Concurrent mark-sweep 算法；</li></ul><p>能够达成该目标主要因为以下两个原因：</p><ol><li>它不会花时间整理压缩年老代，而是维护了一个叫做 free-lists 的数据结构，该数据结构用来管理那些回收再利用的内存空间；</li><li>mark-sweep分为多个阶段，其中一大部分阶段GC的工作是和Application threads的工作同时进行的（当然，gc线程会和用户线程竞争CPU的时间），默认的GC的工作线程为你服务器物理CPU核数的1/4；</li></ol><p>当你的服务器是多核同时你的目标是低延时，那该GC的搭配则是你的不二选择。</p><p>JVM测试参数如下标记：</p><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/intro.jpg"><h3 id="Analyze"><a href="#Analyze" class="headerlink" title="Analyze"></a>Analyze</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T02:23:07.219-0200: 64.322: [GC (Allocation Failure) 64.322: </span><br><span class="line">[ParNew: 613404K-&gt;68068K(613440K), 0.1020465 secs] </span><br><span class="line">10885349K-&gt;10880154K(12514816K), 0.1021309 secs] </span><br><span class="line">[Times: user=0.78 sys=0.01, real=0.11 secs]</span><br></pre></td></tr></table></figure><ul><li>2016-08-23T02:23:07.219-0200：GC发生的时间</li><li>64.322：GC开始，相对JVM启动的相对时间，单位是秒</li><li>GC：区别MinorGC和FullGC的标识，这次代表的是MinorGC</li><li>Allocation Failure：MinorGC的原因，在这个case里边，由于年轻代不满足申请的空间，因此触发了MinorGC</li><li>ParNew：收集器的名称，它预示了年轻代使用一个并行的 mark-copy stop-the-world 垃圾收集器</li><li>613404K-&gt;68068K：收集前后年轻代的使用情况</li><li>(613440K)：整个年轻代的容量</li><li>0.1020465 secs：Duration for the collection w/o final cleanup.</li><li>10885349K-&gt;10880154K：收集前后整个堆的使用情况</li><li>(12514816K)：整个堆的容量</li><li>0.1021309 secs：ParNew收集器标记和复制年轻代活着的对象所花费的时间（包括和老年代通信的开销、对象晋升到老年代时间、垃圾收集周期结束一些最后的清理对象等的开销）</li><li>[Times: user=0.78 sys=0.01, real=0.11 secs]：GC事件在不同维度的耗时</li><li><ul><li>user：Total CPU time that was consumed by Garbage Collector threads during this collection</li></ul></li><li><ul><li>sys：Time spent in OS calls or waiting for system event</li></ul></li><li><ul><li>real：Clock time for which your application was stopped. With Parallel GC this number should be close to (user time + system time) divided by the number of threads used by the Garbage Collector. In this particular case 8 threads were used. Note that due to some activities not being parallelizable, it always exceeds the ratio by a certain amount.</li></ul></li></ul><hr><h4 id="年轻代对象-晋升-gt-老年对象"><a href="#年轻代对象-晋升-gt-老年对象" class="headerlink" title="年轻代对象 -晋升-&gt; 老年对象"></a>年轻代对象 -晋升-&gt; 老年对象</h4><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/eden-to-old.jpg"><p>开始的时候：整个堆的大小是10885349K，年轻代大小是613404K，这说明老年代大小是10885349-613404=10271945K</p><p>收集完成之后：整个堆的大小是10880154K，年轻代大小是68068K，这说明老年代大小是10880154-68068=10812086K</p><p>老年代的大小增加了：10812086-10271945=608209K，也就是说年轻代对象晋升到年老代对象的大小为608209K的数据</p><hr><h4 id="Full-Major-GC"><a href="#Full-Major-GC" class="headerlink" title="Full/Major GC"></a>Full/Major GC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T11:23:07.321-0200: 64.425: [GC (CMS Initial Mark)1 [1 CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">2016-08-23T11:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]</span><br><span class="line">2016-08-23T11:23:07.357-0200: 64.460: [CMS-concurrent-mark2: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]</span><br><span class="line">2016-08-23T11:23:07.357-0200: 64.460: [CMS-concurrent-preclean-start]</span><br><span class="line">2016-08-23T11:23:07.373-0200: 64.476: [CMS-concurrent-preclean3: 0.016/0.016 secs] [Times: user=0.02 sys=0.00, real=0.02 secs]</span><br><span class="line">2016-08-23T11:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">2016-08-23T11:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean4: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]</span><br><span class="line">2016-08-23T11:23:08.447-0200: 65.550: [GC (CMS Final Remark5)</span><br><span class="line">[YG occupancy: 387920 K (613440 K)]65.550: [Rescan (parallel) , 0.0085125 secs]65.559: </span><br><span class="line">[weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: </span><br><span class="line">[scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] </span><br><span class="line">[Times: user=0.06 sys=0.00, real=0.01 secs]</span><br><span class="line">2016-08-23T11:23:08.458-0200: 65.561: [CMS-concurrent-sweep-start]</span><br><span class="line">2016-08-23T11:23:08.485-0200: 65.588: [CMS-concurrent-sweep6: 0.027/0.027 secs] [Times: user=0.03 sys=0.00, real=0.03 secs]</span><br><span class="line">2016-08-23T11:23:08.485-0200: 65.589: [CMS-concurrent-reset-start]</span><br><span class="line">2016-08-23T11:23:08.497-0200: 65.601: [CMS-concurrent-reset7: 0.012/0.012 secs] [Times: user=0.01 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><hr><p><strong>Phase 1: Initial Mark</strong></p><p>这是CMS中两次stop-the-world事件中的一次。它有两个目标：</p><ol><li>标记老年代中所有的GC Roots；</li><li>标记被年轻代中活着的对象引用的对象。</li></ol><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/initial-mark.jpg"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T11:23:07.321-0200: 64.425: [GC (CMS Initial Mark)1 [1 CMS-initial-mark: 10812086K(11901376K)] 10887844K(12514816K), 0.0001997 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><ul><li>CMS Initial Mark：收集阶段，开始收集所有的GC Roots和直接引用到的对象</li><li>10812086K：当前老年代使用情况</li><li>(11901376K)：老年代可用容量</li><li>10887844K：当前整个堆的使用情况</li><li>(12514816K)：整个堆的容量</li></ul><hr><p><strong>Phase 2: Concurrent Mark</strong></p><p>这个阶段会遍历整个老年代并且标记所有存活的对象，从“初始化标记”阶段找到的GC Roots开始。并发标记的特点是和应用程序线程同时运行。并不是老年代的所有存活对象都会被标记，因为标记的同时应用程序会改变一些对象的引用等。</p><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/concurrent-mark.jpg"><p>在上边的图中，一个引用的箭头已经远离了当前对象（current obj）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T11:23:07.321-0200: 64.425: [CMS-concurrent-mark-start]</span><br><span class="line">2016-08-23T11:23:07.357-0200: 64.460: [CMS-concurrent-mark2: 0.035/0.035 secs] [Times: user=0.07 sys=0.00, real=0.03 secs]</span><br></pre></td></tr></table></figure><ul><li>0.035/0.035 secs：展示该阶段持续的时间和时钟时间</li></ul><hr><p><strong>Phase 3: Concurrent Preclean</strong></p><p>这个阶段又是一个并发阶段，和应用线程并行运行，不会中断应用线程。</p><p>前一个阶段在并行运行的时候，一些对象的引用已经发生了变化，当这些引用发生变化的时候，JVM会标记堆的这个区域为Dirty Card(包含被标记但是改变了的对象，被认为”dirty”)，这就是Card Marking。</p><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/concurrent-preclean.jpg"><p>在pre-clean阶段，那些能够从dirty card对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了，如下：</p><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/concurrent-preclean-after.jpg"><p>另外，一些必要的清扫工作也会做，还会做一些final remark阶段需要的准备工作；</p><hr><p><strong>Phase 4: Concurrent Abortable Preclean</strong></p><p>又一个并发阶段不会停止应用程序线程。这个阶段尝试着去承担STW的Final Remark阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生aboart的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T11:23:07.373-0200: 64.476: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">2016-08-23T11:23:08.446-0200: 65.550: [CMS-concurrent-abortable-preclean4: 0.167/1.074 secs] [Times: user=0.20 sys=0.00, real=1.07 secs]</span><br></pre></td></tr></table></figure><p>这个阶段很大程度的影响着即将来临的Final Remark的停顿，有相当一部分重要的configuration options和失败的模式；</p><hr><p><strong>Phase 5: Final Remark</strong></p><p>这个阶段是CMS中第二个并且是最后一个STW的阶段。该阶段的任务是完成标记整个年老代的所有的存活对象。由于之前的预处理是并发的，它可能跟不上应用程序改变的速度，这个时候，STW是非常需要的来完成这个严酷考验的阶段。</p><p>通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候，目的是消除紧接着的连续的几个STW阶段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2016-08-23T11:23:08.447-0200: 65.550: [GC (CMS Final Remark5)</span><br><span class="line">[YG occupancy: 387920 K (613440 K)]65.550: [Rescan (parallel) , 0.0085125 secs]65.559: </span><br><span class="line">[weak refs processing, 0.0000243 secs]65.559: [class unloading, 0.0013120 secs]65.560: </span><br><span class="line">[scrub symbol table, 0.0008345 secs]65.561: [scrub string table, 0.0001759 secs][1 CMS-remark: 10812086K(11901376K)] 11200006K(12514816K), 0.0110730 secs] </span><br><span class="line">[Times: user=0.06 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><ul><li>weak refs processing, 0.0000243 secs：第一个子阶段，随着这个阶段的进行处理弱引用</li><li>class unloading, 0.0013120 secs]65.560：第二个子阶段(that is unloading the unused classes, with the duration and timestamp of the phase)</li><li>scrub string table, 0.0001759 secs：最后一个子阶段（that is cleaning up symbol and string tables which hold class-level metadata and internalized string respectively）</li><li>10812086K(11901376K)：在这个阶段之后老年代占有的内存大小和老年代的容量</li><li>11200006K(12514816K)：在这个阶段之后整个堆的内存大小和整个堆的容量</li><li>0.0110730 secs：这个阶段的持续时间</li></ul><p>通过以上5个阶段的标记，老年代所有存活的对象已经被标记并且现在要通过Garbage Collector采用清扫的方式回收那些不能用的对象了。</p><hr><p><strong>Phase 6: Concurrent Sweep</strong></p><p>和应用线程同时进行，不需要STW。这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。</p><img src="/2018/12/22/Java/JVM/Basic/CMS-Collection-Phase/concurrent-sweep.jpg"><hr><p><strong>Phase 7: Concurrent Reset</strong></p><p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p><h3 id="Other-GC-log"><a href="#Other-GC-log" class="headerlink" title="Other GC log"></a>Other GC log</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;Heap before GC invocations=537 (full 5):</span><br><span class="line"> def new generation   total 76032K, used 68480K [0x00000000e2200000, 0x00000000e7470000, 0x00000000ec150000)</span><br><span class="line">  eden space 67648K, 100% used [0x00000000e2200000, 0x00000000e6410000, 0x00000000e6410000)</span><br><span class="line">  from space 8384K,   9% used [0x00000000e6c40000, 0x00000000e6d101c8, 0x00000000e7470000)</span><br><span class="line">  to   space 8384K,   0% used [0x00000000e6410000, 0x00000000e6410000, 0x00000000e6c40000)</span><br><span class="line"> tenured generation   total 168760K, used 120244K [0x00000000ec150000, 0x00000000f661e000, 0x0000000100000000)</span><br><span class="line">   the space 168760K,  71% used [0x00000000ec150000, 0x00000000f36bd1e0, 0x00000000f36bd200, 0x00000000f661e000)</span><br><span class="line"> Metaspace       used 57113K, capacity 59188K, committed 59520K, reserved 1101824K</span><br><span class="line">  class space    used 7298K, capacity 7692K, committed 7808K, reserved 1048576K</span><br><span class="line">856.767: [GC (Allocation Failure) 856.767: [DefNew: 68480K-&gt;935K(76032K), 0.0079443 secs] 188724K-&gt;121180K(244792K), 0.0080136 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line"></span><br><span class="line">Heap after GC invocations=538 (full 5):</span><br><span class="line"> def new generation   total 76032K, used 935K [0x00000000e2200000, 0x00000000e7470000, 0x00000000ec150000)</span><br><span class="line">  eden space 67648K,   0% used [0x00000000e2200000, 0x00000000e2200000, 0x00000000e6410000)</span><br><span class="line">  from space 8384K,  11% used [0x00000000e6410000, 0x00000000e64f9df8, 0x00000000e6c40000)</span><br><span class="line">  to   space 8384K,   0% used [0x00000000e6c40000, 0x00000000e6c40000, 0x00000000e7470000)</span><br><span class="line"> tenured generation   total 168760K, used 120245K [0x00000000ec150000, 0x00000000f661e000, 0x0000000100000000)</span><br><span class="line">   the space 168760K,  71% used [0x00000000ec150000, 0x00000000f36bd5f0, 0x00000000f36bd600, 0x00000000f661e000)</span><br><span class="line"> Metaspace       used 57113K, capacity 59188K, committed 59520K, reserved 1101824K</span><br><span class="line">  class space    used 7298K, capacity 7692K, committed 7808K, reserved 1048576K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://www.cnblogs.com/zhangxiaoguang/p/5792468.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxiaoguang/p/5792468.html</a><br><a href="https://plumbr.io/handbook/what-is-garbage-collection" target="_blank" rel="noopener">https://plumbr.io/handbook/what-is-garbage-collection</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;CMS：Concurrent Mark and Sweep，
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="CMS Phases" scheme="https://sulangsss.github.io/tags/CMS-Phases/"/>
    
  </entry>
  
  <entry>
    <title>JVM Minor GC vs Major GC vs Full GC</title>
    <link href="https://sulangsss.github.io/2018/12/22/Java/JVM/Basic/Minor%20GC%20vs%20Major%20GC%20vs%20Full%20GC/"/>
    <id>https://sulangsss.github.io/2018/12/22/Java/JVM/Basic/Minor GC vs Major GC vs Full GC/</id>
    <published>2018-12-22T08:00:22.000Z</published>
    <updated>2018-12-22T08:54:16.174Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The post expects the reader to be familiar with generic garbage collection principles built into the JVM. Division of Heap into Eden, Survivor and Tenured/Old spaces, generational hypothesis(假设) and different GC algorithms are beyond the scope of this post.</p><img src="/2018/12/22/Java/JVM/Basic/Minor%20GC%20vs%20Major%20GC%20vs%20Full%20GC/jvm-generational.jpg"><hr><h3 id="Minor-GC"><a href="#Minor-GC" class="headerlink" title="Minor GC"></a>Minor GC</h3><p>Collecting garbage from Young space (consisting of <strong>Eden</strong> and <strong>Survivor</strong> spaces) is called a Minor GC. </p><p>This definition is both clear(清晰的) and uniformly(统一的) understood. But there are still some interesting take-aways you should be aware of when dealing with Minor Garbage Collection events:</p><ul><li><p>Minor GC is always triggered when JVM is unable to allocate space for a new Object, e.g. the Eden is getting full. So the higher the allocation rate, the more frequently Minor GC is executed.</p></li><li><p>Whenever the pool is filled, its entire content is copied and the pointer can start tracking the free memory from zero again. So instead of(而不是…) classical(传统的) Mark, Sweep and Compact, cleaning Eden and Survivor spaces is carried out with Mark and Copy instead. So, no fragmentation(内存碎片) actually takes place inside Eden or Survivor spaces. The write pointer is always residing on the top of the used pool.</p></li><li><p>During a Minor GC event, Tenured generation is effectively ignored. References from tenured generation to young generation are considered de facto GC roots. References from young generation to Tenured generation are simply ignored during the markup phase.</p></li><li><p>Against common belief, <strong>all Minor GCs do trigger stop-the-world pauses, stopping the application threads</strong>. For most of the applications, the length of the pauses is negligible(微不足道的) latency-wise. This is true if most of the objects in Eden can be considered garbage and are never copied to Survivor/Old spaces. If the opposite is true and most of the newborn objects are not eligible for GC, Minor GC pauses start taking considerably more time.</p></li></ul><blockquote><p>Minor GC并不意味着不会STW，只是Minor GC会比Full GC开销小。</p></blockquote><hr><h3 id="Major-GC-vs-Full-GC"><a href="#Major-GC-vs-Full-GC" class="headerlink" title="Major GC vs Full GC"></a>Major GC vs Full GC</h3><ul><li>Major GC is cleaning the Tenured space.</li><li>Full GC is cleaning the entire Heap – both Young and Tenured spaces.</li></ul><p>This leads us to the point where instead of worrying whether the GC is called Major or Full GC, you should focus to finding out whether the GC at hand stopped all the application threads or was it able to progress concurrently with the application threads.</p><p>This confusion is even built right into the JVM standard tools. What I mean by that is best explained via an example. Lets compare the output of two different tools tracing the GC on a JVM running with <strong>Concurrent Mark</strong> and <strong>Sweep collector</strong> (-XX:+UseConcMarkSweepGC)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -gc -t 4235 1s</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Time    S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC       MU    CCSC   CCSU     YGC     YGCT    FGC    FGCT     GCT   </span><br><span class="line"> 5.7 34048.0 34048.0  0.0   34048.0 272640.0 194699.7 1756416.0   181419.9  18304.0 17865.1 2688.0 2497.6      3    0.275   0      0.000    0.275</span><br><span class="line"> 6.7 34048.0 34048.0 34048.0  0.0   272640.0 247555.4 1756416.0   263447.9  18816.0 18123.3 2688.0 2523.1      4    0.359   0      0.000    0.359</span><br><span class="line"> 7.7 34048.0 34048.0  0.0   34048.0 272640.0 257729.3 1756416.0   345109.8  19072.0 18396.6 2688.0 2550.3      5    0.451   0      0.000    0.451</span><br><span class="line"> 8.7 34048.0 34048.0 34048.0 34048.0 272640.0 272640.0 1756416.0  444982.5  19456.0 18681.3 2816.0 2575.8      7    0.550   0      0.000    0.550</span><br><span class="line"> 9.7 34048.0 34048.0 34046.7  0.0   272640.0 16777.0  1756416.0   587906.3  20096.0 19235.1 2944.0 2631.8      8    0.720   0      0.000    0.720</span><br><span class="line">10.7 34048.0 34048.0  0.0   34046.2 272640.0 80171.6  1756416.0   664913.4  20352.0 19495.9 2944.0 2657.4      9    0.810   0      0.000    0.810</span><br><span class="line">11.7 34048.0 34048.0 34048.0  0.0   272640.0 129480.8 1756416.0   745100.2  20608.0 19704.5 2944.0 2678.4     10    0.896   0      0.000    0.896</span><br><span class="line">12.7 34048.0 34048.0  0.0   34046.6 272640.0 164070.7 1756416.0   822073.7  20992.0 19937.1 3072.0 2702.8     11    0.978   0      0.000    0.978</span><br><span class="line"><span class="comment"># Focus</span></span><br><span class="line">13.7 34048.0 34048.0 34048.0  0.0   272640.0 211949.9 1756416.0   897364.4  21248.0 20179.6 3072.0 2728.1     12    1.087   1      0.004    1.091</span><br><span class="line">14.7 34048.0 34048.0  0.0   34047.1 272640.0 245801.5 1756416.0   597362.6  21504.0 20390.6 3072.0 2750.3     13    1.183   2      0.050    1.233</span><br><span class="line"><span class="comment"># Focus</span></span><br><span class="line">15.7 34048.0 34048.0  0.0   34048.0 272640.0 21474.1  1756416.0   757347.0  22012.0 20792.0 3200.0 2791.0     15    1.336   2      0.050    1.386</span><br><span class="line">16.7 34048.0 34048.0 34047.0  0.0   272640.0 48378.0  1756416.0   838594.4  22268.0 21003.5 3200.0 2813.2     16    1.433   2      0.050    1.484</span><br></pre></td></tr></table></figure><p>This snippet is extracted from the first 17 seconds after the JVM was launched. </p><p>Based on this information we could conclude that after 12 Minor GC runs two Full GC runs were performed, spanning 50ms in total. You would get the same confirmation via GUI-based tools, such as the jconsole or jvisualvm.</p><p>lets look at to the output of the garbage collection logs gathered from the same JVM launch. Apparently -XX:+PrintGCDetails tells us a different and more detailed story:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintGCDetails -XX:+UseConcMarkSweepGC eu.plumbr.demo.GarbageProducer</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">3.157: [GC (Allocation Failure) 3.157: [ParNew: 272640K-&gt;34048K(306688K), 0.0844702 secs] 272640K-&gt;69574K(2063104K), 0.0845560 secs] [Times: user=0.23 sys=0.03, real=0.09 secs] </span><br><span class="line">4.092: [GC (Allocation Failure) 4.092: [ParNew: 306688K-&gt;34048K(306688K), 0.1013723 secs] 342214K-&gt;136584K(2063104K), 0.1014307 secs] [Times: user=0.25 sys=0.05, real=0.10 secs] </span><br><span class="line">... cut <span class="keyword">for</span> brevity ...</span><br><span class="line">11.292: [GC (Allocation Failure) 11.292: [ParNew: 306686K-&gt;34048K(306688K), 0.0857219 secs] 971599K-&gt;779148K(2063104K), 0.0857875 secs] [Times: user=0.26 sys=0.04, real=0.09 secs] </span><br><span class="line">12.140: [GC (Allocation Failure) 12.140: [ParNew: 306688K-&gt;34046K(306688K), 0.0821774 secs] 1051788K-&gt;856120K(2063104K), 0.0822400 secs] [Times: user=0.25 sys=0.03, real=0.08 secs] </span><br><span class="line">12.989: [GC (Allocation Failure) 12.989: [ParNew: 306686K-&gt;34048K(306688K), 0.1086667 secs] 1128760K-&gt;931412K(2063104K), 0.1087416 secs] [Times: user=0.24 sys=0.04, real=0.11 secs] </span><br><span class="line"><span class="comment"># Focus CMS Initial Mark 0.0041705 secs</span></span><br><span class="line">13.098: [GC (CMS Initial Mark) [1 CMS-initial-mark: 897364K(1756416K)] 936667K(2063104K), 0.0041705 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] </span><br><span class="line">13.102: [CMS-concurrent-mark-start]</span><br><span class="line">13.341: [CMS-concurrent-mark: 0.238/0.238 secs] [Times: user=0.36 sys=0.01, real=0.24 secs] </span><br><span class="line">13.341: [CMS-concurrent-preclean-start]</span><br><span class="line">13.350: [CMS-concurrent-preclean: 0.009/0.009 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] </span><br><span class="line">13.350: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line">13.878: [GC (Allocation Failure) 13.878: [ParNew: 306688K-&gt;34047K(306688K), 0.0960456 secs] 1204052K-&gt;1010638K(2063104K), 0.0961542 secs] [Times: user=0.29 sys=0.04, real=0.09 secs] </span><br><span class="line">14.366: [CMS-concurrent-abortable-preclean: 0.917/1.016 secs] [Times: user=2.22 sys=0.07, real=1.01 secs] </span><br><span class="line"><span class="comment"># Focus CMS Final Remark 0.0462010 secs</span></span><br><span class="line">14.366: [GC (CMS Final Remark) [YG occupancy: 182593 K (306688 K)]14.366: [Rescan (parallel) , 0.0291598 secs]14.395: [weak refs processing, 0.0000232 secs]14.395: [class unloading, 0.0117661 secs]14.407: [scrub symbol table, 0.0015323 secs]14.409: [scrub string table, 0.0003221 secs][1 CMS-remark: 976591K(1756416K)] 1159184K(2063104K), 0.0462010 secs] [Times: user=0.14 sys=0.00, real=0.05 secs] </span><br><span class="line">14.412: [CMS-concurrent-sweep-start]</span><br><span class="line">14.633: [CMS-concurrent-sweep: 0.221/0.221 secs] [Times: user=0.37 sys=0.00, real=0.22 secs] </span><br><span class="line">14.633: [CMS-concurrent-reset-start]</span><br><span class="line">14.636: [CMS-concurrent-reset: 0.002/0.002 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br></pre></td></tr></table></figure><p>Based on this information we can see that indeed after 12 Minor GC runs “something different” started happening. But instead two Full GC runs, this “different thing” was in reality just a single GC running in Tenured generation consisting of different phases:</p><ul><li>Initial Mark phase, spanning for 0.0041705 seconds or approximately 4ms. This phase is a stop-the-world event stopping all application threads for initial marking.</li><li>Concurrenty executed Markup and Preclean phases. These are run concurrently with the application threads</li><li>Final Remark phase, spanning for 0.0462010 seconds or approximately 46ms. This phase is again stop-the-world event.</li><li>Concurrently executed Sweep operation. As the name states, this phase is also carried out concurrently without stopping the application threads.</li></ul><p>So what we see from the actual garbage collection logs is that – instead(而不是) two Full GC operations, just one Major GC cleaning Old space was actually executed.</p><img src="/2018/12/22/Java/JVM/Basic/Minor%20GC%20vs%20Major%20GC%20vs%20Full%20GC/cms-gc-event.png"><h3 id="Pertaining-Terms"><a href="#Pertaining-Terms" class="headerlink" title="Pertaining Terms"></a>Pertaining Terms</h3><ul><li>S0C：年轻代中第一个survivor（幸存区）的容量 (kb)</li><li>S1C：年轻代中第二个survivor（幸存区）的容量 (kb)</li><li>S0U：年轻代中第一个survivor（幸存区）目前已使用空间 (kb)</li><li>S1U：年轻代中第二个survivor（幸存区）目前已使用空间 (kb)</li><li>EC：年轻代中Eden（伊甸园）的容量 (kb)</li><li>EU：年轻代中Eden（伊甸园）目前已使用空间 (kb)</li><li>OC：Old代的容量 (kb)</li><li>OU：Old代目前已使用空间 (kb)</li><li>PC：Perm(持久代)的容量 (kb)</li><li>PU：Perm(持久代)目前已使用空间 (kb)</li><li><strong>YGC：从应用程序启动到采样时年轻代中gc次数</strong></li><li><strong>YGCT：从应用程序启动到采样时年轻代中gc所用时间(s)</strong></li><li><strong>FGC：从应用程序启动到采样时old代(全gc)gc次数</strong></li><li><strong>FGCT：从应用程序启动到采样时old代(全gc)gc所用时间(s)</strong></li><li><strong>GCT：从应用程序启动到采样时gc用的总时间(s)</strong></li><li>NGCMN：年轻代(young)中初始化(最小)的大小 (kb)</li><li>NGCMX：年轻代(young)的最大容量 (kb)</li><li>NGC：年轻代(young)中当前的容量 (kb)</li><li>OGCMN：old代中初始化(最小)的大小 (kb)</li><li>OGCMX：old代的最大容量 (kb)</li><li>OGC：old代当前新生成的容量 (kb)</li><li>PGCMN：perm代中初始化(最小)的大小 (kb)</li><li>PGCMX：perm代的最大容量 (kb)</li><li>PGC：perm代当前新生成的容量 (kb)</li><li>S0：年轻代中第一个survivor（幸存区）已使用的占当前容量百分比</li><li>S1：年轻代中第二个survivor（幸存区）已使用的占当前容量百分比</li><li>E：年轻代中Eden（伊甸园）已使用的占当前容量百分比</li><li>O：old代已使用的占当前容量百分比</li><li>P：perm代已使用的占当前容量百分比</li><li>S0CMX：年轻代中第一个survivor（幸存区）的最大容量 (kb)</li><li>S1CMX ：年轻代中第二个survivor（幸存区）的最大容量 (kb)</li><li>ECMX：年轻代中Eden（伊甸园）的最大容量 (kb)</li><li>DSS：当前需要survivor（幸存区）的容量 (kb)（Eden区已满）</li><li>TT：持有次数限制</li><li>MTT ：最大持有次数限制</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc" target="_blank" rel="noopener">https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc</a><br><a href="https://www.cnblogs.com/zhangxiaoguang/p/5792468.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangxiaoguang/p/5792468.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The post expects the reader to
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>黄宗羲定律</title>
    <link href="https://sulangsss.github.io/2018/12/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%BB%84%E5%AE%97%E7%BE%B2%E5%AE%9A%E5%BE%8B/"/>
    <id>https://sulangsss.github.io/2018/12/22/读书笔记/黄宗羲定律/</id>
    <published>2018-12-22T05:10:07.000Z</published>
    <updated>2018-12-22T09:50:47.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>所谓黄宗羲定律是由秦晖先生依据黄宗羲的观点而总结出来的某种历史规律：<strong>历史上的税费改革不止一次，但每次税费改革后，由于当时社会政治环境的局限性，农民负担在下降一段时间后又涨到一个比改革前更高的水平。</strong>明清思想家黄宗羲称之为“积累莫返之害”。</p><hr><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>黄宗羲定律谈的主要是赋税问题，说起来很复杂，但核心的观点就一个：税越改革越多。</p><p>税赋只是表象，分权才是根本，而中央和地方有限争权又是中央集权制的必然。</p><p>古代税赋分为杂税（包括贪腐）和正税，前者重，后者轻。正税归中央，杂税归地方，杂税属于地方搭车，中央默认的状态。税赋改革无非是把杂税并入正税，也归中央，这时赋税会降低。此时即便地方没有任何贪腐现象，纯为维持庶政考虑，也必须重新征收杂税，然后本来已经并入正税的名目，在新的杂税中又重复征收，加上贪腐的反弹，税赋自然更重。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://www.zhihu.com/question/22796484" target="_blank" rel="noopener">https://www.zhihu.com/question/22796484</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;所谓黄宗羲定律是由秦晖先生依据黄宗羲的观点而总结出来的某种历
      
    
    </summary>
    
      <category term="Note" scheme="https://sulangsss.github.io/categories/Note/"/>
    
    
      <category term="笔记" scheme="https://sulangsss.github.io/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="黄宗羲定律" scheme="https://sulangsss.github.io/tags/%E9%BB%84%E5%AE%97%E7%BE%B2%E5%AE%9A%E5%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>JVM Quick Start</title>
    <link href="https://sulangsss.github.io/2018/12/21/Java/JVM/Basic/Quick-Start/"/>
    <id>https://sulangsss.github.io/2018/12/21/Java/JVM/Basic/Quick-Start/</id>
    <published>2018-12-21T08:31:22.000Z</published>
    <updated>2018-12-27T07:20:05.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JVM-Running-Time"><a href="#JVM-Running-Time" class="headerlink" title="JVM Running Time"></a>JVM Running Time</h3><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/jvm-running-time.png"><p>线程共享区域：</p><ul><li>Java对象实例存放在Heap中</li><li>常量存放在方法区的常量</li><li>池虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区</li></ul><p>线程独享区域：</p><ul><li>栈是线程私有的，存放该方法的局部变量表 (基本类型、对象引用)、操作数栈、动态链接、方法出口等信息。</li></ul><p>一个Java程序对应一个JVM，一个方法（线程）对应一个Java栈。</p><h4 id="Heap"><a href="#Heap" class="headerlink" title="Heap"></a>Heap</h4><ul><li>被所有线程共享的一块内存区域，在虚拟机启动时创建</li><li>用来存储对象实例</li><li>可以通过-Xmx和-Xms控制堆的大小</li><li>OutOfMemoryError：当在堆中没有内存完成实例分配，且堆也无法再扩展时</li></ul><p>Heap是垃圾收集器管理的主要区域。</p><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/head-structure.png"><ul><li><p>新生代(New/Young)：新建的对象都由新生代分配内存。</p><blockquote><p>常常又被划分为Eden区和Survivor区。Eden空间不足时会把存活的对象转移到Survivor。<br>新生代的大小可由-Xmn控制，也可用-XX:SurvivorRatio控制Eden和Survivor的比例。</p></blockquote></li><li><p>旧生代/年老代(Old/Tenured)：存放经过多次垃圾回收仍然存活的对象。</p><blockquote><p>持久代（Permanent）在方法区，不属于Heap。<br>持久代：存放静态文件，如今Java类、方法等。持久代在方法区，对垃圾回收没有显著影响。</p></blockquote></li></ul><hr><h4 id="Direct-Memory"><a href="#Direct-Memory" class="headerlink" title="Direct Memory"></a>Direct Memory</h4><p>特点：</p><ul><li>直接内存并不是虚拟机运行的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用</li><li>NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作</li><li>大小不受Java堆大小的限制，受本机 (服务器) 内存限制</li></ul><hr><h3 id="Compile-and-Running"><a href="#Compile-and-Running" class="headerlink" title="Compile and Running"></a>Compile and Running</h3><p>Java 代码的编译和执行包括了三个重要机制：</p><ol><li>Java源码编译机制（.java 源代码文件 -&gt; .class 字节码文件）</li><li>类加载机制（ClassLoader）</li><li>类执行机制（JVM 执行引擎）</li></ol><h4 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h4><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/compile-java.png"><p>Java源代码是不能被机器识别的，需要先经过编译器编译成JVM可以执行的.class 字节码文件，再由解释器解释运行。</p><blockquote><p>Java 源文件（.java） –&gt; Java 编译器 –&gt; Java 字节码文件 （.class） –&gt; Java 解释器 –&gt; 执行</p></blockquote><ul><li>字节码文件（.class）是平台无关的</li><li>Java中字符只以一种形式存在：Unicode，字符转换发生在JVM和OS交界处（Reader/Writer）</li><li>class文件组成：结构信息，元数据和方法信息<blockquote><p>结构信息：包括class文件格式版本号及各部分的数量与大小的信息<br>元数据：对应于Java源码中声明与常量的信息。包含类/继承的超类/实现的接口的声明信息、域与方法声明信息和常量池<br>方法信息：对应Java源码中语句和表达式对应的信息。包含字节码、异常处理器表、求值栈与局部变量区大小、求值栈的类型记录、调试符号信息</p></blockquote></li></ul><hr><h4 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h4><p>Java程序并不一个可执行文件，是由多个独立的类文件组成。这些类文件并非一次性全部装入内存，而是依据程序逐步载入。</p><p>JVM的类加载是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序可以由下图来描述：</p><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/class-loading.png"><ul><li>Bootstrap ClassLoader<blockquote><p>JVM的根ClassLoader，由C++实现<br>JVM启动时即初始化此ClassLoader<br>加载rt.jar，它包含了Java规范定义的所有接口以及实现</p></blockquote></li></ul><blockquote><p>The VM implements the bootstrap class loader, which loads classes from the BOOTPATH, including for example rt.jar. For faster startup, the VM can also process preloaded classes via Class Data Sharing.<br>Class Data Sharing：Class data sharing (CDS) is a feature introduced in J2SE 5.0 that is intended to reduce the startup time for Java programming language applications, in particular smaller applications, as well as reduce footprint. When the JRE is installed on 32-bit platforms using the Sun provided installer, <strong>the installer loads a set of classes from the system jar file into a private internal representation, and dumps that representation to a file, called a “shared archive”.</strong></p></blockquote><ul><li><p>Extension ClassLoader</p><blockquote><p>加载Java扩展 API（lib/ext 中的类）</p></blockquote></li><li><p>App ClassLoader</p><blockquote><p>加载Classpath目录下定义的class</p></blockquote></li><li><p>Custom ClassLoader</p><blockquote><p>属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据J2EE规范自行实现ClassLoader</p></blockquote></li></ul><p>加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。</p><p>QA:</p><ol><li>什么是双亲委派机制？<br>JVM在加载类时默认采用的是双亲委派机制。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归。如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。</li></ol><p>作用：</p><ul><li>避免重复加载。</li><li>更安全。如果没有双亲委派，那么用户可用在自己的classpath编写了一个java.lang.Object的类，那就无法保证Object的唯一性。</li></ul><hr><h4 id="类执行机制"><a href="#类执行机制" class="headerlink" title="类执行机制"></a>类执行机制</h4><p>Java字节码的执行是由JVM执行引擎来完成，流程图如下所示：</p><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/class-execute.png"><p>JVM是基于栈的体系结构来执行class字节码的。当线程创建后，都会产生程序计数器（PC）和栈（Stack）。</p><ul><li>程序计数器存放下一条要执行的指令在方法内的偏移量。</li><li>栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量区和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。</li></ul><p>涉及的技术点：</p><ul><li>解释属于第一代JVM</li><li>即时编译JIT属于第二代JVM</li><li>自适应优化（目前 Sun 的 HotspotJVM 采用这种技术）则吸取第一代JVM和第二代JVM的经验，采用两者结合的方式（开始时，对所有的代码都采取解释执行的方式，并监视代码执行情况。对那些经常调用的方法启动一个后台线程，将其编译为本地代码，并进行优化。若方法不再频繁使用，则取消编译过的代码，仍对其进行解释执行）。</li></ul><h4 id="VM-Class-Loading"><a href="#VM-Class-Loading" class="headerlink" title="VM Class Loading"></a>VM Class Loading</h4><p>The VM is responsible for resolving constant pool symbols, which requires loading, linking and then initializing classes and interfaces. </p><p>We will use the term <strong>“class loading”</strong> to describe the overall(全部的) process of mapping a class or interface name to a class object, and the more specific terms loading, linking and initializing for the phases of class loading as defined by the JVMS(Java Virtual Machine Specification(说明,规范)).</p><p><strong>The most common reason for class loading is during bytecode resolution</strong>, when a constant pool symbol in the classfile requires resolution. Java APIs such as Class.forName(), classLoader.loadClass(), reflection APIs, and JNI_FindClass can initiate class loading. </p><p>The VM itself can initiate class loading. The VM loads core classes such as java.lang.Object, java.lang.Thread, etc. at JVM startup. Loading a class requires loading all superclasses and superinterfaces. And classfile verification, which is part of the linking phase, can require loading additional classes.</p><p>The VM and Java SE class loading libraries share the responsibility for class loading. The VM performs constant pool resolution, linking and initialization for classes and interfaces. The loading phase is a cooperative(协同的,合作的) effort between the VM and specific class loaders (java.lang.classLoader).</p><h4 id="Class-Loading-Phases"><a href="#Class-Loading-Phases" class="headerlink" title="Class Loading Phases"></a>Class Loading Phases</h4><p>The load class phase(阶段) <strong>takes</strong> a class or interface name, <strong>finds</strong> the binary in classfile format, <strong>defines</strong> the class and <strong>creates</strong> the java.lang.Class object. </p><blockquote><p>keyword: take，find，define，create</p></blockquote><p>The load class phase can throw a <strong>NoClassDefFound</strong> error if a binary representation can not be found. In addition, the load class phase does format checking on the syntax of the classfile, which can throw a <strong>ClassFormatError</strong> or <strong>UnsupportedClassVersionError</strong>. Prior to completing loading of a class, the VM must load all of its superclasses and superinterfaces. If the class hierarchy has a problem such that this class is its own superclass or superinterface (recursively), then the VM will throw a <strong>ClassCircularityError</strong>. The VM also throws <strong>IncompatibleClassChangeError</strong> if the direct superinterface is not an interface, or the direct superclass is an interface.</p><p>The link class phase first does <strong>verification</strong>, which checks the classfile semantics(语义), checks the constant pool symbols and does type checking. These checks can throw a <strong>VerifyError</strong>. Linking then does preparation, which creates and initializes static fields to standard defaults and allocates method tables. Note that no Java code has yet been run. Linking then optionally does resolution of symbolic references.</p><blockquote><p>keyword: Linking，verification，preparation</p></blockquote><p>Class initialization runs the static initializers, and initializers for static fields. This is the first Java code which runs for this class. Note that class initialization requires superclass initialization, although(尽管) not superinterface initialization.</p><blockquote><p>keyword: static fields</p></blockquote><p>The JVMS specifies that class initialization occurs on the first <strong>“active use”</strong> of a class. The JLS allows flexibility in when the symbolic resolution step of linking occurs as long as we respect the semantics of the language, finish each step of loading, linking and initializing before performing the next step, and throw errors when programs would expect them. </p><p><strong>For performance, the HotSpot VM generally waits until class initialization to load and link a class.</strong> So if class A references class B, loading class A will not necessarily cause loading of class B (unless required for verification). Execution of the first instruction that references B will cause initialization of B, which requires loading and linking of class B.</p><h4 id="Class-Loader-Delegation"><a href="#Class-Loader-Delegation" class="headerlink" title="Class Loader Delegation"></a>Class Loader Delegation</h4><p><strong>When a class loader is asked to find and load a class, it can ask another class loader to do the actual loading. This is called class loader delegation.</strong> </p><p>The first loader is an initiating loader, and the class loading that ultimately defines the class is called the defining loader. In the case of bytecode resolution, the initiating loader is the class loader for the class whose constant pool symbol we are resolving.</p><p>Class loaders are defined hierarchically and each class loader has a delegation parent. The delegation defines a search order for binary class representations. </p><p>The Java SE class loader hierarchy searches the <strong>bootstrap</strong> class loader, the <strong>extension</strong> class loader and the <strong>system</strong> class loader in that order.</p><p>The system class loader is the default application class loader, which runs “main” and loads classes from the classpath. The application class loader can be a class loader from the Java SE class loader libraries, or it can be provided by an application developer. </p><p>The Java SE class loader libraries implement the extension class loader which loads classes from the lib/ext directory of the JRE.</p><hr><h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h4><p>GC将内存中<strong>不再被引用的对象</strong>进行回收。</p><p>由于GC需要消耗一些资源和时间，Java在对对象的生命周期特征进行分析后，按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停。</p><ul><li>对新生代的对象的收集称为Minor GC；</li><li>对旧生代的对象的收集称为Full GC；</li><li>程序中主动调用System.gc()的GC为Full GC。</li></ul><p>Java垃圾回收是单独的后台线程GC执行的，自动运行无需显示调用。即使主动调用了java.lang.System.gc()，该方法也只会提醒系统进行垃圾回收，但系统不一定会回应，可能会不予理睬。</p><h4 id="Memory-Leak"><a href="#Memory-Leak" class="headerlink" title="Memory Leak"></a>Memory Leak</h4><p>一直持有不再使用对象的引用，造成对象不能被GC回收，无法释放内存空间。</p><p>满足这两个条件即可判定为内存泄漏：</p><ul><li>对象是可达的</li><li>对象是无用的</li></ul><p>常见原因：</p><ul><li>全局集合</li><li>缓存</li><li>ClassLoader</li></ul><h4 id="Optimize-GC"><a href="#Optimize-GC" class="headerlink" title="Optimize GC"></a>Optimize GC</h4><p>Direction：</p><ul><li>减少GC的频率尤其是Full GC的次数，过多的GC会占用很多系统资源影响吞吐量。特别要关注Full GC，因为它会对整个堆进行整理</li><li>优化JVM的参数，提高垃圾回收的速度，合理分配堆内存各部分的比例</li></ul><p>The reason for triggering Full GC:</p><ul><li><p>旧生代空间不足</p><blockquote><p>尽量让对象在新生代被GC回收、不要创建过大的对象及数组避免直接在旧生代创建对象。</p></blockquote></li><li><p>持久代（Pemanet Generation）空间不足</p><blockquote><p>增大Perm Gen空间和避免太多静态对象。</p></blockquote></li><li><p>System.gc()被显示调用</p><blockquote><p>垃圾回收不要手动触发，尽量依靠JVM自身的机制。</p></blockquote></li><li><p>从新生代晋升到旧生代的对象所需内存空间，大于旧生代剩余可用内存空间</p><blockquote><p>控制好新生代和旧生代的比例，避免新生代晋升到旧生代时，旧生代内存不够用，进而触发Full GC回收内存。</p></blockquote></li></ul><hr><p>QA：</p><ol><li><p>堆内存比例不良设置会导致什么后果?</p><blockquote><p>新生代设置过小：新生代GC次数非常频繁，增大系统消耗；二是导致大对象直接进入旧生代，占据了旧生代剩余空间。<br>新生代设置过大：是新生代设置过大会导致旧生代过小（堆总量一定），从而容易触发Full GC；新生代GC耗时大幅度增加，一般说来新生代占整个堆1/3比较合适。<br>Survivor设置过小：导致对象从Eden直接到达旧生代，降低了在新生代的存活时间。<br>Survivor设置过大：导致Eden过小，增加了GC频率。可用通过-XX:MaxTenuringThreshold=n来控制新生代存活时间，尽量让对象在新生代被回收。</p></blockquote></li><li><p>JVM可选的GC策略有哪些？</p><blockquote><p>吞吐量优先：自行选择相应的GC策略及控制新生代与旧生代的大小比例，来达到吞吐量指标。这个值可由-XX:GCTimeRatio=n来设置。<br>暂停时间优先：自行选择相应的GC策略及控制新生代与旧生代的大小比例，尽量保证每次GC造成的应用停止时间都在指定的数值范围内完成。这个值可由-XX:MaxGCPauseRatio=n来设置。</p></blockquote></li></ol><hr><p>JVM Configuration:</p><ul><li>堆设置<blockquote><p>-Xms: 堆初始大小<br>-Xmx: 堆最大大小<br>-XX:NewSize=n: 设置年轻代大小<br>-XX:NewRatio=n: 设置年轻代和年老代的比值。如果设为3，表示年轻代与年老代比值为1:3，年轻代占整个年轻代年老代和的1/4。<br>-XX:SurvivorRatio=n: 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如果设为3，表示Eden:Survivor=3:2，一个Survivor区占整个年轻代的1/5。<br>-XX:MaxPermSize=n: 设置持久代大小</p></blockquote></li></ul><ul><li>收集器设置<blockquote><p>-XX:+UseSerialGC: 设置串行收集器<br>-XX:+UseParallelGC: 设置并行收集器<br>-XX:+UseParalledlOldGC: 设置并行年老代收集器<br>-XX:+UseParNewGC: 并发串行收集器<br>-XX:+UseConcMarkSweepGC: 设置并发收集器</p></blockquote></li></ul><ul><li>垃圾回收统计信息<blockquote><p>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename</p></blockquote></li></ul><ul><li>并行收集器设置<blockquote><p>-XX:ParallelGCThreads=n: 设置并行收集器收集时使用的CPU数，并行收集线程数<br>-XX:MaxGCPauseMillis=n: 设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n: 设置垃圾回收时间占程序运行时间的百分比。公式为 1/(1+n)</p></blockquote></li></ul><ul><li>并发收集器设置<blockquote><p>-XX:+CMSIncrementalMode: 设置为增量模式，适用于单CPU情况。<br>-XX:ParallelGCThreads=n: 设置并发收集器年轻代收集方式为并行收集时，使用的CPU数，并行收集线程数。</p></blockquote></li></ul><hr><h3 id="VM-Lifecycle"><a href="#VM-Lifecycle" class="headerlink" title="VM Lifecycle"></a>VM Lifecycle</h3><p>The following sections gives an overview of the general purpose java launcher pertaining(与…有关的) to the lifecyle of the HotSpot VM.</p><ul><li>Launcher</li><li>JNI_CreateJavaVM</li><li>DestroyJavaVM</li></ul><h4 id="Launcher"><a href="#Launcher" class="headerlink" title="Launcher"></a>Launcher</h4><p>There are several HotSpot VM launchers in the Java Standard Edition, <strong>the general purpose launcher typically used is the java command on Unix and on Windows java and javaw commands</strong>, not to be confused with javaws which is a network based launcher.</p><ol><li><p>Parse the command line options, some of the command line options are consumed by the launcher itself, for example -client or -server is used to determine and load the appropriate VM library, others are passed to the VM using <strong>JavaVMInitArgs</strong>.</p></li><li><p>Establish the heap sizes and the compiler type (client or server) if these options are not explicitly specified on the command line.</p></li><li><p>Establishes the environment variables such as LD_LIBRARY_PATH and CLASSPATH.</p></li><li><p>If the java Main-Class is not specified on the command line it <strong>fetches the Main-Class name from the JAR’s manifest</strong>.</p></li><li><p>Creates the VM using <strong>JNI_CreateJavaVM</strong> in a newly created thread (<strong>non primordial thread</strong>). </p><blockquote><p>Note: creating the VM in the primordial thread greatly reduces the ability to customize the VM, for example the stack size on Windows, and many other limitations.</p></blockquote></li><li><p>Once the VM is created and initialized, the Main-Class is loaded, and the launcher gets the main method’s attributes from the Main-Class.</p></li><li><p>The java main method is then invoked in the VM using <strong>CallStaticVoidMethod</strong>, using the marshalled arguments from the command line. - main()真正开始被调用</p></li><li><p>Once the java main method completes, its very important to check and clear any pending exceptions that may have occurred and also pass back the exit status, the exception is cleared by calling <strong>ExceptionOccurred</strong>, the return value of this method is 0 if successful, any other value otherwise, this value is passed back to the calling process.</p></li><li><p>The main thread is detached using <strong>DetachCurrentThread</strong>, by doing so we decrement the thread count so the DestroyJavaVM can be called safely, also to ensure that the thread is not performing operations in the vm and that there are no active java frames on its stack.</p></li></ol><hr><h4 id="JNI-CreateJavaVM"><a href="#JNI-CreateJavaVM" class="headerlink" title="JNI_CreateJavaVM"></a>JNI_CreateJavaVM</h4><ol><li><p>Ensures that no two threads call this method at the same time and that no two VM instances are created in the same process. Noting that a VM cannot be created in the same process space once a point in initialization is reached, “point of no return”. This is so because the VM creates static data structures that cannot be re-initialized, at this time.</p></li><li><p>Checks to make sure the JNI version is supported, and the ostream is initialized for gc logging. The OS modules are initialized such as the random number generator, the current pid, high-resolution time, memory page sizes, and the guard pages.</p></li><li><p>The arguments and properties passed in are parsed and stored away for later use. The standard java system properties are initialized.</p></li><li><p>The OS modules are further created and initialized, based on the parsed arguments and properties, are initialized for synchronization, stack, memory, and safepoint pages. At this time other libraries such as libzip, libhpi, libjava, libthread are loaded, signal handlers are initialized and set, and the thread library is initialized.</p></li><li><p>The output stream logger is initialized. Any agent libraries (hprof, jdi) required are initialized and started.</p></li><li><p>The thread states and the thread local storage (TLS), which holds several thread specific data required for the operation of threads, are initialized.</p></li><li><p>The global data is initialized as part of the I phase, such as event log, OS synchronization primitives, perfMemory (performance memory), chunkPool (memory allocator).</p></li><li><p>At this point, we can create Threads. The Java version of the main thread is created and attached to the current OS thread. However this thread will not be yet added to the known list of the Threads. The Java level synchronization is initialized and enabled.</p></li><li><p>The rest of the global modules are initialized such as the BootClassLoader, CodeCache, Interpreter, Compiler, JNI, SystemDictionary, and Universe. Noting that, we have reached our “point of no return”, ie. We can no longer create another VM in the same process address space.</p></li><li><p>The main thread is added to the list, by first locking the Thread_Lock. The Universe, a set of required global data structures, is sanity checked. The VMThread, which performs all the VM’s critical functions, is created. At this point the appropriate JVMTI events are posted to notify the current state.</p></li><li><p>The following classes java.lang.String, java.lang.System, java.lang.Thread, java.lang.ThreadGroup, java.lang.reflect.Method, java.lang.ref.Finalizer, java.lang.Class, and the rest of the System classes, are loaded and initialized. At this point, the VM is initialized and operational, but not yet fully functional.</p></li><li><p>The Signal Handler thread is started, the compilers are initialized and the CompileBroker thread is started. The other helper threads StatSampler and WatcherThreads are started, at this time the VM is fully functional, the JNIEnv is populated and returned to the caller, and the VM is ready to service new JNI requests.</p></li></ol><hr><h4 id="DestroyJavaVM"><a href="#DestroyJavaVM" class="headerlink" title="DestroyJavaVM"></a>DestroyJavaVM</h4><ol><li><p>Wait until we are the last non-daemon thread to execute, noting that the VM is still functional.</p></li><li><p>Call java.lang.Shutdown.shutdown(), which will invoke Java level shutdown hooks, run finalizers if finalization-on-exit.</p></li><li><p>Call before_exit(), prepare for VM exit run VM level shutdown hooks (they are registered through JVM_OnExit()), stop the Profiler, StatSampler, Watcher and GC threads. Post the status events to JVMTI/PI, disable JVMPI, and stop the Signal thread.</p></li><li><p>Call JavaThread::exit(), to release JNI handle blocks, remove stack guard pages, and remove this thread from Threads list. From this point on we cannot execute any more Java code.</p></li><li><p>Stop VM thread, it will bring the remaining VM to a safepoint and stop the compiler threads. At a safepoint, care should that we should not use anything that could get blocked by a Safepoint.</p></li><li><p>Disable tracing at JNI/JVM/JVMPI barriers.</p></li><li><p>Set _vm_exited flag for threads that are still running native code.</p></li><li><p>Delete this thread.</p></li><li><p>Call exit_globals(), which deletes IO and PerfMemory resources.</p></li><li><p>Return to caller.</p></li></ol><hr><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><img src="/2018/12/21/Java/JVM/Basic/Quick-Start/thread-extend-structure.png"><ul><li>java.lang.Thread: 这个是Java语言里的线程类，由这个Java类创建的instance都会1:1映射到一个操作系统的osthread。</li><li>JavaThread：JVM中C++定义的类，一个JavaThread的instance代表了在JVM中的java.lang.Thread的instance, 它维护了线程的状态，并且维护一个指针指向java.lang.Thread创建的对象(oop)。它同时还维护了一个指针指向对应的OSThread，来获取底层操作系统创建的osthread的状态。</li><li>OSThread：JVM中C++定义的类，代表了JVM中对底层操作系统的osthread的抽象，它维护着实际操作系统创建的线程句柄handle，可以获取底层osthread的状态。</li><li>VMThread：JVM中C++定义的类，这个类和用户创建的线程无关，是JVM本身用来进行虚拟机操作的线程，比如GC。</li></ul><h4 id="Thread-Creation-and-Destruction"><a href="#Thread-Creation-and-Destruction" class="headerlink" title="Thread Creation and Destruction"></a>Thread Creation and Destruction</h4><p>There are two basic ways for a thread to be introduced into the VM:</p><ul><li>execution of Java code that calls start() on a java.lang.Thread object</li><li>attaching an existing native thread to the VM using JNI</li></ul><p>There are a number of objects associated with a given thread in the VM:</p><ul><li>The java.lang.Thread instance that represents a thread in Java code</li><li><strong>A JavaThread instance that represents the java.lang.Thread instance inside the VM.</strong> It contains additional information to track the state of the thread. A JavaThread holds a reference to its associated java.lang.Thread object (as an oop), and the java.lang.Thread object also stores a reference to its JavaThread (as a raw int). A JavaThread also holds a reference to its associated OSThread instance.</li><li><strong>An OSThread instance represents an operating system thread</strong>, and contains additional operating-system-level information needed to track thread state. The OSThread then contains a platform specific “handle” to identify the actual thread to the operating system</li></ul><blockquote><p>JavaThread：HotSpot VM在内部管理Java线程执行状态的C++对象，里面会进一步引用一个OSThread对象，是HotSpot VM对底层操作系统线程的状态的抽象描述用的对象。这些管理用的对象都很小，可以忽略不计。<br>在每个平台上HotSpot VM对OSThread有特定的实现，里面会包含创建真正的平台线程（例如通过 pthread 在Linux上创建LWP）的逻辑，其中会传栈大小的参数下去来分配栈空间。例如说在Linux上现在HotSpot VM默认使用的栈大小是1MB，这个空间才是大头，远大于HotSpot VM用来管理线程用的那些小的C++对象的大小。<br>因此，在HotSpot VM上遇到 “unable to create new native thread” ，最主要的原因还就是无法分配Java线程的栈的情况。</p></blockquote><p>When a java.lang.Thread is started the VM creates the associated JavaThread and OSThread objects, and <strong>ultimately the native thread</strong>. After preparing all of the VM state (such as thread-local storage and allocation buffers, synchronization objects and so forth) the native thread is started. </p><p><strong>The native thread completes initialization and then executes a start-up method that leads to the execution of the java.lang.Thread object’s run() method</strong>, and then, upon its return, terminates the thread after dealing with any uncaught exceptions, and interacting with the VM to check if termination of this thread requires termination of the whole VM. Thread termination releases all allocated resources, removes the JavaThread from the set of known threads, invokes destructors for the OSThread and JavaThread and ultimately ceases execution when it’s initial startup method completes.</p><p>A native thread attaches to the VM using the JNI call <strong>AttachCurrentThread</strong>. In response to this an associated OSThread and JavaThread instance is created and basic initialization is performed. </p><p>Next a java.lang.Thread object must be created for the attached thread, which is done by reflectively invoking the Java code for the Thread class constructor, based on the arguments supplied when the thread attached. Once attached, a thread can invoke whatever Java code it needs to via the other JNI methods available. </p><p>Finally when the native thread no longer wishes to be involved with the VM it can call the JNI <strong>DetachCurrentThread</strong> method to disassociate it from the VM (release resources, drop the reference to the java.lang.Thread instance, destruct the JavaThread and OSThread objects and so forth).</p><p>A special case of attaching a native thread is the initial creation of the VM via the JNI <strong>CreateJavaVM</strong> call, which can be done by a native application or by the launcher (java.c). This causes a range of initialization operations to take place and then acts effectively as if a call to <strong>AttachCurrentThread</strong> was made. The thread can then invoke Java code as needed, such as reflective invocation of the main method of an application. </p><h4 id="Thread-States"><a href="#Thread-States" class="headerlink" title="Thread States"></a>Thread States</h4><p>The main thread states from the VM perspective are as follows:</p><ul><li>_thread_new: a new thread in the process of being initialized</li><li>_thread_in_Java: a thread that is executing Java code</li><li>_thread_in_vm: a thread that is executing inside the VM</li><li>_thread_blocked: the thread is blocked for some reason (acquiring a lock, waiting for a condition, sleeping, performing a blocking I/O operation and so forth)</li></ul><p>For debugging purposes additional state:</p><ul><li>MONITOR_WAIT: a thread is waiting to acquire a contended monitor lock</li><li>CONDVAR_WAIT: a thread is waiting on an internal condition variable used by the VM (not associated with any Java level object)</li><li>OBJECT_WAIT: a thread is performing an Object.wait() call</li></ul><h4 id="Internal-VM-Threads"><a href="#Internal-VM-Threads" class="headerlink" title="Internal VM Threads"></a>Internal VM Threads</h4><ul><li>VM thread: This singleton instance of VMThread is responsible for executing VM operations, which are discussed below</li><li>Periodic task thread: This singleton instance of WatcherThread simulates timer interrupts for executing periodic operations withinthe VM</li><li>GC threads: These threads, of different types, support parallel and concurrent garbage collection</li><li>Compiler threads: These threads perform runtime compilation of bytecode to native code</li><li>Signal dispatcher thread: This thread waits for process directed signals and dispatches them to a Java level signal handling method</li></ul><p>All threads are instances of the Thread class, and all threads that execute Java code are JavaThread instances (a subclass of Thread). </p><p>The VM keeps track of all threads in a linked-list known as the Threads_list, and which is protected by the Threads_lock – one of the key synchronization locks used within the VM.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://hacpai.com/article/1542904258051" target="_blank" rel="noopener">https://hacpai.com/article/1542904258051</a><br><a href="http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/RuntimeOverview.html</a><br><a href="https://www.zhihu.com/question/64685291" target="_blank" rel="noopener">https://www.zhihu.com/question/64685291</a><br><a href="https://blog.csdn.net/justloveyou_/article/details/54347954" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/54347954</a><br>关于JVM的类型和模式：<a href="https://my.oschina.net/itblog/blog/507822" target="_blank" rel="noopener">https://my.oschina.net/itblog/blog/507822</a><br>初探JAVA 10之CDS：<a href="https://www.jianshu.com/p/890196bf529a" target="_blank" rel="noopener">https://www.jianshu.com/p/890196bf529a</a><br>Java 并发：Thread 类深度解析: <a href="https://blog.csdn.net/justloveyou_/article/details/54347954" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/54347954</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JVM-Running-Time&quot;&gt;&lt;a href=&quot;#JVM-Running-Time&quot; class=&quot;headerlink&quot; title=&quot;JVM Running Time&quot;&gt;&lt;/a&gt;JVM Running Time&lt;/h3&gt;&lt;img src=&quot;/2018/1
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="QuickStart" scheme="https://sulangsss.github.io/tags/QuickStart/"/>
    
  </entry>
  
  <entry>
    <title>Cloud Architecture</title>
    <link href="https://sulangsss.github.io/2018/12/21/Architecture/CloudSolution/"/>
    <id>https://sulangsss.github.io/2018/12/21/Architecture/CloudSolution/</id>
    <published>2018-12-21T08:01:22.000Z</published>
    <updated>2018-12-25T02:02:39.538Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cloud-Platform"><a href="#Cloud-Platform" class="headerlink" title="Cloud Platform"></a>Cloud Platform</h3><ul><li>Kubernetes</li></ul><hr><h3 id="Register-And-Discover"><a href="#Register-And-Discover" class="headerlink" title="Register And Discover"></a>Register And Discover</h3><ul><li>eurake</li><li>nacos</li><li>zk</li><li>consul</li><li>etcd</li></ul><hr><h3 id="Circuit-breaker"><a href="#Circuit-breaker" class="headerlink" title="Circuit breaker"></a>Circuit breaker</h3><ul><li>istio</li><li>Linkerd</li></ul><hr><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><ul><li><p>GlusterFS</p><blockquote><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-glusterfs-docker-volume/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-glusterfs-docker-volume/index.html</a></p></blockquote></li><li><p>Ceph</p></li></ul><hr><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><ul><li>Jenkins</li></ul><hr><h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><ul><li>Spinnaker：一个持续交付平台，它定位于将产品快速且持续的部署到多种云平台上。</li></ul><h3 id="Docker-Repository"><a href="#Docker-Repository" class="headerlink" title="Docker Repository"></a>Docker Repository</h3><ul><li>Docker Registry</li><li>Habor</li><li>Nexus</li></ul><hr><h3 id="The-package-manager-for-Kubernetes"><a href="#The-package-manager-for-Kubernetes" class="headerlink" title="The package manager for Kubernetes"></a>The package manager for Kubernetes</h3><ul><li>Helm</li></ul><hr><h3 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h3><h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><ul><li>Heapster+Grafana+InfluxDB</li></ul><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>Spring Boot Actuator + Spring Boot Admin</li></ul><h4 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h4><ul><li>gceasy</li><li>fastthread</li><li>gcplot</li></ul><h4 id="Trace"><a href="#Trace" class="headerlink" title="Trace"></a>Trace</h4><ul><li>SkyWalking</li><li>Zipkin</li></ul><hr><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><ul><li>Fluentd + Elasticsearch + Kibana</li></ul><hr><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><ul><li>GitLab</li><li>SonarQube</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Cloud-Platform&quot;&gt;&lt;a href=&quot;#Cloud-Platform&quot; class=&quot;headerlink&quot; title=&quot;Cloud Platform&quot;&gt;&lt;/a&gt;Cloud Platform&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;

      
    
    </summary>
    
      <category term="Architecture" scheme="https://sulangsss.github.io/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="https://sulangsss.github.io/tags/Architecture/"/>
    
      <category term="Cloud" scheme="https://sulangsss.github.io/tags/Cloud/"/>
    
  </entry>
  
  <entry>
    <title>Java RegEx Syntax</title>
    <link href="https://sulangsss.github.io/2018/12/21/Java/RegEx/BasicSyntax/"/>
    <id>https://sulangsss.github.io/2018/12/21/Java/RegEx/BasicSyntax/</id>
    <published>2018-12-21T03:31:22.000Z</published>
    <updated>2018-12-24T08:14:35.216Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h4><p>Synatx: (?(?=regex)then|else)</p><h4 id="Example：Split-Decimal-String"><a href="#Example：Split-Decimal-String" class="headerlink" title="Example：Split Decimal String"></a>Example：Split Decimal String</h4><p>Target</p><ul><li>1000.00 -&gt; (1000),(00)</li><li>1000 -&gt; (1000),()</li></ul><p>Note:</p><ul><li>合法值</li><li>非法值，比如00100，a100，100x100，100.a100等等</li></ul><p>对于非法值可以预先检查，如果包含非法值，直接忽略，比如用”[^\d\.]”来检测是否有非法字符</p><p>Exp: (^[1-9]{1}\d+)(?=.<em>(\d+|\d</em>))</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;h4 id=&quot;if-else&quot;&gt;&lt;a href=&quot;#if-else&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="RegEx" scheme="https://sulangsss.github.io/categories/Java/RegEx/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Syntax" scheme="https://sulangsss.github.io/tags/Syntax/"/>
    
      <category term="RegEx" scheme="https://sulangsss.github.io/tags/RegEx/"/>
    
  </entry>
  
</feed>
