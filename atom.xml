<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Big Boy Blog -  Tech Articls &amp; Notes</title>
  
  <subtitle>Python Java Android Django Web -&gt; sulang357159@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulangsss.github.io/"/>
  <updated>2019-04-27T12:54:13.709Z</updated>
  <id>https://sulangsss.github.io/</id>
  
  <author>
    <name>Jason - sulang357159@163.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM YGC</title>
    <link href="https://sulangsss.github.io/2019/04/27/Java/JVM/Basic/YGC/"/>
    <id>https://sulangsss.github.io/2019/04/27/Java/JVM/Basic/YGC/</id>
    <published>2019-04-27T11:31:22.000Z</published>
    <updated>2019-04-27T12:54:13.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>otSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from和to）。默认比例为8：1,为啥默认会是这个比例，接下来我们会聊到。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><img src="/2019/04/27/Java/JVM/Basic/YGC/young_gc.png"><hr><h4 id="YGC-Young-GC"><a href="#YGC-Young-GC" class="headerlink" title="YGC - Young GC"></a>YGC - Young GC</h4><p>YGC是JVM GC当前最为频繁的一种GC，一个高并发的服务在运行期间，会进行大量的YGC，发生YGC时，会进行STW，一般时间都很短，除非碰到YGC时，存在大量的存活对象需要进行拷贝。</p><p>一次YGC过程主要分成两个步骤：</p><ol><li>查找GC Roots，拷贝所引用的对象到 to 区；</li><li>递归遍历上一步中查找到的对象，并拷贝其所引用的对象到 to 区，当然可能会存在自然晋升，或者因为 to 区空间不足引起的提前晋升的情况；</li></ol><hr><h3 id="Find-GC-Roots"><a href="#Find-GC-Roots" class="headerlink" title="Find GC Roots"></a>Find GC Roots</h3><p>YGC的第一步根据GC Roots找出第一批活跃的对象，Hotspot中通过 <strong>gch-&gt;gen_process_strong_roots</strong> 方法实现</p><blockquote><p>Serial GC源代码为例</p></blockquote><img src="/2019/04/27/Java/JVM/Basic/YGC/find_gc_roots_code.png"><ul><li>在黄色框的实现中，SharedHeap::process_strong_roots()扫描了所有一定是GC Roots的内存区域；</li><li>红色框中的实现逻辑对于YGC来说是没有意义的，因为level=0，Hotspot中唯一用到这个地方的只有CMS GC实现，默认只收集old generation，所以需要扫描young generation作为它的Strong root；</li><li>如果一个old generation的对象引用了young generation，那么这个old generation的对象肯定也属于Strong root的一部分，这部分逻辑并没有在process_strong_roots中实现，而是在绿色框中实现了，其中rem_set中保存了old generation中dirty card的对应区域，每次对象的拷贝移动都会检查一下是否产生了新的跨代引用，<strong>比如有对象晋升到了old generation，而该对象还引用了young generation的对象，这种情况下会把相应的card置为dirty，下次YGC的时候只会扫描dirty card所指内存的对象，避免扫描所有的old generation对象。</strong></li></ul><blockquote><p>process_strong_roots的实现，主要包括了以下东西：<br>Universe类中所引用的一些必须存活的对象 Universe::oops_do(roots)<br>所有JNI Handles JNIHandles::oops_do(roots)<br>所有线程的栈 Threads::oops_do(roots, code_roots)<br>所有被Synchronize锁持有的对象  ObjectSynchronizer::oops_do(roots)<br>VM内实现的MBean所持有的对象 Management::oops_do(roots)<br>JVMTI所持有的对象 JvmtiExport::oops_do(roots)<br>（可选）所有已加载的类 或 所有已加载的系统类 SystemDictionary::oops_do(roots)<br>（可选）所有驻留字符串（StringTable） StringTable::oops_do(roots)<br>（可选）代码缓存（CodeCache） CodeCache::scavenge_root_nmethods_do(code_roots)<br>（可选）PermGen的remember set所记录的存在跨代引用的区域  rem_set()-&gt;younger_refs_iterate(perm_gen(), perm_blk)<br>注意：YGC在执行时只收集young generation，不收集old generation和perm generation，并不会做类的卸载行为，所以上述可选部分都作为Strong root，但是在FGC时就不会当作Strong root了。</p></blockquote><hr><h3 id="Recurse-Roots"><a href="#Recurse-Roots" class="headerlink" title="Recurse Roots"></a>Recurse Roots</h3><p>在查找GC Roots的步骤中，已经找出了第一批存活的对象，这些存活对象可能在 to-space，也有可能直接晋升到了 old generation，这些区域都是需要进行遍历的，保证所有的活跃对象都能存活下来。<br>遍历过程的实现由FastEvacuateFollowersClosure类的do_void方法完成，这是一个*-Closure 方式命名的类，实现如下：</p><img src="/2019/04/27/Java/JVM/Basic/YGC/recurse_roots.png"><p>每个内存区域都有两个指针变量，分别是 _saved_mark_word 和 _top，其中_saved_mark_word 指向当前遍历对象的位置，_top指向当前内存区域可分配的位置，其中_saved_mark_word 到 _top之间的对象是已拷贝，但未扫描的对象。</p><img src="/2019/04/27/Java/JVM/Basic/YGC/saved_market_word.png"><p>GC Roots引用的对象拷贝完成后，to-space的_saved_mark_word和_top的状态如上图所示，假设期间没有对象晋升到old generation。每次扫描一个对象，_saved_mark_word会往前移动，期间也有新的对象会被拷贝到to-space，_top也会往前移动，直到_saved_mark_word追上_top，说明to-space的对象都已经遍历完成。</p><p>其中while循环条件 while (!_gch-&gt;no_allocs_since_save_marks(_level)，就是在判断各个内存代中的_saved_mark_word是否已经追到_top，如果还没有追上，就执行_gch-&gt;oop_since_save_marks_iterate进行遍历，实现如下：</p><img src="/2019/04/27/Java/JVM/Basic/YGC/oop_since_save_marks_iterate.png"><p>to-space对象的遍历实现：</p><img src="/2019/04/27/Java/JVM/Basic/YGC/to-space.png"><p>这里的blk变量是传递过来的FastScanClosure回调函数，oop_iterate方法会遍历该对象的所有引用，并调用回调函数的do_oop_work方法处理这里引用所指向的对象。</p><p>do_oop_work的实现：</p><img src="/2019/04/27/Java/JVM/Basic/YGC/do_oop_work.png"><p>在FastScanClosure回调函数的do_oop_work方法实现中，红框的是重要的部分，因为可能存在多个对象共同引用一个对象，所以在遍历过程中，可能会遇到已经处理过的对象，如果遇到这样的对象，就不会再次进行复制了，如果该对象没有被拷贝过，则调用 copy_to_survivor_space 方法拷贝对象到to-space或者晋升到old generation，这里提一下ParNew的实现，因为是并发执行的，所以可能存在多个线程拷贝了同一个对象到to-space，不过通过原子操作，保证了只有一个对象是有效的。</p><p>copy_to_survivor_space 的实现：</p><img src="/2019/04/27/Java/JVM/Basic/YGC/copy_to_survivor_space.png"><p>拷贝对象的目标空间不一定是to-space，也有可能是old generation，如果一个对象经历了很多次YGC，会从young generation直接晋升到old generation，为了记录对象经历的YGC次数，在对象头的mark word 数据结构中有一个位置记录着对象的YGC次数，也叫对象的年龄，如果扫描到的对象，其年龄小于某个阈值（tenuring threshold），该对象会被拷贝到to-space，并增加该对象的年龄，同时to-space的_top指针也会往后移动，这个新对象等待着被扫描。</p><img src="/2019/04/27/Java/JVM/Basic/YGC/saved_market_word_2.png"><hr><h3 id="Full-GC-和-YGC-触发条件"><a href="#Full-GC-和-YGC-触发条件" class="headerlink" title="Full GC 和 YGC 触发条件"></a>Full GC 和 YGC 触发条件</h3><p><strong>YGC</strong>：对新生代堆进行GC。频率比较高，因为大部分对象的存活寿命较短，在新生代里被回收。性能耗费较小。</p><p>YGC触发条件：</p><ul><li>edn空间不足</li></ul><p><strong>FGC</strong>：全堆范围的GC。默认堆空间使用到达80%(可调整)的时候会触发FGC。<br>FGC触发条件：</p><ul><li>old空间不足；</li><li>perm空间不足；</li><li>显示调用System.gc()，包括RMI等的定时触发；</li><li>YGC时的悲观策略；</li><li>dump live的内存信息时(jmap –dump:live)；</li><li>heap dump。</li></ul><blockquote><p>悲观策略：当准备要触发一次 young GC时，如果发现统计数据说之前 young GC的平均晋升大小比目前的 old gen剩余的空间大，则不会触发young GC而是转为触发 full GC。<br>因为HotSpot VM的GC里，除了垃圾回收器 CMS 的 concurrent collection 之外，其他能收集 old gen 的GC都会同时收集整个GC堆，包括young gen，所以不需要事先准备一次单独的young GC。</p></blockquote><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="http://ifeve.com/jvm-yong-generation/" target="_blank" rel="noopener">http://ifeve.com/jvm-yong-generation/</a><br><a href="https://www.jianshu.com/p/9af1a63a33c3" target="_blank" rel="noopener">https://www.jianshu.com/p/9af1a63a33c3</a><br><a href="https://juejin.im/post/5b8d2a5551882542ba1ddcf8" target="_blank" rel="noopener">https://juejin.im/post/5b8d2a5551882542ba1ddcf8</a><br><a href="https://www.zhihu.com/question/41922036/answer/93079526" target="_blank" rel="noopener">https://www.zhihu.com/question/41922036/answer/93079526</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Java/JVM/Basic/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="YGC" scheme="https://sulangsss.github.io/tags/YGC/"/>
    
  </entry>
  
  <entry>
    <title>Java Queue</title>
    <link href="https://sulangsss.github.io/2019/04/24/Java/Advance/Queue/"/>
    <id>https://sulangsss.github.io/2019/04/24/Java/Advance/Queue/</id>
    <published>2019-04-24T04:01:06.000Z</published>
    <updated>2019-04-25T12:15:20.457Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Interface"><a href="#Interface" class="headerlink" title="Interface"></a>Interface</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A collection designed for holding elements prior to processing.</span></span><br><span class="line"><span class="comment"> * Besides basic &#123;<span class="doctag">@link</span> java.util.Collection Collection&#125; operations,</span></span><br><span class="line"><span class="comment"> * queues provide additional insertion, extraction, and inspection</span></span><br><span class="line"><span class="comment"> * operations.  Each of these methods exists in two forms: one throws</span></span><br><span class="line"><span class="comment"> * an exception if the operation fails, the other returns a special</span></span><br><span class="line"><span class="comment"> * value (either &#123;<span class="doctag">@code</span> null&#125; or &#123;<span class="doctag">@code</span> false&#125;, depending on the</span></span><br><span class="line"><span class="comment"> * operation).  The latter form of the insert operation is designed</span></span><br><span class="line"><span class="comment"> * specifically for use with capacity-restricted &#123;<span class="doctag">@code</span> Queue&#125;</span></span><br><span class="line"><span class="comment"> * implementations; in most implementations, insert operations cannot</span></span><br><span class="line"><span class="comment"> * fail.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//插入（抛出异常）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//插入（返回特殊值）</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="comment">//移除（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//移除（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（抛出异常）</span></span><br><span class="line">    <span class="function">E <span class="title">element</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//检查（返回特殊值）</span></span><br><span class="line">    <span class="function">E <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue是个接口，它提供的add，offer方法初衷是希望子类能够禁止添加元素为<span class="keyword">null</span>，这样可以避免在查询时返回<span class="keyword">null</span>究竟是正确还是错误。实际上大多数Queue的实现类的确响应了Queue接口的规定，比如ArrayBlockingQueue，PriorityBlockingQueue等等。</span><br><span class="line"></span><br><span class="line">但还是有一些实现类没有这样要求，比如LinkedList。虽然 LinkedList 没有禁止添加 <span class="keyword">null</span>，但是一般情况下 Queue 的实现类都不允许添加 <span class="keyword">null</span> 元素，为啥呢？因为poll(),peek()方法在异常的时候会返回 <span class="keyword">null</span>，你添加了<span class="keyword">null</span> 以后，当获取时不好分辨究竟是否正确返回。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deque</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Queue</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the front of this deque if it is</span></span><br><span class="line"><span class="comment">     * possible to do so immediately without violating capacity restrictions,</span></span><br><span class="line"><span class="comment">     * throwing an &#123;<span class="doctag">@code</span> IllegalStateException&#125; if no space is currently</span></span><br><span class="line"><span class="comment">     * available.  When using a capacity-restricted deque, it is generally</span></span><br><span class="line"><span class="comment">     * preferable to use method &#123;<span class="doctag">@link</span> #offerFirst&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the element to add</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalStateException if the element cannot be added at this</span></span><br><span class="line"><span class="comment">     *         time due to capacity restrictions</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if the class of the specified element</span></span><br><span class="line"><span class="comment">     *         prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified element is null and this</span></span><br><span class="line"><span class="comment">     *         deque does not permit null elements</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if some property of the specified</span></span><br><span class="line"><span class="comment">     *         element prevents it from being added to this deque</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">E <span class="title">removeLast</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Classification"><a href="#Classification" class="headerlink" title="Classification"></a>Classification</h4><ul><li>PriorityQueue</li><li>PriorityBlockingQueue</li><li>Deque</li><li>ArrayDeque：ArrayDeque是一个循环队列，它使用数组实现的Deque，底层是数组。</li><li>BlockingQueue</li><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>SynchronousQueue</li></ul><p><strong>Summary</strong></p><ul><li>当 Deque 当做 Queue 队列使用时（FIFO），添加元素是添加到队尾，删除时删除的是头部元素。</li><li>当 Deque 当做 Stack 栈用（LIFO）。这时入栈、出栈元素都是在双端队列的头部进行。</li><li>ArrayDeque不是线程安全的。 当作为栈使用时，性能比Stack好；当作为队列使用时，性能比LinkedList好。</li><li>ArrayBlockingQueue 底层是数组，有界队列，如果我们要使用生产者-消费者模式，这是非常好的选择。</li><li>LinkedBlockingQueue 底层是链表，可以当做无界和有界队列来使用，所以大家不要以为它就是无界队列。</li><li>SynchronousQueue 本身不带有空间来存储任何元素，使用上可以选择公平模式和非公平模式。</li><li>PriorityBlockingQueue 是无界队列，基于数组，数据结构为二叉堆，数组第一个也是树的根节点总是最小值。</li></ul><hr><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><h4 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h4><p>ArrayBlockingQueue 是 BlockingQueue 接口的有界队列实现类，底层采用数组来实现。其并发控制采用可重入锁来控制，不管是插入操作还是读取操作，都需要获取到锁才能进行操作。</p><p><strong>核心属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存放元素的数组</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">// 下一次读取操作的位置</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">// 下一次写入操作的位置</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">// 以下几个就是控制并发用的同步器</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><p><strong>核心原理</strong></p><p>ArrayBlockingQueue 实现并发同步的原理就是，读操作和写操作都需要获取到 AQS 独占锁才能进行操作。</p><p>如果队列为空，这个时候读操作的线程进入到读线程队列排队，等待写线程写入新的元素，然后写线程唤醒读线程队列的第一个等待线程。如果队列已满，这个时候写操作的线程进入到写线程队列排队，等待读线程将队列元素移除腾出空间，然后唤醒写线程队列的第一个等待线程。</p><img src="/2019/04/24/Java/Advance/Queue/array-blocking-queue.png"><p>构造函数可选参数：</p><ul><li>队列容量，其限制了队列中最多允许的元素个数；</li><li>指定独占锁是公平锁还是非公平锁。非公平锁的吞吐量比较高，公平锁可以保证每次都是等待最久的线程获取到锁；</li><li>可以指定用一个集合来初始化，将此集合中的元素在构造方法期间就先添加到队列中。</li></ul><hr><h4 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h4><p>底层基于单向链表实现的阻塞队列，可以当做无界队列也可以当做有界队列来使用。</p><p><strong>核心属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列中的元素数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队尾</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// take, poll, peek 等读操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果读操作的时候队列是空的，那么等待 notEmpty 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">// put, offer 等写操作的方法需要获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果写操作的时候队列是满的，那么等待 notFull 条件</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><p>ReentrantLock与Condition使用说明：</p><ul><li><p>takeLock 和 notEmpty 搭配：如果要获取（take）一个元素，需要获取 takeLock 锁，但是获取了锁还不够，如果队列此时为空，还需要队列不为空（notEmpty）这个条件（Condition）。</p></li><li><p>putLock 和 notFull 搭配：如果要插入（put）一个元素，需要获取 putLock 锁，但是获取了锁还不够，如果队列此时已满，还需要队列不是满的（notFull）这个条件（Condition）。</p></li></ul><img src="/2019/04/24/Java/Advance/Queue/linked-blocking-queue.png"><hr><h4 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h4><p>不像ArrayBlockingQueue或LinkedListBlockingQueue，SynchronousQueue内部并没有数据缓存空间，你不能调用peek()方法来看队列中是否有数据元素，因为数据元素只有当你试着取走的时候才可能存在，不取走而只想偷窥一下是不行的，当然遍历这个队列的操作也是不允许的。队列头元素是第一个排队要插入数据的线程，而不是要交换的数据。数据是在配对的生产者和消费者线程之间直接传递的，并不会将数据缓冲数据到队列中。可以这样来理解：生产者和消费者互相等待对方，握手，然后一起离开。</p><p>虽然说是队列，但是 SynchronousQueue 的队列其实是虚的，其不提供任何空间（一个都没有）来存储元素。数据必须从某个写线程交给某个读线程，而不是写到某个队列中等待被消费。</p><p>在开发中比较少使用到 SynchronousQueue 这个类，不过它在线程池的实现类 ScheduledThreadPoolExecutor 中得到了应用。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，线程空闲了60秒后会被回收。</p><p><strong>核心原理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E o)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (transferer.transfer(o, <span class="keyword">false</span>, <span class="number">0</span>) == <span class="keyword">null</span>) &#123; <span class="comment">// 1</span></span><br><span class="line">        Thread.interrupted();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取值并移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Object e = transferer.transfer(<span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">0</span>); <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (E)e;</span><br><span class="line">    Thread.interrupted();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写操作 put(E o) 和读操作 take() 都是调用 Transferer.transfer(…) 方法，区别在于第一个参数是否为 null 值。</p><p>transfer 的设计思路，其基本算法如下：</p><ul><li><p>当调用这个方法时，如果队列是空的，或者队列中的节点和当前的线程操作类型一致（如当前操作是 put 操作，而队列中的元素也都是写线程）。这种情况下，将当前线程加入到等待队列即可。</p></li><li><p>如果队列中有等待节点，而且与当前操作可以匹配（如队列中都是读操作线程，当前线程是写操作线程，反之亦然）。这种情况下，匹配等待队列的队头，出队，返回相应数据。</p></li></ul><p><strong>示例图说明</strong></p><ol><li>前提条件：公平模式，初始化情况下，TransferQueue的状态</li></ol><img src="/2019/04/24/Java/Advance/Queue/TransferQueue1.png"><ol start="2"><li>put线程1执行操作put(1)，由于当前没有配对的消费线程，所以线程1入队列，自旋一小会后睡眠等待。</li></ol><img src="/2019/04/24/Java/Advance/Queue/TransferQueue2.png"><ol start="3"><li>put线程2执行操作put(2)，由于当前没有配对的消费线程，所以线程2入队列，自旋一小会后睡眠等待。</li></ol><img src="/2019/04/24/Java/Advance/Queue/TransferQueue3.png"><ol start="4"><li>这时候taker线程执行操作taker(1)，由于tail指向put2线程，put线程2跟take线程1配对了(put一take)，这时take1线程不需要入队，但是请注意了，这时候，要唤醒的线程并不是put线程2，而是put线程1。put线程1被唤醒，take线程1的take()方法返回了put线程1的数据，这样就实现了线程间的一对一通信，这时候内部状态如下：</li></ol><blockquote><p>公平策略总结下来就是：队尾匹配队头出队。</p></blockquote><img src="/2019/04/24/Java/Advance/Queue/TransferQueue4.png"><p>SynchronousQueue的实现模型。总结下来就是：队尾匹配队头出队，先进先出，体现公平原则。</p><hr><h4 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h4><p>带排序的 BlockingQueue 实现，其并发控制采用的是 ReentrantLock，队列为无界队列（ArrayBlockingQueue 是有界队列，LinkedBlockingQueue 也可以通过在构造函数中传入 capacity 指定队列最大的容量，但是 PriorityBlockingQueue 只能指定初始的队列大小，后面插入元素的时候，如果空间不够的话会自动扩容）。</p><p>简单地说，它就是 PriorityQueue 的线程安全版本。不可以插入 null 值，同时，插入队列的对象必须是可比较大小的（comparable），否则报 ClassCastException 异常。它的插入操作 put 方法不会 block，因为它是无界队列（take 方法在队列为空的时候会阻塞）。</p><p><strong>核心属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造方法中，如果不指定大小的话，默认大小为 11</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"><span class="comment">// 数组的最大容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个就是存放数据的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列当前大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大小比较器，如果按照自然序排序，那么此属性可设置为 null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发控制所用的锁，所有的 public 且涉及到线程安全的方法，都必须先获取到这个锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个很好理解，其实例由上面的 lock 属性创建</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个也是用于锁，用于数组扩容的时候，需要先获取到这个锁，才能进行扩容操作</span></span><br><span class="line"><span class="comment">// 其使用 CAS 操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> allocationSpinLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于序列化和反序列化的时候用，对于 PriorityBlockingQueue 我们应该比较少使用到序列化</span></span><br><span class="line"><span class="keyword">private</span> PriorityQueue q;</span><br></pre></td></tr></table></figure><p>此类实现了 Collection 和 Iterator 接口中的所有接口方法，对其对象进行迭代并遍历时，不能保证有序性。</p><p>如果你想要实现有序遍历，建议采用 Arrays.sort(queue.toArray()) 进行处理。PriorityBlockingQueue 提供了 drainTo 方法用于将部分或全部元素有序地填充（准确说是转移，会删除原队列中的元素）到另一个集合中。</p><p>还有一个需要说明的是，如果两个对象的优先级相同（compare 方法返回 0），此队列并不保证它们之间的顺序。</p><p>PriorityBlockingQueue 使用了基于数组的二叉堆来存放元素，所有的 public 方法采用同一个 lock 进行并发控制。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://juejin.im/post/5a3763ed51882506a463b740" target="_blank" rel="noopener">https://juejin.im/post/5a3763ed51882506a463b740</a><br><a href="https://javadoop.com/post/java-concurrent-queue" target="_blank" rel="noopener">https://javadoop.com/post/java-concurrent-queue</a><br><a href="https://zhuanlan.zhihu.com/p/29227508" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29227508</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;Interface&quot;&gt;&lt;a href=&quot;#Inte
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Queue" scheme="https://sulangsss.github.io/tags/Queue/"/>
    
      <category term="BlockingQueue" scheme="https://sulangsss.github.io/tags/BlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>Git Flow QuickStart</title>
    <link href="https://sulangsss.github.io/2019/04/23/Git/GitFlow/"/>
    <id>https://sulangsss.github.io/2019/04/23/Git/GitFlow/</id>
    <published>2019-04-23T13:36:12.000Z</published>
    <updated>2019-04-27T11:22:40.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Git Flow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。因此，Git flow可以很好的于各种现有开发模型相结合使用。</p><p>Git Flow模型中定义了主分支和辅助分支两类分支。其中主分支用于组织与软件开发、部署相关的活动；辅助分支组织为了解决特定的问题而进行的各种开发活动。</p><p>分支类型说明：</p><ul><li><p>feature： 用于日常的功能开发，一般一个功能分支代表一个功能，一般一个功能分支代表一个功能。</p><blockquote><p>继承分支：develop，合并分支：develop，命名规则：任何名字除了master, develop, release-<em>, hotfix-</em></p></blockquote></li><li><p>release：当需要发布新版本时使用，主要用于测试。可在此分支上直接开发功能，修复bug，但务必同时合并到develop和master。</p><blockquote><p>继承分支：develop，合并分支：develop master，命名规则：release-*</p></blockquote></li><li><p>hotfix：用于修复线上的bug，务必同时合并到develop和master。</p><blockquote><p>继承分支：master，合并分支：develop master，命名规则：hotfix-*</p></blockquote></li></ul><hr><h3 id="Git-Flow-Tools"><a href="#Git-Flow-Tools" class="headerlink" title="Git Flow Tools"></a>Git Flow Tools</h3><h4 id="Feature-Branch"><a href="#Feature-Branch" class="headerlink" title="Feature Branch"></a>Feature Branch</h4><ol><li><p>创建 feature 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git flow feature start login</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to a new branch <span class="string">'feature/login'</span></span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch <span class="string">'feature/login'</span> was created, based on <span class="string">'develop'</span></span><br><span class="line">- You are now on branch <span class="string">'feature/login'</span></span><br><span class="line"></span><br><span class="line">Now, start committing on your feature. When <span class="keyword">done</span>, use:</span><br><span class="line"></span><br><span class="line">     git flow feature finish login</span><br></pre></td></tr></table></figure></li><li><p>完成 feature 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git flow feature finish login</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to branch <span class="string">'develop'</span></span><br><span class="line">Updating d2df03b..85d1933</span><br><span class="line">Fast-forward</span><br><span class="line"> login.java | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 login.java</span><br><span class="line">Deleted branch feature/login (was 85d1933).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- The feature branch <span class="string">'feature/login'</span> was merged into <span class="string">'develop'</span></span><br><span class="line">- Feature branch <span class="string">'feature/login'</span> has been removed</span><br><span class="line">- You are now on branch <span class="string">'develop'</span></span><br></pre></td></tr></table></figure></li></ol><p>此时，本地feature/login已经被删除，同时代码合并到了本地的develop分支。</p><blockquote><p>如果想在github上保留feature/login，则需要手动push该分支。</p></blockquote><h4 id="Release-Branch"><a href="#Release-Branch" class="headerlink" title="Release Branch"></a>Release Branch</h4><ol><li><p>创建 release 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">git flow release start 1.13.1</span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Switched to a new branch <span class="string">'release/1.13.1'</span></span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- A new branch <span class="string">'release/1.13.1'</span> was created, based on <span class="string">'develop'</span></span><br><span class="line">- You are now on branch <span class="string">'release/1.13.1'</span></span><br><span class="line"></span><br><span class="line">Follow-up actions:</span><br><span class="line">- Bump the version number now!</span><br><span class="line">- Start committing last-minute fixes <span class="keyword">in</span> preparing your release</span><br><span class="line">- When <span class="keyword">done</span>, run:</span><br><span class="line"></span><br><span class="line">     git flow release finish <span class="string">'1.13.1'</span></span><br></pre></td></tr></table></figure></li><li><p>完成 release 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git flow release finish <span class="string">'1.13.1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#### output #####</span></span><br><span class="line">Deleted branch release/1.13.1 (was 85d1933).</span><br><span class="line"></span><br><span class="line">Summary of actions:</span><br><span class="line">- Latest objects have been fetched from <span class="string">'origin'</span></span><br><span class="line">- Release branch has been merged into <span class="string">'master'</span></span><br><span class="line">- The release was tagged <span class="string">'1.13.1'</span></span><br><span class="line">- Release branch has been back-merged into <span class="string">'develop'</span></span><br><span class="line">- Release branch <span class="string">'release/1.13.1'</span> has been deleted</span><br></pre></td></tr></table></figure></li></ol><p>完成release 1.13.1后，本地release 1.13.1会被删除 ，release代码会自动合并到本地 master 分支。</p><blockquote><p>如果想在github上保留release 1.13.1，则需要手动push该分支。</p></blockquote><ol start="3"><li>Push Tag</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git push origin 1.13.1</span><br><span class="line"><span class="comment">## or</span></span><br><span class="line">git push --tags</span><br></pre></td></tr></table></figure><h4 id="Hotfix-Branch"><a href="#Hotfix-Branch" class="headerlink" title="Hotfix Branch"></a>Hotfix Branch</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建hotfix分支</span></span><br><span class="line">git flow hotfix start &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交hotfix分支</span></span><br><span class="line">git flow hotfix finish &lt;name&gt;</span><br></pre></td></tr></table></figure><p>和release分支一样，提交时也会自动打上tag。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/12/git-workflow.html</a><br><a href="https://juejin.im/post/5c3e9b6df265da616c65d685" target="_blank" rel="noopener">https://juejin.im/post/5c3e9b6df265da616c65d685</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Git Flow重点解决的是由于源代码在开发过程中的各种冲突
      
    
    </summary>
    
      <category term="Git" scheme="https://sulangsss.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://sulangsss.github.io/tags/Git/"/>
    
      <category term="Flow" scheme="https://sulangsss.github.io/tags/Flow/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s MTU and MSS?</title>
    <link href="https://sulangsss.github.io/2019/04/12/Network/MTU/"/>
    <id>https://sulangsss.github.io/2019/04/12/Network/MTU/</id>
    <published>2019-04-12T07:40:00.000Z</published>
    <updated>2019-04-14T18:47:45.466Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>如果发送的TCP报文段很长的话，会在发送时发生分段，在接收端进行重组，同样IP数据报在长度超过一定值时也会发生分片，在接收端再将分片重组。</p><img src="/2019/04/12/Network/MTU/seven-layer-network-protocol.jpg"><img src="/2019/04/12/Network/MTU/layer-network-protocol-detail.png"><p>在7层网络协议中，MTU是数据链路层的概念。MTU限制的是数据链路层的payload，也就是上层协议的大小，例如IP，ICMP等。</p><h4 id="MTU-Maximum-Transmission-Unit"><a href="#MTU-Maximum-Transmission-Unit" class="headerlink" title="MTU - Maximum Transmission Unit"></a>MTU - Maximum Transmission Unit</h4><p>MTU 是链路层中的网络对数据帧的一个限制，依然以以太网为例，MTU为1500个字节。一个IP数据报在以太网中传输，如果它的长度大于该MTU值，就要进行分片传输，使得每片数据报的长度小于MTU。分片传输的IP数据报不一定按序到达，但IP首部中的信息能让这些数据报片按序组装。IP数据报的分片与重组是在网络层进完成的。</p><p><strong>如何确定 UDP 包的数据大小？</strong></p><ul><li>在链路层，由以太网的物理特性决定了数据帧的长度为 46＋18 ~ 1500＋18，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500（不包括帧头和帧尾），即MTU（Maximum Transmission Unit）为1500；</li><li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480；</li><li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；</li></ul><p>所以，在应用层，你的Data最大长度为1472。当我们的UDP包中的数据多于MTU(1472)时，发送方的IP层需要分片进行传输，而在接收方IP层则需要进行数据报重组，由于UDP是不可靠的传输协议，如果分片丢失导致重组失败，将导致UDP数据包被丢弃。</p><p>从上面的分析来看，在普通的局域网环境下，UDP的数据最大为1472字节最好(避免分片重组)。但在网络编程中，Internet中的路由器可能有设置成不同的值（小于默认值），Internet上的标准MTU值为576，所以Internet的UDP编程时数据长度最好在576－20－8＝548字节以内。</p><p><strong>如何查看路由的MTU值？</strong></p><p>Theory：ping程序使用ICMP报文，ICMP报文首部占8字节，IP数据报首部占20字节，因此在数据大小基础上加上28字节为MTU值。</p><ul><li>Windows: ping -f -l 1472 192.168.0.1</li><li>Linux: ping -c 1 -M do -s 1472 192.168.0.1</li></ul><hr><h4 id="MSS-Maxitum-Segment-Size"><a href="#MSS-Maxitum-Segment-Size" class="headerlink" title="MSS - Maxitum Segment Size"></a>MSS - Maxitum Segment Size</h4><p>MSS是TCP里的一个概念。MSS是TCP数据包每次能够传输的最大数据分段，TCP报文段的长度大于MSS时，要进行分段传输。</p><p>TCP协议在建立连接的时候通常要协商双方的MSS值，每一方都有用于通告它期望接收的MSS选项（MSS选项只出现在SYN报文段中，即TCP三次握手的前两次）。MSS的值一般为MTU值减去两个首部大小（需要减去IP数据包包头的大小20Bytes和TCP数据段的包头20Bytes），所以如果用链路层以太网，MSS的值往往为1460。而Internet上标准的MTU（最小的MTU，链路层网络为x2.5时）为576，那么如果不设置，则MSS的默认值就为536个字节。很多时候，MSS的值最好取512的倍数。TCP报文段的分段与重组是在运输层完成的。</p><blockquote><p>MSS = MTU - IP首部大小 - TCP首部大小。</p></blockquote><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>TCP分段的原因是MSS，IP分片的原因是MTU，由于一直有MSS &lt;= MTU，很明显，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。</p><p>再来看UDP数据报，由于UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p><p>另外，IP数据报分片后，只有第一片带有UDP首部或ICMP首部，其余的分片只有IP头部，到了端点后根据IP头部中的信息再网络层进行重组。而TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是向其他网络协议，在下一站就要进行重组。</p><p>最后一点，对IP分片的数据报来说，即使只丢失一片数据也要重新传整个数据报（既然有重传，说明运输层使用的是具有重传功能的协议，如TCP协议）。这是因为IP层本身没有超时重传机制，则由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p><hr><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>举一个最简单的场景，你在家用自己的笔记本上网，用的是路由器，路由器连接电信网络，然后访问了<a href="http://www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：" target="_blank" rel="noopener">www.baidu.com，从你的笔记本出发的一个以太网数据帧总共经过了以下路径：</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1500     1500                 1500    </span><br><span class="line">笔记本 -&gt; 路由器 -&gt; 电信机房  -&gt; 服务器</span><br></pre></td></tr></table></figure><p>假设现在我把笔记本的MTU最大值设置成了1700，然后发送了一个超大的ip数据包（2000），这时候在以外网传输的时候会被拆成2个包，一个1700，一个300，然后加上头信息进行传输。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1700     1500                 1500    </span><br><span class="line">笔记本 -&gt; 路由器 -&gt; 电信机房  -&gt; 服务器</span><br></pre></td></tr></table></figure><p>路由器接收到了一个1700的帧，发现大于自己设置的最大值：1500，如果IP包DF标志位为1，也就是不允许分包，那么路由器直接就把这个包丢弃了，根本就不会到达电信机房，也就到不了服务器了，所以，到这里我们就会发现，MTU其实就是在每一个节点的管控值，只要是大于这个值的数据帧，要么选择分片，要么直接丢弃。</p><hr><h3 id="为什么MTU通常设置为1500"><a href="#为什么MTU通常设置为1500" class="headerlink" title="为什么MTU通常设置为1500?"></a>为什么MTU通常设置为1500?</h3><p>其实一个标准的以太网数据帧大小是：1518，头信息有14字节，尾部校验和FCS占了4字节，所以真正留给上层协议传输数据的大小就是：1518 - 14 - 4 = 1500，那么，1518这个值又是从哪里来的呢？</p><p><strong>假设取一个更大的MTU值会怎么样？</strong></p><p>假设MTU值和IP数据包大小一致，一个IP数据包的大小是：65535，那么加上以太网帧头和为，一个以太网帧的大小就是：65535 + 14 + 4 = 65553，看起来似乎很完美，发送方也不需要拆包，接收方也不需要重组。</p><p>那么假设我们现在的带宽是：100Mbps，因为以太网帧是传输中的最小可识别单元，再往下就是0101所对应的光信号了，所以我们的一条带宽同时只能发送一个以太网帧。如果同时发送多个，那么对端就无法重组成一个以太网帧了，在100Mbps的带宽中（假设中间没有损耗），我们计算一下发送这一帧需要的时间：</p><p>( 65553 <em> 8 ) / ( 100 </em> 1024 * 1024 ) ≈ <strong>0.005(s)</strong></p><p>在100M网络下传输一帧就需要5ms，也就是说这5ms其他进程发送不了任何数据。如果是早先的电话拨号，网速只有2M的情况下：</p><p>( 65553 <em> 8 ) / ( 2 </em> 1024 * 1024 ) ≈ <strong>0.100(s)</strong></p><p>100ms，这简直是噩梦。其实这就像红绿灯，时间要设置合理，交替通行，不然同一个方向如果一直是绿灯，那么另一个方向就要堵成翔了。</p><p><strong>MTU值既然大了不行，那把MTU的值设置小一点可以么？</strong></p><p>假设MTU值设置为100，那么单个帧传输的时间，在2Mbps带宽下需要：</p><p>( 100 <em> 8 ) / ( 2 </em> 1024 <em> 1024 ) </em> 1000 ≈ 5(ms)</p><p>时间上已经能接受了，问题在于，不管MTU设置为多少，以太网头帧尾大小是固定的，都是14 + 4，所以在MTU为100的时候，一个以太网帧的传输效率为：</p><p>( 100 - 14 - 4 ) / 100 = <strong>82%</strong></p><p>写成公式就是：( T - 14 - 4 ) / T，当T趋于无穷大的时候，效率接近100%，也就是MTU的值越大，传输效率最高，但是基于上一点传输时间的问题，来个折中的选择吧，既然头加尾是18，那就凑个整来个1500，总大小就是1518，传输效率：</p><p>1500 / 1518 =  98.8%</p><p>100Mbps传输时间：( 1518 <em> 8 ) / ( 100 </em> 1024 <em> 1024 ) </em> 1000 = 0.11(ms)</p><p>2Mbps传输时间：( 1518 <em> 8 ) / ( 2 </em> 1024 <em> 1024 ) </em> 1000 = 5.79(ms)</p><blockquote><p>至于MUT的值最少是64，这个值是因为和以太网帧在半双工下的碰撞有关。</p></blockquote><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://www.zhihu.com/question/31460305" target="_blank" rel="noopener">https://www.zhihu.com/question/31460305</a><br>什么是MTU: <a href="https://www.vps234.com/vps-mtu-config-tutorials/" target="_blank" rel="noopener">https://www.vps234.com/vps-mtu-config-tutorials/</a><br>GCP and AWS MTU: <a href="http://www.cloudnetworkstuff.com/index.php/2018/04/19/multicloud-path-mtu-aws-gcp/" target="_blank" rel="noopener">http://www.cloudnetworkstuff.com/index.php/2018/04/19/multicloud-path-mtu-aws-gcp/</a><br>关于网络编程中MTU、TCP、UDP优化配置的一些总结: <a href="https://www.cnblogs.com/maowang1991/archive/2013/04/15/3022955.html" target="_blank" rel="noopener">https://www.cnblogs.com/maowang1991/archive/2013/04/15/3022955.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;如果发送的TCP报文段很长的话，会在发送时发生分段，在接收端
      
    
    </summary>
    
      <category term="Network" scheme="https://sulangsss.github.io/categories/Network/"/>
    
    
      <category term="Network" scheme="https://sulangsss.github.io/tags/Network/"/>
    
      <category term="MTU" scheme="https://sulangsss.github.io/tags/MTU/"/>
    
  </entry>
  
  <entry>
    <title>How select a best jwt cryptographic algorithm</title>
    <link href="https://sulangsss.github.io/2019/04/09/Security/JWT-Algorithm/"/>
    <id>https://sulangsss.github.io/2019/04/09/Security/JWT-Algorithm/</id>
    <published>2019-04-09T07:31:22.000Z</published>
    <updated>2019-04-08T21:46:51.911Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>The common data security concerns:</p><ul><li>Integrity: That data has not been tampered with</li><li>Authenticity: That the origin of the data can be verified</li><li>Non-repudiation: The origin of the data must be verifiable by others</li><li>Confidentiality: That data is kept secret from unauthorised parties and processes</li></ul><hr><h3 id="Digital-signatures"><a href="#Digital-signatures" class="headerlink" title="Digital signatures"></a>Digital signatures</h3><h4 id="Key-Type"><a href="#Key-Type" class="headerlink" title="Key Type"></a>Key Type</h4><ul><li>RSA</li><li>EC </li><li>OKP</li></ul><hr><h4 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h4><ul><li>RSA signature with PKCS #1 and SHA-2: RS256 RS384 RS512</li><li>RSA PSS signature with SHA-2: PS256</li><li>EC DSA signature with SHA-2:</li><li>Edwards-curve DSA signature with SHA-2:</li></ul><hr><h3 id="RSA、DSA、ECDSA-三者的区别"><a href="#RSA、DSA、ECDSA-三者的区别" class="headerlink" title="RSA、DSA、ECDSA 三者的区别"></a>RSA、DSA、ECDSA 三者的区别</h3><h4 id="EdDSA与ECDSA-的区别"><a href="#EdDSA与ECDSA-的区别" class="headerlink" title="EdDSA与ECDSA 的区别"></a>EdDSA与ECDSA 的区别</h4><p>ECDSA签名算法的安全性是比较依赖于安全的随机数生成算法的，如果随机数算法存在问题，使用了相同的k进行签名，那么攻击者是可以根据签名信息恢复私钥的，历史上也出过几次这样的事故，比如10年索尼的PS3私钥遭破解以及12年受Java某随机数生成库的影响造成的比特币被盗事件。所以说ECDSA签名在设计上还是存在一些问题的， 这也激励了新的EdDSA算法的出现。</p><p>EdDSA签名算法由Schnorr签名发展变化而来，可以在RFC8032中看到它的定义实现，由曲线和参数的选择不同又可以划分为Ed25519和Ed448算法，顾命思义，它们两分别是基于curve25519和curve448曲线，一般用的比较多的是Ed25519算法，相比Ed448而言运算速度要更快，秘钥与签名空间也较小，二者的使用场景还是有点区别。</p><p>Ed25519所使用的曲线由curve25519变换而来，curve25519是蒙哥马利曲线，经过变换得到Ed25519使用的扭爱德华曲线edwards25519，curve25519曲线的安全性是非常高的。</p><p>EdDSA的运算速度也比ECDSA算法要快很多，优势可以说是非常明显的，门罗币和zcash等加密货币已经将算法切换到了EdDSA了，目前其也被确认为下一代椭圆曲线算法。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://connect2id.com/products/nimbus-jose-jwt/algorithm-selection-guide" target="_blank" rel="noopener">https://connect2id.com/products/nimbus-jose-jwt/algorithm-selection-guide</a><br><a href="https://security.stackexchange.com/questions/194830/recommended-asymmetric-algorithms-for-jwt" target="_blank" rel="noopener">https://security.stackexchange.com/questions/194830/recommended-asymmetric-algorithms-for-jwt</a><br>数字签名算法介绍和区别: <a href="https://zhuanlan.zhihu.com/p/33195438" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33195438</a><br>算法性能测试: <a href="https://zhuanlan.zhihu.com/p/27615345" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/27615345</a><br>针对EdDSA的fault attack: <a href="https://www.anquanke.com/post/id/167018" target="_blank" rel="noopener">https://www.anquanke.com/post/id/167018</a><br>ECDSA Digital Signature Verification in Java: <a href="https://metamug.com/article/sign-verify-digital-signature-ecdsa-java.html" target="_blank" rel="noopener">https://metamug.com/article/sign-verify-digital-signature-ecdsa-java.html</a><br>Google Implementation Libary: <a href="https://github.com/google/tink" target="_blank" rel="noopener">https://github.com/google/tink</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;The common data security conce
      
    
    </summary>
    
      <category term="Security" scheme="https://sulangsss.github.io/categories/Security/"/>
    
    
      <category term="JWT" scheme="https://sulangsss.github.io/tags/JWT/"/>
    
      <category term="Security" scheme="https://sulangsss.github.io/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>JVM NewRatio与SurvivorRatio</title>
    <link href="https://sulangsss.github.io/2019/04/08/Java/JVM/Optimize/NewRatio%E4%B8%8ESurvivorRatio/"/>
    <id>https://sulangsss.github.io/2019/04/08/Java/JVM/Optimize/NewRatio与SurvivorRatio/</id>
    <published>2019-04-08T10:41:22.000Z</published>
    <updated>2019-04-08T12:52:59.604Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>-XX:NewRatio：新生代(Eden + 2*S)与老年代(不包括永久区)的比值。假如设置为4，4表示新生代:老年代 = 1:4，意思是老年代占 4/5。</p><img src="/2019/04/08/Java/JVM/Optimize/NewRatio与SurvivorRatio/pc1.png"><hr><p>-XX:SurvivorRatio：2个Survivor区和Eden区的比值，假如设置为8，8表示两个Survivor:Eden = 2:8，每个Survivor占 1/10。</p><img src="/2019/04/08/Java/JVM/Optimize/NewRatio与SurvivorRatio/pc2.png"><hr><h3 id="如何确定-NewRatio-和-SurvivorRatio-的最优值"><a href="#如何确定-NewRatio-和-SurvivorRatio-的最优值" class="headerlink" title="如何确定 NewRatio 和 SurvivorRatio 的最优值"></a>如何确定 NewRatio 和 SurvivorRatio 的最优值</h3><p>JVM Options：-server -Xmx4g -Xms4g -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+ExplicitGCInvokesConcurrent -XX:NewRatio=1 -XX:SurvivorRatio=5 -XX:MetaspaceSize=32m -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -verbose:gc -Xloggc:/opt/logs/gc/gc.lo</p><h4 id="初始化GC"><a href="#初始化GC" class="headerlink" title="初始化GC"></a>初始化GC</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2.459: [CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">2.459: [CMS-concurrent-preclean-start]</span><br><span class="line">2.462: [CMS-concurrent-preclean: 0.004/0.004 secs] [Times: user=0.02 sys=0.00, real=0.00 secs]</span><br><span class="line">2.462: [CMS-concurrent-abortable-preclean-start]</span><br><span class="line"> CMS: abort preclean due to time 7.523: [CMS-concurrent-abortable-preclean: 0.325/5.061 secs] [Times: user=7.40 sys=3.62, real=5.07 secs]</span><br><span class="line">7.524: [GC (CMS Final Remark) [YG occupancy: 1108516 K (1797568 K)]7.524: [Rescan (parallel) , 0.2107730 secs]7.735: [weak refs processing, 0.0000480 secs]7.735: [class unloading, 0.0094960 secs]7.744: [scrub symbol table, 0.0088638 secs]7.753: [scrub string table, 0.0007320 secs][1 CMS-remark: 0K(2097152K)] 1108516K(3894720K), 0.2317200 secs] [Times: user=1.71 sys=0.00, real=0.23 secs]</span><br><span class="line">7.756: [CMS-concurrent-sweep-start]</span><br><span class="line">7.756: [CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">7.756: [CMS-concurrent-reset-start]</span><br><span class="line">7.785: [CMS-concurrent-reset: 0.029/0.029 secs] [Times: user=0.01 sys=0.05, real=0.03 secs]</span><br></pre></td></tr></table></figure><ul><li>新生代大小：1797568 KB = 1755.43 MB，当前已经占用 1108516 KB = 1082 MB；</li></ul><h4 id="GC-Allocation-Failure"><a href="#GC-Allocation-Failure" class="headerlink" title="[GC (Allocation Failure)"></a>[GC (Allocation Failure)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 938.900: [ParNew: 1507180K-&gt;7820K(1797568K), 0.0121347 secs] 1594391K-&gt;95047K(3894720K), 0.0122274 secs] [Times: user=0.05 sys=0.00, real=0.01 secs]</span><br></pre></td></tr></table></figure><ul><li>[GC与[Full GC：表示GC类型；</li><li>[ParNew: 1507180K-&gt;7820K(1797568K)：[ParNew表示GC发生的区域，显示的区域与使用的GC收集器密切相关。1507180K 表示收集前该内存区域（新生代）已经使用的容量，820K(1797568K)表示GC后该内存区域已使用容量(该内存区域总容量)</li><li>1594391K-&gt;95047K(3894720K)：表示GC前堆已使用容量-&gt;GC后堆已使用容量(堆总容量)</li><li>估算出老年大大小：3894720K - 1507180K = 2387540K = 2331.58 MB</li></ul><p>433.231: [GC (Allocation Failure) 433.231: [ParNew: 2255562K-&gt;8497K(2696384K), 0.0112992 secs] 2342952K-&gt;95887K(3744960K), 0.0114044 secs] [Times: user=0.08 sys=0.00, real=0.01 secs]</p><p>老年代大小 = 1 GB</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://plumbr.io/handbook/gc-tuning-in-practice" target="_blank" rel="noopener">https://plumbr.io/handbook/gc-tuning-in-practice</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;-XX:NewRatio：新生代(Eden + 2*S)与老
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Java/JVM/"/>
    
      <category term="Optimize" scheme="https://sulangsss.github.io/categories/Java/JVM/Optimize/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
      <category term="NewRatio" scheme="https://sulangsss.github.io/tags/NewRatio/"/>
    
      <category term="SurvivorRatio" scheme="https://sulangsss.github.io/tags/SurvivorRatio/"/>
    
  </entry>
  
  <entry>
    <title>Kuberntes CPU Management Policies on Node</title>
    <link href="https://sulangsss.github.io/2019/04/07/Kubenetes/CPU-Management-Policies/"/>
    <id>https://sulangsss.github.io/2019/04/07/Kubenetes/CPU-Management-Policies/</id>
    <published>2019-04-07T07:35:06.000Z</published>
    <updated>2019-04-08T21:58:33.711Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="CPU-Management-Policies"><a href="#CPU-Management-Policies" class="headerlink" title="CPU Management Policies"></a>CPU Management Policies</h4><p>By default, the kubelet uses CFS quota to enforce pod CPU limits.  When the node runs many CPU-bound pods, the workload can move to different CPU cores depending on whether the pod is throttled and which CPU cores are available at scheduling time.  Many workloads are not sensitive to this migration and thus work fine without any intervention.</p><blockquote><p>CFS：The Completely Fair Scheduler (CFS) is a process scheduler which was merged into the 2.6.23 (October 2007) release of the Linux kernel and is the default scheduler. It handles CPU resource allocation for executing processes, and aims to maximize overall CPU utilization while also maximizing interactive performance. </p></blockquote><p>There are two supported policies:</p><ul><li><strong>none</strong>: the default, which represents the existing scheduling behavior.</li><li><strong>static</strong>: allows pods with certain resource characteristics to be granted increased CPU affinity and exclusivity on the node.</li></ul><blockquote><p>The CPU manager periodically writes resource updates through the CRI in order to reconcile in-memory CPU assignments with cgroupfs. The reconcile frequency is set through a new Kubelet configuration value –cpu-manager-reconcile-period. If not specified, it defaults to the same duration as –node-status-update-frequency</p></blockquote><hr><h3 id="None-policy"><a href="#None-policy" class="headerlink" title="None policy"></a>None policy</h3><p>The none policy explicitly enables the existing default CPU affinity scheme, providing no affinity beyond what the OS scheduler does automatically.  Limits on CPU usage for Guaranteed pods are enforced using <strong>CFS</strong> quota.</p><hr><h3 id="Static-policy"><a href="#Static-policy" class="headerlink" title="Static policy"></a>Static policy</h3><p>The static policy allows containers in Guaranteed pods with integer CPU requests access to exclusive CPUs on the node. This exclusivity is enforced using the cpuset cgroup controller.</p><hr><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="Case-BestEffort"><a href="#Case-BestEffort" class="headerlink" title="Case: BestEffort"></a>Case: BestEffort</h4><p>This pod runs in the <strong>BestEffort</strong> QoS class because no resource requests or limits are specified. It runs in the shared pool.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure><h4 id="Case-Burstable"><a href="#Case-Burstable" class="headerlink" title="Case: Burstable"></a>Case: Burstable</h4><ol><li>This pod runs in the <strong>Burstable</strong> QoS class because resource requests do not equal limits and the cpu quantity is not specified. It runs in the shared pool.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"100Mi"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>This pod runs in the <strong>Burstable</strong> QoS class because resource requests do not equal limits. It runs in the shared pool.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"100Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"1"</span></span><br></pre></td></tr></table></figure><h4 id="Case-Guaranteed"><a href="#Case-Guaranteed" class="headerlink" title="Case: Guaranteed"></a>Case: Guaranteed</h4><ol><li>This pod runs in the <strong>Guaranteed</strong> QoS class because requests are equal to limits. And the container’s resource limit for the CPU resource is an integer greater than or equal to one. <strong>The nginx container is granted 2 exclusive CPUs.</strong></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"2"</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"2"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>This pod runs in the <strong>Guaranteed</strong> QoS class because requests are equal to limits. But the container’s resource limit for the CPU resource is a fraction. It runs in the shared pool.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"1.5"</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"1.5"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>This pod runs in the <strong>Guaranteed</strong> QoS class because only limits are specified and requests are set equal to limits when not explicitly specified. And the container’s resource limit for the CPU resource is an integer greater than or equal to one. The nginx container is granted 2 exclusive CPUs.</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="string">"200Mi"</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="string">"2"</span></span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://en.wikipedia.org/wiki/Completely_Fair_Scheduler" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Completely_Fair_Scheduler</a><br><a href="https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/" target="_blank" rel="noopener">https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;CPU-Management-Policies&quot;&gt;
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/tags/Kubernetes/"/>
    
      <category term="CPU Policy" scheme="https://sulangsss.github.io/tags/CPU-Policy/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot ReactiveWeb</title>
    <link href="https://sulangsss.github.io/2019/04/06/SpringBoot/ReactiveWeb/Introduction-ReactiveWeb/"/>
    <id>https://sulangsss.github.io/2019/04/06/SpringBoot/ReactiveWeb/Introduction-ReactiveWeb/</id>
    <published>2019-04-06T06:21:22.000Z</published>
    <updated>2019-04-13T06:34:54.890Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Netty-Configuration"><a href="#Netty-Configuration" class="headerlink" title="Netty Configuration"></a>Netty Configuration</h3><ul><li><p>reactor.netty.ioWorkerCount</p><blockquote><p>Math.max(availableProcessors(), 4)</p></blockquote></li><li><p>reactor.netty.ioSelectCount</p></li><li><p>reactor.netty.pool.maxConnections</p></li></ul><ol><li>How to change them?</li></ol><blockquote><p>System.setProperty(“reactor.netty.ioWorkerCount”, “100”);</p></blockquote><hr><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h4 id="Why-concatMap-is-better-than-flatMap"><a href="#Why-concatMap-is-better-than-flatMap" class="headerlink" title="Why concatMap is better than flatMap?"></a>Why concatMap is better than flatMap?</h4><p>In its essence, flatMap is designed to merge elements from the multiple substreams that is executing at a time. It means that flatMap should have asynchronous streams underneath so, they could potentially process data on the multiple threads or that could be a several network calls. Subsequently, such expectations impact implementation a lot so flatMap should be able to handle data from the multiple streams (Threads) (means usage of concurrent data structures), enqueue elements if there is a draining from another stream (means additional memory allocation for Queues for each substream) and do not violate Reactive Streams specification rules (means really complex implementation). Counting all these facts and the fact that we replace a plain map operation (which is synchronous) onto the more convenient way of throwing an exception using Flux/Mono.error (which does not change synchronicity of execution) leads to the fact that we do not need such a complex operator and we can use much simpler concatMap which is designed for asynchronous handling of a single stream at a time and has a couple of optimization in order to handle scalar, cold stream. </p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://projectreactor.io/" target="_blank" rel="noopener">https://projectreactor.io/</a><br><a href="https://www.callicoder.com/spring-5-reactive-webclient-webtestclient-examples/" target="_blank" rel="noopener">https://www.callicoder.com/spring-5-reactive-webclient-webtestclient-examples/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Netty-Configuration&quot;&gt;&lt;a href=&quot;#Netty-Configuration&quot; class=&quot;headerlink&quot; title=&quot;Netty Configuration&quot;&gt;&lt;/a&gt;Netty Configuration&lt;/h3&gt;&lt;ul&gt;

      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/categories/Spring-Boot/"/>
    
      <category term="ReactiveWeb" scheme="https://sulangsss.github.io/categories/Spring-Boot/ReactiveWeb/"/>
    
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/tags/Spring-Boot/"/>
    
      <category term="ReativeWeb" scheme="https://sulangsss.github.io/tags/ReativeWeb/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot WebFlux</title>
    <link href="https://sulangsss.github.io/2019/04/05/SpringBoot/ReactiveWeb/WebFlux/"/>
    <id>https://sulangsss.github.io/2019/04/05/SpringBoot/ReactiveWeb/WebFlux/</id>
    <published>2019-04-05T06:21:22.000Z</published>
    <updated>2019-04-08T08:26:02.291Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="Unit-Test"><a href="#Unit-Test" class="headerlink" title="Unit Test"></a>Unit Test</h3><h4 id="Simple"><a href="#Simple" class="headerlink" title="Simple"></a>Simple</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@WebFluxTest(controllers = [OrderController::class])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    lateinit var client: WebTestClient</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">shouldPlaceLimitOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        client.post()</span><br><span class="line">                .uri(RestfulPath.addOrderPath)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .body(Mono.just(limit), ReqOrder::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">exchange</span>()</span></span><br><span class="line"><span class="class">                .<span class="title">expectStatus</span>()</span></span><br><span class="line"><span class="class">                .<span class="title">isOk</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><h4 id="Filter-Configration"><a href="#Filter-Configration" class="headerlink" title="Filter Configration"></a>Filter Configration</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@WebFluxTest(controllers = [OrderController::class])</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderControllerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    lateinit var client: WebTestClient</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> lateinit var context: ApplicationContext</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function">fun <span class="title">shouldPlaceLimitOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        val serverSpec = WebTestClient.bindToApplicationContext(context)</span><br><span class="line"></span><br><span class="line">        serverSpec.webFilter&lt;Nothing&gt;(AuthFilter())</span><br><span class="line">        val webTestClient = serverSpec.build()</span><br><span class="line"></span><br><span class="line">        val limit = TestingHelper.getLimit(</span><br><span class="line">                limitPrice = <span class="string">"1000.00"</span>,</span><br><span class="line">                quantity = <span class="string">"1"</span>,</span><br><span class="line">                contractId = Contract.BTCUSD.contractId</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        webTestClient.post()</span><br><span class="line">                .uri(RestfulPath.addOrderPath)</span><br><span class="line">                .contentType(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .accept(MediaType.APPLICATION_JSON_UTF8)</span><br><span class="line">                .body(Mono.just(limit), ReqOrder::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">exchange</span>()</span></span><br><span class="line"><span class="class">                .<span class="title">expectStatus</span>()</span></span><br><span class="line"><span class="class">                .<span class="title">isOk</span></span></span><br><span class="line"><span class="class">    &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://grokonez.com/testing/springboot-webflux-test-webfluxtest" target="_blank" rel="noopener">https://grokonez.com/testing/springboot-webflux-test-webfluxtest</a><br><a href="https://www.callicoder.com/spring-5-reactive-webclient-webtestclient-examples/" target="_blank" rel="noopener">https://www.callicoder.com/spring-5-reactive-webclient-webtestclient-examples/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;Unit-Test&quot;&gt;&lt;a href=&quot;#Unit-Test&quot; class=&quot;headerlink&quot; title=&quot;Unit Test&quot;&gt;&lt;/a&gt;Unit Test&lt;/h3&gt;&lt;h4 id=&quot;Simple&quot;&gt;&lt;a href=&quot;#Simple&quot; class=
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/categories/Spring-Boot/"/>
    
      <category term="ReactiveWeb" scheme="https://sulangsss.github.io/categories/Spring-Boot/ReactiveWeb/"/>
    
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/tags/Spring-Boot/"/>
    
      <category term="WebFlux" scheme="https://sulangsss.github.io/tags/WebFlux/"/>
    
      <category term="ReativeWeb" scheme="https://sulangsss.github.io/tags/ReativeWeb/"/>
    
  </entry>
  
  <entry>
    <title>wrk</title>
    <link href="https://sulangsss.github.io/2019/04/05/Testing/Stress/wrk/"/>
    <id>https://sulangsss.github.io/2019/04/05/Testing/Stress/wrk/</id>
    <published>2019-04-05T04:12:18.000Z</published>
    <updated>2019-04-04T10:06:44.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h4><ul><li>function setup(thread) 在创建线程时调用</li><li>function init(args) 在线程启动时调用</li><li>function request() 每个请求都会调用，特别说明，此函数调用频繁，所以不要在这里写入耗时的操作，如果复杂的请求，在init函数就构造好，这里直接引用。</li><li>function delay()</li><li>function response(status, headers, body) ，频繁调用。</li></ul><hr><h3 id="Experience"><a href="#Experience" class="headerlink" title="Experience"></a>Experience</h3><h4 id="参数执行对比"><a href="#参数执行对比" class="headerlink" title="参数执行对比"></a>参数执行对比</h4><p>机器配置：GCP 4 core, 3.6G Memory</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wrk -t4 -c400 -d1m -&gt; 32803.27</span><br><span class="line"></span><br><span class="line">wrk -t4 -c800 -d1m -&gt; 33405.82</span><br><span class="line"></span><br><span class="line">wrk -t8 -c400 -d1m -&gt; 34530.65</span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://juejin.im/post/5a59e74f5188257353008fea" target="_blank" rel="noopener">https://juejin.im/post/5a59e74f5188257353008fea</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;h4 id=&quot;Function&quot;&gt;&lt;a href=&quot;#Function&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Testing" scheme="https://sulangsss.github.io/categories/Testing/"/>
    
      <category term="Stress" scheme="https://sulangsss.github.io/categories/Testing/Stress/"/>
    
    
      <category term="Testing" scheme="https://sulangsss.github.io/tags/Testing/"/>
    
      <category term="Stress" scheme="https://sulangsss.github.io/tags/Stress/"/>
    
      <category term="wrk" scheme="https://sulangsss.github.io/tags/wrk/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot Configration</title>
    <link href="https://sulangsss.github.io/2019/04/04/SpringBoot/SpringBoot-Configuration/"/>
    <id>https://sulangsss.github.io/2019/04/04/SpringBoot/SpringBoot-Configuration/</id>
    <published>2019-04-04T09:21:22.000Z</published>
    <updated>2019-04-07T05:32:31.692Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Jetty-On-Web"><a href="#Jetty-On-Web" class="headerlink" title="Jetty On Web"></a>Jetty On Web</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Self4J-Conflict"><a href="#Self4J-Conflict" class="headerlink" title="Self4J Conflict"></a>Self4J Conflict</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Unite-Test"><a href="#Unite-Test" class="headerlink" title="Unite Test"></a>Unite Test</h3><h4 id="Configration-Application-Class"><a href="#Configration-Application-Class" class="headerlink" title="Configration Application Class"></a>Configration Application Class</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner::<span class="class"><span class="keyword">class</span>)</span></span><br><span class="line">@SpringBootTest(classes = [NoProducerApplication::class])</span><br><span class="line"><span class="comment">// or use @ContextConfiguration(classes = [MockApplication::class])</span></span><br><span class="line"></span><br><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Jetty-On-Web&quot;&gt;&lt;a href=&quot;#Jetty-On-Web&quot; class=&quot;headerlink&quot; title=&quot;Jetty On Web&quot;&gt;&lt;/a&gt;Jetty On Web&lt;/h3&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/categories/Spring-Boot/"/>
    
    
      <category term="Spring Boot" scheme="https://sulangsss.github.io/tags/Spring-Boot/"/>
    
      <category term="Configration" scheme="https://sulangsss.github.io/tags/Configration/"/>
    
  </entry>
  
  <entry>
    <title>Java AffinityThread</title>
    <link href="https://sulangsss.github.io/2019/04/03/Java/Advance/AffinityThread/"/>
    <id>https://sulangsss.github.io/2019/04/03/Java/Advance/AffinityThread/</id>
    <published>2019-04-03T07:55:06.000Z</published>
    <updated>2019-04-04T04:12:08.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="AffinityStrategies"><a href="#AffinityStrategies" class="headerlink" title="AffinityStrategies"></a>AffinityStrategies</h4><ul><li>ANY: Any free cpu.</li><li>SAME_CORE: Must be a cpu on the same core.</li><li>SAME_SOCKET: Must be a cpu on the same socket/chip but different core.</li><li>DIFFERENT_CORE: Must be a cpu on any other core (or socket)</li><li>DIFFERENT_SOCKET: Must be a cpu on any other socket.</li></ul><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="http://ifeve.com/thread-affinity/" target="_blank" rel="noopener">http://ifeve.com/thread-affinity/</a><br><a href="http://codingtutortips.blogspot.com/2012/01/java-thread-affinity-support-for-hyper.html" target="_blank" rel="noopener">http://codingtutortips.blogspot.com/2012/01/java-thread-affinity-support-for-hyper.html</a><br><a href="http://ifeve.com/java-context-switch/" target="_blank" rel="noopener">http://ifeve.com/java-context-switch/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;h4 id=&quot;AffinityStrategies&quot;&gt;&lt;a href=&quot;#AffinityStrategies&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="AffinityThread" scheme="https://sulangsss.github.io/tags/AffinityThread/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Pod on /dev/shm</title>
    <link href="https://sulangsss.github.io/2019/03/29/Kubenetes/Solution/PodShareMemoryOnNode/"/>
    <id>https://sulangsss.github.io/2019/03/29/Kubenetes/Solution/PodShareMemoryOnNode/</id>
    <published>2019-03-29T12:35:06.000Z</published>
    <updated>2019-03-29T12:46:08.886Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Linux共享内存机制"><a href="#Linux共享内存机制" class="headerlink" title="Linux共享内存机制"></a>Linux共享内存机制</h4><p>理想很美好，现实很残酷。首先要解决的问题是，有些组件Agent与业务Pod之间是通过共享内存通信的，这跟Kubernetes&amp;微服务的最佳实践背道而驰。</p><p>大家都知道，Kubernetes单个Pod内是共享IPC的，并且可以通过挂载Medium为Memory的EmptyDir Volume共享同一块内存Volume。</p><p>Linux共享内存的两种机制：</p><ul><li>POSIX共享内存（shm_open()、shm_unlink()）</li><li>System V共享内存（shmget()、shmat()、shmdt()）</li></ul><p>System V共享内存历史悠久，一般的UNIX系统上都有这套机制；而POSIX共享内存机制接口更加方便易用，一般是结合内存映射mmap使用。</p><p>mmap和System V共享内存的主要区别在于：</p><ul><li>sysv shm是持久化的，除非被一个进程明确的删除，否则它始终存在于内存里，直到系统关机；</li><li>mmap映射的内存在不是持久化的，如果进程关闭，映射随即失效，除非事先已经映射到了一个文件上。</li><li>/dev/shm 是Linux下sysv共享内存的默认挂载点。</li></ul><p>POSIX共享内存是基于tmpfs来实现的。实际上，不仅PSM(POSIX shared memory)，而且SSM(System V shared memory)在内核也是基于tmpfs实现的。</p><p>虽然System V与POSIX共享内存都是通过tmpfs实现，但是受的限制却不相同。也就是说 /proc/sys/kernel/shmmax只会影响SYS V共享内存，/dev/shm只会影响Posix共享内存 。实际上，System V与Posix共享内存本来就是使用的两个不同的tmpfs实例(instance)。</p><p>小结：</p><ul><li>POSIX共享内存与SYS V共享内存在内核都是通过tmpfs实现，但对应两个不同的tmpfs实例，相互独立。</li><li>通过/proc/sys/kernel/shmmax可以限制SYS V共享内存的最大值，通过/dev/shm可以限制POSIX共享内存的最大值(所有之和)。</li></ul><hr><h3 id="Pod-share-memory-on-same-node"><a href="#Pod-share-memory-on-same-node" class="headerlink" title="Pod share memory on same node"></a>Pod share memory on same node</h3><p>基础组件Agents DaemonSet部署后，Agents和业务Pod分别在同一个Node上不同的Pod，那么Kubernetes该如何支持这两种类型的共享内存机制呢？</p><img src="/2019/03/29/Kubenetes/Solution/PodShareMemoryOnNode/k8s-overview.png"><p>当然，安全性上做出了牺牲，但在非容器化之前IPC的隔离也是没有的，所以这一点是可以接受的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">demo-agent</span></span><br><span class="line"><span class="attr">  namespace:</span> <span class="string">kube-system</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    k8s-app:</span> <span class="string">demo-agent</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">demo-agent</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      annotations:</span></span><br><span class="line">        <span class="string">scheduler.alpha.kubernetes.io/critical-pod:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">demo-agent</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      tolerations:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">"AgentsDaemonSet"</span></span><br><span class="line"><span class="attr">        operator:</span> <span class="string">"Equal"</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">"YES"</span></span><br><span class="line"><span class="attr">        effect:</span> <span class="string">"NoSchedule"</span></span><br><span class="line"><span class="attr">      hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      hostIPC:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      nodeSelector:</span></span><br><span class="line"><span class="attr">        AgentsDaemonSet:</span> <span class="string">"YES"</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">demo-agent</span></span><br><span class="line"><span class="attr">        image:</span> <span class="attr">demo_agent:1.0</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/dev/shm</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">shm</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          limits:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">            memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">shm</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/dev/shm</span></span><br><span class="line"><span class="attr">          type:</span> <span class="string">Directory</span></span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://my.oschina.net/jxcdwangtao/blog/3006365" target="_blank" rel="noopener">https://my.oschina.net/jxcdwangtao/blog/3006365</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;Linux共享内存机制&quot;&gt;&lt;a href=&quot;#Li
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/categories/Kubernetes/"/>
    
      <category term="Solution" scheme="https://sulangsss.github.io/categories/Kubernetes/Solution/"/>
    
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/tags/Kubernetes/"/>
    
      <category term="Solution" scheme="https://sulangsss.github.io/tags/Solution/"/>
    
  </entry>
  
  <entry>
    <title>GCP Builder</title>
    <link href="https://sulangsss.github.io/2019/03/27/Kubenetes/GCP/Builder/"/>
    <id>https://sulangsss.github.io/2019/03/27/Kubenetes/GCP/Builder/</id>
    <published>2019-03-27T10:00:06.000Z</published>
    <updated>2019-04-24T03:37:31.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Custom-Building-Machine"><a href="#Custom-Building-Machine" class="headerlink" title="Custom Building Machine"></a>Custom Building Machine</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># view machine on region</span></span><br><span class="line">gcloud compute machine-types list | grep asia-east1</span><br><span class="line"></span><br><span class="line"><span class="comment"># build</span></span><br><span class="line">kbuild cloudbuild-dev.yaml --machine-type=n1-highcpu-8 .</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://cloud.google.com/compute/docs/machine-types?hl=zh-cn" target="_blank" rel="noopener">https://cloud.google.com/compute/docs/machine-types?hl=zh-cn</a><br><a href="https://cloud.google.com/cloud-build/docs/build-config" target="_blank" rel="noopener">https://cloud.google.com/cloud-build/docs/build-config</a><br><a href="https://docs.docker.com/engine/reference/run/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/run/</a></p></blockquote><h3 id="Trigger-rule"><a href="#Trigger-rule" class="headerlink" title="Trigger rule"></a>Trigger rule</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^release\/[0-9]&#123;1&#125;\.[0-9]&#123;1,2&#125;\.[0-9]&#123;1,2&#125;$|^hotfix|^master$</span><br></pre></td></tr></table></figure><h3 id="substitutions"><a href="#substitutions" class="headerlink" title="substitutions"></a>substitutions</h3><h4 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">steps:</span></span><br><span class="line"><span class="attr">images:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"gcr.io/$PROJECT_ID/image:$&#123;_IMAGE_VERSION&#125;"</span></span><br><span class="line"><span class="attr">substitutions:</span></span><br><span class="line"><span class="attr">  _IMAGE_VERSION:</span> <span class="string">"my_image"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Custom-Building-Machine&quot;&gt;&lt;a href=&quot;#Custom-Building-Machine&quot; class=&quot;headerlink&quot; title=&quot;Custom Building Machine&quot;&gt;&lt;/a&gt;Custom Building M
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/categories/Kubernetes/"/>
    
      <category term="GCP" scheme="https://sulangsss.github.io/categories/Kubernetes/GCP/"/>
    
    
      <category term="GCP" scheme="https://sulangsss.github.io/tags/GCP/"/>
    
      <category term="Builder" scheme="https://sulangsss.github.io/tags/Builder/"/>
    
  </entry>
  
  <entry>
    <title>Grafana Configuration</title>
    <link href="https://sulangsss.github.io/2019/03/25/Grafana/Grafana-Configuration/"/>
    <id>https://sulangsss.github.io/2019/03/25/Grafana/Grafana-Configuration/</id>
    <published>2019-03-25T11:13:06.000Z</published>
    <updated>2019-03-25T11:30:52.813Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Kuberntes-Configuration"><a href="#Kuberntes-Configuration" class="headerlink" title="Kuberntes Configuration"></a>Kuberntes Configuration</h3><h4 id="GF-PATHS-DATA-’-var-lib-grafana’-is-not-writable"><a href="#GF-PATHS-DATA-’-var-lib-grafana’-is-not-writable" class="headerlink" title="GF_PATHS_DATA=’/var/lib/grafana’ is not writable"></a>GF_PATHS_DATA=’/var/lib/grafana’ is not writable</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">grafana-core</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">grafana-core</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">"grafana-core-headless-service"</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">grafana-core</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">grafana-core</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      initContainers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">grafana-chown</span></span><br><span class="line"><span class="attr">          command:</span> <span class="string">["chown",</span> <span class="string">"-R"</span><span class="string">,</span> <span class="string">"472:472"</span><span class="string">,</span> <span class="string">"/var/lib/grafana"</span><span class="string">]</span></span><br><span class="line"><span class="attr">          image:</span> <span class="string">busybox</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">grafana-core-pvc</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">grafana-core</span></span><br><span class="line"><span class="attr">          image:</span> </span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">256</span><span class="string">M</span></span><br><span class="line"><span class="attr">            limits:</span></span><br><span class="line"><span class="attr">              memory:</span> <span class="number">1</span><span class="string">G</span></span><br><span class="line"><span class="attr">          ports:</span></span><br><span class="line"><span class="attr">            - containerPort:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">          volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">grafana-core-pvc</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/var/lib/grafana</span></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">    - metadata:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">grafana-core-pvc</span></span><br><span class="line"><span class="attr">      spec:</span></span><br><span class="line"><span class="attr">        accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">        storageClassName:</span> <span class="string">"pd-standard"</span></span><br><span class="line"><span class="attr">        resources:</span></span><br><span class="line"><span class="attr">          requests:</span></span><br><span class="line"><span class="attr">            storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Kuberntes-Configuration&quot;&gt;&lt;a href=&quot;#Kuberntes-Configuration&quot; class=&quot;headerlink&quot; title=&quot;Kuberntes Configuration&quot;&gt;&lt;/a&gt;Kuberntes Configu
      
    
    </summary>
    
      <category term="Grafana" scheme="https://sulangsss.github.io/categories/Grafana/"/>
    
    
      <category term="Grafana" scheme="https://sulangsss.github.io/tags/Grafana/"/>
    
      <category term="Configuration" scheme="https://sulangsss.github.io/tags/Configuration/"/>
    
  </entry>
  
  <entry>
    <title>Helm Installation</title>
    <link href="https://sulangsss.github.io/2019/03/23/Kubenetes/Helm/HelmIn-stallation/"/>
    <id>https://sulangsss.github.io/2019/03/23/Kubenetes/Helm/HelmIn-stallation/</id>
    <published>2019-03-23T12:15:19.000Z</published>
    <updated>2019-03-26T12:17:22.844Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="What-Is-Helm"><a href="#What-Is-Helm" class="headerlink" title="What Is Helm?"></a>What Is Helm?</h4><ul><li><strong>Helm</strong> is a Package Manager for Kubernetes.</li></ul><blockquote><p>NodeJS is to Kubernetes as NPM is to HELM!<br>Ruby is to Kubernetes as Gems are to HELM!<br>Swift is to Kubernetes as CocoaPods are to HELM!<br>Java is to Kubernetes as Maven is to HELM!</p></blockquote><ul><li><p>A <strong>Helm Chart</strong> is a Helm Package. This is the chart or “instructions” of how to put together your releasable package.</p></li><li><p><strong>Tiller</strong> is a server that runs inside your Kubernetes Cluster anytime you install Helm. Tiller manages installations of your Helm Charts. As Tiller installs containers into your Kubernetes Cluster on your behalf, security around this process should be a high priority for you.</p></li></ul><hr><h3 id="Installation-on-GKE"><a href="#Installation-on-GKE" class="headerlink" title="Installation on GKE"></a>Installation on GKE</h3><hr><h3 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h3><ul><li><p>helm install</p><blockquote><p>source from repository、tar、local and url<br>helm install stable/nginx<br>helm install ./nginx-1.2.3.tgz<br>helm install ./nginx<br>helm install <a href="https://example.com/charts/nginx-1.2.3.tgz" target="_blank" rel="noopener">https://example.com/charts/nginx-1.2.3.tgz</a></p></blockquote></li><li><p>helm search</p></li><li>helm ls</li><li>helm delete</li><li>helm rollback</li><li>helm repo update</li><li>helm status</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://medium.com/google-cloud/installing-helm-in-google-kubernetes-engine-7f07f43c536e" target="_blank" rel="noopener">https://medium.com/google-cloud/installing-helm-in-google-kubernetes-engine-7f07f43c536e</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;What-Is-Helm&quot;&gt;&lt;a href=&quot;#W
      
    
    </summary>
    
      <category term="Kuberntes" scheme="https://sulangsss.github.io/categories/Kuberntes/"/>
    
      <category term="Helm" scheme="https://sulangsss.github.io/categories/Kuberntes/Helm/"/>
    
    
      <category term="Kuberntes" scheme="https://sulangsss.github.io/tags/Kuberntes/"/>
    
      <category term="Installation" scheme="https://sulangsss.github.io/tags/Installation/"/>
    
      <category term="Helm" scheme="https://sulangsss.github.io/tags/Helm/"/>
    
  </entry>
  
  <entry>
    <title>Technology Stack On Testing</title>
    <link href="https://sulangsss.github.io/2019/03/17/Testing/TechStack/"/>
    <id>https://sulangsss.github.io/2019/03/17/Testing/TechStack/</id>
    <published>2019-03-17T06:49:22.000Z</published>
    <updated>2019-04-05T07:28:51.486Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="Performance-Metric"><a href="#Performance-Metric" class="headerlink" title="Performance Metric"></a>Performance Metric</h3><h4 id="业务指标"><a href="#业务指标" class="headerlink" title="业务指标"></a>业务指标</h4><ul><li><p>Response Time：业务响应时间，一般情况下，不同系统的业务响应时间期望值是不同的，１秒以内最佳；</p><ul><li><blockquote><p>平均响应时间：一段时间内响应时间的平均值。无法体现响应时间的波动情况。</p></blockquote></li><li><blockquote><p>中间响应时间：一段时间内响应时间的中间值，50%响应时间，有一半的服务器响应时间低于该值而另一半高于该值。</p></blockquote></li><li><blockquote><p>90%响应时间：一段时间内90%的事务响应时间比此数值要小。反应总体响应速度，和高于该值的10%超时率。是用来评估系统容量的重要指标之一。</p></blockquote></li><li><blockquote><p>最小响应时间：响应时间的最小值。反映服务最快处理能力。</p></blockquote></li><li><blockquote><p>最大响应时间：响应时间的最大值。反映服务器最慢处理能力。</p></blockquote></li></ul></li><li><p>Transaction Per Second(吞吐量)：业务处理能力，这个指标是衡量系统的处理能力的一个非常重要的指标，TPS可以参照同行业系统和结合具体业务，中小企业TPS值为50~1000笔/秒，银行TPS值为1000~50000笔/秒，淘宝TPS值为30000~300000笔/秒。</p><ul><li><blockquote><p>平均吞吐量：一段时间内吞吐量的平均值。无法体现吞吐量的瞬间变化。</p></blockquote></li><li><blockquote><p>峰值吞吐量：一段时间内吞吐量的最大值。是用来评估系统容量的重要指标之一。</p></blockquote></li><li><blockquote><p>最低吞吐量：一段时间内吞吐量的最小值。如果最小值接近0，说明系统有“卡”的现象。</p></blockquote></li><li><blockquote><p>70%的吞吐量集中区间：通过统计15%和85%的吞吐量边界值，计算出70%的吞吐量集中区间。区间越集中，吞吐量越稳定。</p></blockquote></li></ul></li><li><p>成功率：这个指标是衡量系统处于压力下，业务的成功率，一般业界成功率要大于99.6%。</p></li><li><p>Top Percentile(TP)：例如，TP90 = The tp90 is a minimum time under which 90% of requests have been served。</p><blockquote><p>TP50：指在一个时间段内（如5分钟），统计该方法每次调用所消耗的时间，并将这些时间按从小到大的顺序进行排序，取第50%的那个值作为TP50值；配置此监控指标对应的报警阀值后，需要保证在这个时间段内该方法所有调用的消耗时间至少有50%的值要小于此阀值，否则系统将会报警。<br>TP90，TP99，TP999与TP50值计算方式一致，它们分别代表着对方法的不同性能要求，TP50相对较低，TP90则比较高，TP99，TP999则对方法性能要求很高。<br>举例，假设现在有4次请求耗时分别为<br>10s，1000s，100s，2s<br>计算TP百分线的方法就是：</p><ol><li>先按升序排列 [2s, 10s, 100s, 1000s]</li><li>找到你需要用做统计的最后一个条目（向高取整）对应的数值，比如：TP50就是第 ceil(4<em>0.5)=2 个，即 10s ；TP90就是第 ceil(4</em>0.9)=4 个，即1000s。</li></ol></blockquote></li></ul><hr><h4 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h4><ul><li>Running：正在运行的进程。</li><li>Waiting：已准备就绪，等待运行的进程。</li><li>Blocked：因为等待某些事件完成而阻塞的进程，通常是在等待I/O，如Disk I/O，Network I/O等。</li></ul><p>这里的Running和Waiting共同构成Linux进程状态中的可运行状态(task_running)，而Blocked状态可以对应Linux进程状态中的不可中断睡眠状态(task_uninterruptible)。</p><p>Linux命令<strong>vmstat 1</strong>(1秒采集1次)可以读取相关状态数据，例如</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache      si   so    bi    bo   <span class="keyword">in</span>   cs    us  sy  id   wa st</span><br><span class="line"> 2  0     0   142064 374032 1951676    0    0     0     0    351  670    0  0   100   0  0</span><br></pre></td></tr></table></figure><ul><li>us：用户占用CPU的百分比</li><li>sy：系统(内核和中断)占用CPU的百分比</li><li>id：CPU空闲的百分比</li><li>r：表示运行队列(就是说多少个进程真的分配到CPU)，当这个值超过了CPU数目，就会出现CPU瓶颈了。</li><li>in：每秒CPU的中断次数，包括时间中断。</li><li>cs：秒上下文切换次数。</li><li>b：表示阻塞的进程。</li><li>si：每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。</li><li>so：每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。</li><li>bi：块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte。</li><li>bo：块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。</li><li>wt：等待IO</li></ul><p>性能测试指标中，CPU使用率通常用<strong>us + sy</strong>来计算，其可接受上限通常在70%~80%。另外需要注意的是，在测试过程中，如果sy的值长期大于25%，应该关注in(系统中断)和cs(上下文切换)的数值，并根据被测应用的实现逻辑来分析是否合理。</p><hr><ul><li><p>CPU Utilization Percentages(CPU使用率)：有进程处于Running状态的时间/总时间。</p><blockquote><p>在vmstat主要通过us、sys和id三列数据来体现。</p></blockquote></li><li><p>Processes on run queue(运行队列进程数)：Running状态 + Waiting状态的进程数，展示了正在运行和等待CPU资源的任务数，可以看作CPU的工作清单，是判断CPU资源是否成为瓶颈的重要依据。vmstat通过r的值来体现。</p><blockquote><p>如果r的值等于系统CPU总核数，则说明CPU已经满负荷。在负载测试中，其可接受上限通常不超过CPU核数的2倍。</p></blockquote></li><li><p>Context Switches(上下文切换)：简单来说，context指CPU寄存器和程序计数器在某时间点的内容，(进程)上下文切换即kernel挂起一个进程并将该进程此时的状态存储到内存，然后从内存中恢复下一个要执行的进程原来的状态到寄存器，从其上次暂停的执行代码开始继续执行至频繁的上下文切换将导致sy值增长。vmstat通过cs的值来体现</p></li><li><p>Load Average(平均负载)：在UNIX系统中，Load是对系统工作量的度量。Load取值有两种情况，多数UNIX系统取运行队列的值(vmstat输出的r)，而Linux系统取运行队列的值 + 处于task_uninterruptible状态的进程数(vmstat输出的b)，所以会出现CPU使用率不高但Load值很高的情况。</p><blockquote><p>Load Average就是在一段时间内的平均负载，系统工具top、uptime等提供1分钟、5分钟和15分钟的平均负载值。<br>top - 13:38:38 up 42 days,  3:25,  1 user,  load average: 0.80, 0.60, 0.53<br>当需要了解当前系统负载情况时，可以先查看Load average的值，如果系统持续处于高负载(如15分钟平均负载大于CPU总核数的两倍)，则查看vmstat的r值和b值来确认是CPU负荷重还是等待I/O的进程太多。</p></blockquote></li></ul><blockquote><p>sirq 占用比较高是什么原因？</p></blockquote><hr><h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>Memory资源也有三方面需要重点关注：<strong>Free Memory、Swap和Paging</strong>。</p><img src="/2019/03/17/Testing/TechStack/virtual-memory.jpg" title="进程状态"><p>物理内存和硬盘上的一块空间(SWAP)组合起来作为虚拟内存(Virtual Memory)为进程的运行提供一个连续的内存空间，这样的好处是进程可用的内存变大了，但需要注意的是，SWAP的读写速度远低于物理内存，并且物理内存和swap之间的数据交换会增加系统负担。</p><p>虚拟内存被分成页(x86系统默认页大小为4k)，内核读写虚拟内存以页为单位，当物理内存空间不足时，内存调度会将物理内存上不常使用的内存页数据存储到磁盘的SWAP空间，物理内存与swap空间之间的数据交换过程称为页面交换(Paging)。</p><ul><li><p>Free Memory(可用内存)：内存占用的直观数据，vmstat输出free的值，可用内存过小将影响整个系统的运行效率，对于稳定运行的系统，free可接受的范围通常应该大于物理内存的20%，即内存占用应该小于物理内存的80%。在压力测试时，系统内存资源的情况应该用可用内存结合页面交换情况来判断，如果可以内存很少，但页面交换也很少，此时可以认为内存资源还对系统性能构成严重影响。</p></li><li><p>Paging(页面交换)：页面交换包括从SWAP交换到内存和从内存交换到SWAP，如果系统出现频繁的页面交换，需要引起注意。可以从vmstat的si和so获取。</p><blockquote><p>si：每秒从SWAP读取到内存的数据大小；so：每秒从内存写入到SWAP的数据大小。</p></blockquote></li><li><p>Swap：可以从vmstat的swpd来获取当前SWAP空间的使用情况，应该和页面交换结合来分析，比如当swpd不为0，但si，so持续保持为0时，内存资源并没有成为系统的瓶颈。</p></li></ul><hr><h4 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h4><p>磁盘IO分为随机IO和顺序IO两种类型，在性能测试中应该先了解被测系统是偏向哪种类型。</p><ul><li>随机IO：随机读写数据，读写请求多，每次读写的数据量较小，其IO速度更依赖于磁盘每秒能IO次数(IOPS)。</li><li>顺序IO：顺序请求大量数据，读写请求个数相对较少，每次读写的数据量较大，顺序IO更重视每次IO的数据吞吐量。</li></ul><p>对于磁盘，首要关注使用率，IOPS和数据吞吐量，在Linux服务区，可以使用iostat来获取这些数据。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iostat -dxk 1</span><br><span class="line"><span class="comment"># -d 显示设备（磁盘）使用状态</span></span><br><span class="line"><span class="comment"># -k 某些使用block为单位的列强制使用Kilobytes为单位</span></span><br><span class="line"><span class="comment"># 1 表示刷新间隔为1秒</span></span><br><span class="line"></span><br><span class="line">Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># simple top-like I/O monitor</span></span><br><span class="line"><span class="comment"># apt install iotop</span></span><br><span class="line">iotop</span><br><span class="line">TID  PRIO  USER   DISK READ  DISK WRITE   SWAPIN   IO&gt;   COMMAND</span><br><span class="line"></span><br><span class="line"><span class="comment"># --version #显示版本号</span></span><br><span class="line"><span class="comment"># -h, --help #显示帮助信息</span></span><br><span class="line"><span class="comment"># -o, --only #显示进程或者线程实际上正在做的I/O，而不是全部的，可以随时切换按o</span></span><br><span class="line"><span class="comment"># -b, --batch #运行在非交互式的模式</span></span><br><span class="line"><span class="comment"># -n NUM, --iter=NUM #在非交互式模式下，设置显示的次数，</span></span><br><span class="line"><span class="comment"># -d SEC, --delay=SEC #设置显示的间隔秒数，支持非整数值</span></span><br><span class="line"><span class="comment"># -p PID, --pid=PID #只显示指定PID的信息</span></span><br><span class="line"><span class="comment"># -u USER, --user=USER #显示指定的用户的进程的信息</span></span><br><span class="line"><span class="comment"># -P, --processes #只显示进程，一般为显示所有的线程</span></span><br><span class="line"><span class="comment"># -a, --accumulated #显示从iotop启动后每个线程完成了的IO总数</span></span><br><span class="line"><span class="comment"># -k, --kilobytes #以千字节显示</span></span><br><span class="line"><span class="comment"># -t, --time #在每一行前添加一个当前的时间</span></span><br><span class="line"><span class="comment"># -q, --quiet #suppress some lines of header (implies --batch). This option can be specified up to three times to remove header lines.</span></span><br><span class="line"><span class="comment"># -q column names are only printed on the first iteration,</span></span><br><span class="line"><span class="comment"># -qq column names are never printed,</span></span><br><span class="line"><span class="comment"># -qqq the I/O summary is never printed.</span></span><br><span class="line"><span class="comment"># https://www.cnblogs.com/legendbaby/p/5056967.html</span></span><br></pre></td></tr></table></figure><p><strong>重点性能指标</strong></p><ul><li><p>%util：在统计时间内，所有处理IO时间除以总共统计时间。</p><blockquote><p>例如如果统计间隔1秒，该设备有0.8秒在处理IO，而0.2秒闲置，那么该设备的%util = 0.8/1 = 80%，所以该参数暗示了设备的繁忙程度。<br>一般地，如果该参数是100%表示设备已经接近满负荷运行了（当然如果是多磁盘，即使%util是100%，因为磁盘的并发能力，所以磁盘使用未必就到了瓶颈）。</p></blockquote></li><li><p>await：每一个IO请求的处理的平均时间（单位是微秒毫秒）。这里可以理解为IO的响应时间，一般地系统IO响应时间应该低于5ms，如果大于10ms就比较大了。</p><blockquote><p>这个时间包括了队列时间和服务时间，也就是说，一般情况下，await大于svctm，它们的差值越小，则说明队列时间越短，反之差值越大，队列时间越长，说明系统出了问题。</p></blockquote></li><li>svctm：表示平均每次设备I/O操作的服务时间（以毫秒为单位）。如果svctm的值与await很接近，表示几乎没有I/O等待，磁盘性能很好，如果await的值远高于svctm的值，则表示I/O队列等待太长，       系统上运行的应用程序将变慢。</li></ul><hr><ul><li>kB_read/s：每秒从设备读取的数据量；</li><li>kB_wrtn/s：每秒向设备写入的数据量；</li><li>kB_read：读取的总数据量；</li><li>kB_wrtn：写入的总数量数据量；<br>-rrqm/s：每秒这个设备相关的读取请求有多少被Merge了（当系统调用需要读取数据的时候，VFS将请求发到各个FS，如果FS发现不同的读取请求读取的是相同Block的数据，FS会将这个请求合并Merge）；wrqm/s：每秒这个设备相关的写入请求有多少被Merge了。</li><li>rsec/s：每秒读取的扇区数；</li><li>wsec/：每秒写入的扇区数。</li><li>rKB/s：The number of read requests that were issued to the device per second；</li><li>wKB/s：The number of write requests that were issued to the device per second；</li><li>avgrq-sz：平均请求扇区的大小</li><li>avgqu-sz：是平均请求队列的长度。毫无疑问，队列长度越短越好。    </li></ul><hr><ul><li><p>IOPS：每秒处理读/写请求的数量，即iostat输出中的r/s和w/s，个人PC的机械硬盘IOPS一般在100左右，而各种公有云/私有云的普通服务器，也只在百这个数量级。</p><blockquote><p>预先获取到所用服务区的IOPS能力，然后在性能测试中监控试试的IOPS数据，来衡量当前的磁盘是否能满足系统的IO需求。</p></blockquote></li><li><p>数据吞吐量：每秒读/写的数据大小，即iostat输出中的rkB/s和wkB/s，通常磁盘的数据吞吐量与IO类型有直接关系，顺序IO的吞吐能力明显优与随机读写，可以预先测得磁盘在随机IO和顺序IO下的吞吐量，以便于测试时监控到的数据进行比较衡量。</p></li></ul><hr><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><p>网络本身是系统中一个非常复杂的部分，但常规的服务端性能测试通常放在一个局域网进行，因为我们首先关注被测系统自身的性能表现，并且需要保证能在较少的成本下发起足够大的压力。</p><p>因此对于多数系统的性能测试，我们主要关注<strong>网络吞吐量</strong>即可，对于稳定运行的系统，需要为被测场景外的业务流出足够的带宽；在压力测试过程中，需要注意瓶颈可能来自于带宽。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptraf -d eth0</span><br></pre></td></tr></table></figure><hr><h3 id="Performance-Tools"><a href="#Performance-Tools" class="headerlink" title="Performance Tools"></a>Performance Tools</h3><ul><li>wrk</li><li>ab</li><li>locust</li><li>Jmeter</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><blockquote><p><a href="https://testerhome.com/topics/17068" target="_blank" rel="noopener">https://testerhome.com/topics/17068</a><br><a href="https://zhuanlan.zhihu.com/p/22070862" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/22070862</a><br><a href="http://www.aloo.me/2016/08/01/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%94%AE%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%B5%85%E6%9E%90/" target="_blank" rel="noopener">http://www.aloo.me/2016/08/01/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B8%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%85%B3%E9%94%AE%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87%E6%B5%85%E6%9E%90/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;Performance-Metric&quot;&gt;&lt;a href=&quot;#Performance-Metric&quot; class=&quot;headerlink&quot; title=&quot;Performance Metric&quot;&gt;&lt;/a&gt;Performance Metric&lt;/h3&gt;&lt;h4 
      
    
    </summary>
    
      <category term="Testing" scheme="https://sulangsss.github.io/categories/Testing/"/>
    
    
      <category term="TechStack" scheme="https://sulangsss.github.io/tags/TechStack/"/>
    
      <category term="Testing" scheme="https://sulangsss.github.io/tags/Testing/"/>
    
  </entry>
  
  <entry>
    <title>Influxdb Command</title>
    <link href="https://sulangsss.github.io/2019/03/16/DB/Influxdb/Influxdb-Command/"/>
    <id>https://sulangsss.github.io/2019/03/16/DB/Influxdb/Influxdb-Command/</id>
    <published>2019-03-16T07:00:27.000Z</published>
    <updated>2019-03-16T07:19:57.878Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Basic-Command"><a href="#Basic-Command" class="headerlink" title="Basic Command"></a>Basic Command</h3><h4 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">influx -precision rfc3339</span><br><span class="line"></span><br><span class="line"><span class="comment"># The -precision argument specifies the format/precision of any returned timestamps</span></span><br><span class="line"><span class="comment"># rfc3339 tells InfluxDB to return timestamps in RFC3339 format (YYYY-MM-DDTHH:MM:SS.nnnnnnnnnZ)</span></span><br></pre></td></tr></table></figure><h4 id="Auth"><a href="#Auth" class="headerlink" title="Auth"></a>Auth</h4><ol><li><p>Auth User</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth</span><br></pre></td></tr></table></figure></li><li><p>Authenticate Telegraf requests to InfluxDB</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## Write timeout (for the InfluxDB client), formatted as a string.</span></span><br><span class="line"><span class="comment">## If not provided, will default to 5s. 0s means no timeout (not recommended).</span></span><br><span class="line">timeout = <span class="string">"5s"</span></span><br><span class="line">username = <span class="string">"telegraf"</span> <span class="comment">#💥</span></span><br><span class="line">password = <span class="string">"metricsmetricsmetricsmetrics"</span> <span class="comment">#💥</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Basic-Command&quot;&gt;&lt;a href=&quot;#Basic-Command&quot; class=&quot;headerlink&quot; title=&quot;Basic Command&quot;&gt;&lt;/a&gt;Basic Command&lt;/h3&gt;&lt;h4 id=&quot;Connect&quot;&gt;&lt;a href=&quot;#Co
      
    
    </summary>
    
      <category term="DB" scheme="https://sulangsss.github.io/categories/DB/"/>
    
      <category term="Influxdb" scheme="https://sulangsss.github.io/categories/DB/Influxdb/"/>
    
    
      <category term="Command" scheme="https://sulangsss.github.io/tags/Command/"/>
    
      <category term="Influxdb" scheme="https://sulangsss.github.io/tags/Influxdb/"/>
    
  </entry>
  
  <entry>
    <title>Multi-container pods and container communication in Kubernetes</title>
    <link href="https://sulangsss.github.io/2019/03/16/Kubenetes/MultipleContainerOnDeployment/"/>
    <id>https://sulangsss.github.io/2019/03/16/Kubenetes/MultipleContainerOnDeployment/</id>
    <published>2019-03-16T06:00:27.000Z</published>
    <updated>2019-03-16T06:36:03.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.mirantis.com/blog/multi-container-pods-and-container-communication-in-kubernetes/" target="_blank" rel="noopener">https://www.mirantis.com/blog/multi-container-pods-and-container-communication-in-kubernetes/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.mirantis.com/bl
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/categories/Kubernetes/"/>
    
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/tags/Kubernetes/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sulangsss.github.io/2019/02/13/Security/Web/DDoS/"/>
    <id>https://sulangsss.github.io/2019/02/13/Security/Web/DDoS/</id>
    <published>2019-02-13T04:29:10.326Z</published>
    <updated>2019-02-13T04:29:10.326Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
</feed>
