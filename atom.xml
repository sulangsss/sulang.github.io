<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Big Boy Blog -  Tech Articls &amp; Notes</title>
  
  <subtitle>Python Java Android Django Web -&gt; sulang357159@gmail.com</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulangsss.github.io/"/>
  <updated>2019-07-15T05:58:58.713Z</updated>
  <id>https://sulangsss.github.io/</id>
  
  <author>
    <name>Jason - sulang357159@163.com</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker JDK Dockerfile</title>
    <link href="https://sulangsss.github.io/2019/07/15/Docker/Dockerfile/Java-jdk/"/>
    <id>https://sulangsss.github.io/2019/07/15/Docker/Dockerfile/Java-jdk/</id>
    <published>2019-07-15T05:28:19.000Z</published>
    <updated>2019-07-15T05:58:58.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Alibaba-Dragonwell"><a href="#Alibaba-Dragonwell" class="headerlink" title="Alibaba Dragonwell"></a>Alibaba Dragonwell</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:<span class="number">7</span></span><br><span class="line"></span><br><span class="line">ADD java /opt/java</span><br><span class="line"></span><br><span class="line">WORKDIR /opt/java</span><br><span class="line"></span><br><span class="line">RUN alternatives --install /usr/bin/java java /opt/java/bin/java <span class="number">2</span> \</span><br><span class="line">    &amp;&amp; alternatives --install /usr/bin/jar jar /opt/java/bin/jar <span class="number">2</span> \</span><br><span class="line">    &amp;&amp; alternatives --install /usr/bin/javac javac /opt/java/bin/javac <span class="number">2</span> \</span><br><span class="line">    &amp;&amp; alternatives --set java /opt/java/bin/java \</span><br><span class="line">    &amp;&amp; alternatives --set jar /opt/java/bin/jar \</span><br><span class="line">    &amp;&amp; alternatives --set javac /opt/java/bin/javac \</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Alibaba-Dragonwell&quot;&gt;&lt;a href=&quot;#Alibaba-Dragonwell&quot; class=&quot;headerlink&quot; title=&quot;Alibaba Dragonwell&quot;&gt;&lt;/a&gt;Alibaba Dragonwell&lt;/h3&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Docker" scheme="https://sulangsss.github.io/categories/Docker/"/>
    
      <category term="Dockerfile" scheme="https://sulangsss.github.io/categories/Docker/Dockerfile/"/>
    
    
      <category term="Docker" scheme="https://sulangsss.github.io/tags/Docker/"/>
    
      <category term="Dockerfile" scheme="https://sulangsss.github.io/tags/Dockerfile/"/>
    
      <category term="JDK" scheme="https://sulangsss.github.io/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>Java Date</title>
    <link href="https://sulangsss.github.io/2019/07/13/Java/Date/"/>
    <id>https://sulangsss.github.io/2019/07/13/Java/Date/</id>
    <published>2019-07-13T03:52:22.000Z</published>
    <updated>2019-07-16T07:22:08.876Z</updated>
    
    <content type="html"><![CDATA[<hr><h3 id="LocalDate-和-LocalTime"><a href="#LocalDate-和-LocalTime" class="headerlink" title="LocalDate 和 LocalTime"></a>LocalDate 和 LocalTime</h3><p>Java 8一个新增的重要特性就是引入了新的时间和日期API，它们被包含在java.time包中。借助新的时间和日期API可以以更简洁的方法处理时间和日期。</p><p>在Java 8之前，所有关于时间和日期的API都存在各种使用方面的缺陷，主要有：</p><ol><li>Java的java.util.Date和java.util.Calendar类易用性差，不支持时区，而且他们都不是线程安全的；</li><li>用于格式化日期的类DateFormat被放在java.text包中，它是一个抽象类，所以我们需要实例化一个SimpleDateFormat对象来处理日期格式化，并且DateFormat也是非线程安全，这意味着如果你在多线程程序中调用同一个DateFormat对象，会得到意想不到的结果。</li><li>对日期的计算方式繁琐，而且容易出错，因为月份是从0开始的，从Calendar中获取的月份需要加一才能表示当前月份。</li></ol><blockquote><p>在阿里巴巴规约手册里，强制规定SimpleDateFormat是线程不安全的类，当定义为静态变量时，必须加锁处理。忽略线程安全问题，正是大多数Java初学者在进行时间转化时容易踩坑的点。<br>Java 8的日期和时间类包含LocalDate、LocalTime、Instant、Duration以及Period，这些类都包含在java.time包中。</p></blockquote><p>LocalDate类表示一个具体的日期，但不包含具体时间，也不包含时区信息。可以通过LocalDate的静态方法of()创建一个实例，LocalDate也包含一些方法用来获取年份，月份，天，星期几等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">4</span>);     <span class="comment">// 初始化一个日期：2017-01-04</span></span><br><span class="line"><span class="keyword">int</span> year = localDate.getYear();                     <span class="comment">// 年份：2017</span></span><br><span class="line">Month month = localDate.getMonth();                 <span class="comment">// 月份：JANUARY</span></span><br><span class="line"><span class="keyword">int</span> dayOfMonth = localDate.getDayOfMonth();         <span class="comment">// 月份中的第几天：4</span></span><br><span class="line">DayOfWeek dayOfWeek = localDate.getDayOfWeek();     <span class="comment">// 一周的第几天：WEDNESDAY</span></span><br><span class="line"><span class="keyword">int</span> length = localDate.lengthOfMonth();             <span class="comment">// 月份的天数：31</span></span><br><span class="line"><span class="keyword">boolean</span> leapYear = localDate.isLeapYear();          <span class="comment">// 是否为闰年：false</span></span><br><span class="line"></span><br><span class="line">LocalDate now = LocalDate.now();                    <span class="comment">// 调用静态方法now()来获取当前日期</span></span><br></pre></td></tr></table></figure><p>LocalTime和LocalDate类似，他们之间的区别在于LocalDate不包含具体时间，而LocalTime包含具体时间，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);     <span class="comment">// 初始化一个时间：17:23:52</span></span><br><span class="line"><span class="keyword">int</span> hour = localTime.getHour();                     <span class="comment">// 时：17</span></span><br><span class="line"><span class="keyword">int</span> minute = localTime.getMinute();                 <span class="comment">// 分：23</span></span><br><span class="line"><span class="keyword">int</span> second = localTime.getSecond();                 <span class="comment">// 秒：52</span></span><br></pre></td></tr></table></figure><hr><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime类是LocalDate和LocalTime的结合体，可以通过of()方法直接创建，也可以调用LocalDate的atTime()方法或LocalTime的atDate()方法将LocalDate或LocalTime合并成一个LocalDateTime：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime ldt1 = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>, <span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line"></span><br><span class="line">LocalDate localDate = LocalDate.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">4</span>);</span><br><span class="line">LocalTime localTime = LocalTime.of(<span class="number">17</span>, <span class="number">23</span>, <span class="number">52</span>);</span><br><span class="line">LocalDateTime ldt2 = localDate.atTime(localTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  LocalDateTime也提供用于向LocalDate 和 LocalTime的 转化</span></span><br><span class="line">LocalDate date = ldt1.toLocalDate();</span><br><span class="line">LocalTime time = ldt1.toLocalTime();</span><br></pre></td></tr></table></figure><hr><h3 id="TemporalAdjusters"><a href="#TemporalAdjusters" class="headerlink" title="TemporalAdjusters"></a>TemporalAdjusters</h3><p>增加或减少日期操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);          <span class="comment">// 2017-01-05</span></span><br><span class="line"></span><br><span class="line">LocalDate date1 = date.withYear(<span class="number">2016</span>);              <span class="comment">// 修改为 2016-01-05</span></span><br><span class="line">LocalDate date2 = date.withMonth(<span class="number">2</span>);                <span class="comment">// 修改为 2017-02-05</span></span><br><span class="line">LocalDate date3 = date.withDayOfMonth(<span class="number">1</span>);           <span class="comment">// 修改为 2017-01-01</span></span><br><span class="line"></span><br><span class="line">LocalDate date4 = date.plusYears(<span class="number">1</span>);                <span class="comment">// 增加一年 2018-01-05</span></span><br><span class="line">LocalDate date5 = date.minusMonths(<span class="number">2</span>);              <span class="comment">// 减少两个月 2016-11-05</span></span><br><span class="line">LocalDate date6 = date.plus(<span class="number">5</span>, ChronoUnit.DAYS);    <span class="comment">// 增加5天 2017-01-10</span></span><br></pre></td></tr></table></figure><p>些时候我们要面临更复杂的时间操作，比如将时间调到下一个工作日，或者是下个月的最后一天，这时候我们可以使用with()方法的另一个重载方法，它接收一个TemporalAdjuster参数，可以使我们更加灵活的调整日期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.time.temporal.TemporalAdjusters.*;</span><br><span class="line"><span class="comment">//  dayOfWeekInMonth    返回同一个月中每周的第几天</span></span><br><span class="line"><span class="comment">//  firstDayOfMonth 返回当月的第一天</span></span><br><span class="line"><span class="comment">//  firstDayOfNextMonth 返回下月的第一天</span></span><br><span class="line"><span class="comment">//  firstDayOfNextYear 返回下一年的第一天</span></span><br><span class="line"><span class="comment">//  firstDayOfYear 返回本年的第一天</span></span><br><span class="line"><span class="comment">//  firstInMonth 返回同一个月中第一个星期几</span></span><br><span class="line"><span class="comment">//  lastDayOfMonth 返回当月的最后一天</span></span><br><span class="line"><span class="comment">//  lastDayOfNextMonth 返回下月的最后一天</span></span><br><span class="line"><span class="comment">//  lastDayOfNextYear 返回下一年的最后一天</span></span><br><span class="line"><span class="comment">//  lastDayOfYear 返回本年的最后一天</span></span><br><span class="line"><span class="comment">//  lastInMonth 返回同一个月中最后一个星期几</span></span><br><span class="line"><span class="comment">//  next / previous 返回后一个/前一个给定的星期几</span></span><br><span class="line"><span class="comment">//  nextOrSame / previousOrSame 返回后一个/前一个给定的星期几，如果这个值满足条件，直接返回</span></span><br><span class="line"></span><br><span class="line">LocalDate date7 = date.with(nextOrSame(DayOfWeek.SUNDAY));      <span class="comment">// 返回下一个距离当前时间最近的星期日</span></span><br><span class="line">LocalDate date9 = date.with(lastInMonth(DayOfWeek.SATURDAY));   <span class="comment">// 返回本月最后一个星期六</span></span><br></pre></td></tr></table></figure><p>如果上面表格中列出的方法不能满足你的需求，你还可以创建自定义的TemporalAdjuster接口的实现，TemporalAdjuster也是一个函数式接口，所以我们可以使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TemporalAdjuster</span> </span>&#123;</span><br><span class="line">    <span class="function">Temporal <span class="title">adjustInto</span><span class="params">(Temporal temporal)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  比如给定一个日期，计算该日期的下一个工作日（不包括星期六和星期天）：</span></span><br><span class="line">LocalDate date = LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">date.with(temporal -&gt; &#123;</span><br><span class="line">    <span class="comment">// 当前日期</span></span><br><span class="line">    DayOfWeek dayOfWeek = DayOfWeek.of(temporal.get(ChronoField.DAY_OF_WEEK));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正常情况下，每次增加一天</span></span><br><span class="line">    <span class="keyword">int</span> dayToAdd = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期五，增加三天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.FRIDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是星期六，增加两天</span></span><br><span class="line">    <span class="keyword">if</span> (dayOfWeek == DayOfWeek.SATURDAY) &#123;</span><br><span class="line">        dayToAdd = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temporal.plus(dayToAdd, ChronoUnit.DAYS);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><hr><h3 id="DateTimeFormatter"><a href="#DateTimeFormatter" class="headerlink" title="DateTimeFormatter"></a>DateTimeFormatter</h3><p>它被包含在java.time.format包中，Java 8的日期类有一个format()方法用于将日期格式化为字符串，该方法接收一个DateTimeFormatter类型参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dateTime = LocalDateTime.now();</span><br><span class="line">String strDate1 = dateTime.format(DateTimeFormatter.BASIC_ISO_DATE);    <span class="comment">// 20170105</span></span><br><span class="line">String strDate2 = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);    <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate3 = dateTime.format(DateTimeFormatter.ISO_LOCAL_TIME);    <span class="comment">// 14:20:16.998</span></span><br><span class="line">String strDate4 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));   <span class="comment">// 2017-01-05</span></span><br><span class="line">String strDate5 = dateTime.format(DateTimeFormatter.ofPattern(<span class="string">"今天是：YYYY年 MMMM DD日 E"</span>, Locale.CHINESE)); <span class="comment">// 今天是：2017年 一月 05日 星期四</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  同样，日期类也支持将一个字符串解析成一个日期对象</span></span><br><span class="line">String strDate6 = <span class="string">"2017-01-05"</span>;</span><br><span class="line">String strDate7 = <span class="string">"2017-01-05 12:30:05"</span>;</span><br><span class="line"></span><br><span class="line">LocalDate date = LocalDate.parse(strDate6, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd"</span>));</span><br><span class="line">LocalDateTime dateTime1 = LocalDateTime.parse(strDate7, DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="ZoneId"><a href="#ZoneId" class="headerlink" title="ZoneId"></a>ZoneId</h3><p>Java 8中的时区操作被很大程度上简化了，新的时区类java.time.ZoneId是原有的java.util.TimeZone类的替代品。ZoneId对象可以通过ZoneId.of()方法创建，也可以通过ZoneId.systemDefault()获取系统默认时区：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ZoneId shanghaiZoneId = ZoneId.of(<span class="string">"Asia/Shanghai"</span>);</span><br><span class="line">ZoneId systemZoneId = ZoneId.systemDefault();</span><br></pre></td></tr></table></figure><p>of()方法接收一个“区域/城市”的字符串作为参数，你可以通过getAvailableZoneIds()方法获取所有合法的“区域/城市”字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; zoneIds = ZoneId.getAvailableZoneIds();</span><br><span class="line"></span><br><span class="line"><span class="comment">//  对于老的时区类TimeZone，Java 8也提供了转化方法</span></span><br><span class="line">ZoneId oldToNewZoneId = TimeZone.getDefault().toZoneId();</span><br></pre></td></tr></table></figure><p>我们就可以将一个LocalDate、LocalTime或LocalDateTime对象转化为ZonedDateTime对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">ZonedDateTime zonedDateTime = ZonedDateTime.of(localDateTime, shanghaiZoneId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  zonedDateTime</span></span><br><span class="line"><span class="comment">//  2017-01-05T15:26:56.147+08:00[Asia/Shanghai]</span></span><br><span class="line"><span class="comment">//  ZonedDateTime对象由两部分构成，LocalDateTime和ZoneId，其中2017-01-05T15:26:56.147部分为LocalDateTime，+08:00[Asia/Shanghai]部分为ZoneId</span></span><br></pre></td></tr></table></figure><p>另一种表示时区的方式是使用ZoneOffset，它是以当前时间和世界标准时间（UTC）/格林威治时间（GMT）的偏差来计算，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZoneOffset zoneOffset = ZoneOffset.of(<span class="string">"+09:00"</span>);</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">OffsetDateTime offsetDateTime = OffsetDateTime.of(localDateTime, zoneOffset);</span><br></pre></td></tr></table></figure><p>Java中使用的历法是ISO 8601日历系统，它是世界民用历法，也就是我们所说的公历。平年有365天，闰年是366天。闰年的定义是：非世纪年，能被4整除；世纪年能被400整除。为了计算的一致性，公元1年的前一年被当做公元0年，以此类推。</p><p>此外Java 8还提供了4套其他历法（很奇怪为什么没有汉族人使用的农历），每套历法都包含一个日期类，分别是：</p><ul><li>ThaiBuddhistDate：泰国佛教历</li><li>MinguoDate：中华民国历</li><li>JapaneseDate：日本历</li><li>HijrahDate：伊斯兰历</li></ul><p>由于它们都继承ChronoLocalDate类，所以在不知道具体历法情况下，可以通过ChronoLocalDate类操作日期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Chronology jpChronology = Chronology.ofLocale(Locale.JAPANESE);</span><br><span class="line">ChronoLocalDate jpChronoLocalDate = jpChronology.dateNow();</span><br></pre></td></tr></table></figure><p>我们在开发过程中应该尽量避免使用ChronoLocalDate，尽量用与历法无关的方式操作时间，因为不同的历法计算日期的方式不一样，比如开发者会在程序中做一些假设，假设一年中有12个月，如果是中国农历中包含了闰月，一年有可能是13个月，但开发者认为是12个月，多出来的一个月属于明年的。再比如假设年份是累加的，过了一年就在原来的年份上加一，但日本天皇在换代之后需要重新纪年，所以过了一年年份可能会从1开始计算。</p><p>在实际开发过程中建议使用LocalDate，包括存储、操作、业务规则的解读；除非需要将程序的输入或者输出本地化，这时可以使用ChronoLocalDate类。</p><hr><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  方法的第一个参数为秒，第二个参数为纳秒</span></span><br><span class="line">Instant instant = Instant.ofEpochSecond(<span class="number">120</span>, <span class="number">100000</span>);</span><br><span class="line"><span class="comment">//  从1970-01-01 00:00:00开始后两分钟的10万纳秒的时刻</span></span><br><span class="line"><span class="comment">//  1970-01-01T00:02:00.000100Z</span></span><br></pre></td></tr></table></figure><hr><h3 id="Duration"><a href="#Duration" class="headerlink" title="Duration"></a>Duration</h3><p>与Instant区别：Instant用于表示一个时间戳（或者说是一个时间点），而Duration表示一个时间段，所以Duration类中不包含now()静态方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime from = LocalDateTime.of(<span class="number">2017</span>, Month.JANUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);    <span class="comment">// 2017-01-05 10:07:00</span></span><br><span class="line">LocalDateTime to = LocalDateTime.of(<span class="number">2017</span>, Month.FEBRUARY, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">0</span>);     <span class="comment">// 2017-02-05 10:07:00</span></span><br><span class="line">Duration duration = Duration.between(from, to);     <span class="comment">// 表示从 2017-01-05 10:07:00 到 2017-02-05 10:07:00 这段时间</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> days = duration.toDays();              <span class="comment">// 这段时间的总天数</span></span><br><span class="line"><span class="keyword">long</span> hours = duration.toHours();            <span class="comment">// 这段时间的小时数</span></span><br><span class="line"><span class="keyword">long</span> minutes = duration.toMinutes();        <span class="comment">// 这段时间的分钟数</span></span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();       <span class="comment">// 这段时间的秒数</span></span><br><span class="line"><span class="keyword">long</span> milliSeconds = duration.toMillis();    <span class="comment">// 这段时间的毫秒数</span></span><br><span class="line"><span class="keyword">long</span> nanoSeconds = duration.toNanos();      <span class="comment">// 这段时间的纳秒数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  Duration对象还可以通过of()方法创建，该方法接受一个时间段长度，和一个时间单位作为参数</span></span><br><span class="line">Duration duration1 = Duration.of(<span class="number">5</span>, ChronoUnit.DAYS);       <span class="comment">// 5天</span></span><br><span class="line">Duration duration2 = Duration.of(<span class="number">1000</span>, ChronoUnit.MILLIS);  <span class="comment">// 1000毫秒</span></span><br></pre></td></tr></table></figure><hr><h3 id="Period"><a href="#Period" class="headerlink" title="Period"></a>Period</h3><p>Period在概念上和Duration类似，区别在于Period是以年月日来衡量一个时间段，比如2年3个月6天：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Period period = Period.of(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//  Period对象也可以通过between()方法创建，值得注意的是，由于Period是以年月日衡量时间段，所以between()方法只能接收LocalDate类型的参数</span></span><br><span class="line">Period period = Period.between(LocalDate.of(<span class="number">2017</span>, <span class="number">1</span>, <span class="number">5</span>), LocalDate.of(<span class="number">2017</span>, <span class="number">2</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://juejin.im/post/5d079fd76fb9a07ef44407d9" target="_blank" rel="noopener">https://juejin.im/post/5d079fd76fb9a07ef44407d9</a></li><li><a href="https://lw900925.github.io/java/java8-newtime-api.html" target="_blank" rel="noopener">https://lw900925.github.io/java/java8-newtime-api.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h3 id=&quot;LocalDate-和-LocalTime&quot;&gt;&lt;a href=&quot;#LocalDate-和-LocalTime&quot; class=&quot;headerlink&quot; title=&quot;LocalDate 和 LocalTime&quot;&gt;&lt;/a&gt;LocalDate 和 LocalT
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="DateFormat" scheme="https://sulangsss.github.io/tags/DateFormat/"/>
    
      <category term="DateTime" scheme="https://sulangsss.github.io/tags/DateTime/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin coroutine</title>
    <link href="https://sulangsss.github.io/2019/07/07/Java/Kotlin/coroutine/"/>
    <id>https://sulangsss.github.io/2019/07/07/Java/Kotlin/coroutine/</id>
    <published>2019-07-07T15:04:22.000Z</published>
    <updated>2019-07-13T03:51:50.719Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><h4 id="First-Example"><a href="#First-Example" class="headerlink" title="First Example"></a>First Example</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Practice&quot;&gt;&lt;a href=&quot;#Practice&quot; class=&quot;headerlink&quot; title=&quot;Practice&quot;&gt;&lt;/a&gt;Practice&lt;/h3&gt;&lt;h4 id=&quot;First-Example&quot;&gt;&lt;a href=&quot;#First-Example&quot; c
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/categories/Java/Kotlin/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/tags/Kotlin/"/>
    
      <category term="coroutine" scheme="https://sulangsss.github.io/tags/coroutine/"/>
    
  </entry>
  
  <entry>
    <title>RxJava Quick Start</title>
    <link href="https://sulangsss.github.io/2019/07/06/Java/Rx/Rx-Quick-Start/"/>
    <id>https://sulangsss.github.io/2019/07/06/Java/Rx/Rx-Quick-Start/</id>
    <published>2019-07-06T06:22:22.000Z</published>
    <updated>2019-07-16T14:30:12.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Basic-Theory"><a href="#Basic-Theory" class="headerlink" title="Basic Theory"></a>Basic Theory</h3><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/components-of-the-rxjava.png"><ul><li>Flowable: 多个流，响应式流和背压</li><li>Observable: 多个流，无背压</li><li>Single: 只有一个元素或者错误的流</li></ul><h3 id="Testing-Model"><a href="#Testing-Model" class="headerlink" title="Testing Model"></a>Testing Model</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class DataManager(size: Int = 16) &#123;</span><br><span class="line">    <span class="keyword">private</span> val data = mutableListOf&lt;Student&gt;()</span><br><span class="line"></span><br><span class="line">    init &#123;</span><br><span class="line">        <span class="keyword">for</span> (index in <span class="number">0</span> until size) &#123;</span><br><span class="line">            val student = Student(<span class="string">"Jack-$index"</span>, mutableListOf(Course(<span class="string">"English-$index"</span>)))</span><br><span class="line">            data.add(student)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">queryOrigin</span><span class="params">()</span>: MutableList&lt;Student&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">data class <span class="title">Student</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    var name: String,</span></span></span><br><span class="line"><span class="function"><span class="params">    var courses: MutableList&lt;Course&gt; = mutableListOf()</span></span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">data class <span class="title">Course</span><span class="params">(var name: String)</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="Transforming-Observables"><a href="#Transforming-Observables" class="headerlink" title="Transforming Observables"></a>Transforming Observables</h3><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>transform the items emitted by an Observable by applying a function to each item</p><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/map-execution.png"><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">        .map &#123; it.toDouble() &#125;</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="flatMap-vs-concatMap"><a href="#flatMap-vs-concatMap" class="headerlink" title="flatMap vs concatMap"></a>flatMap vs concatMap</h4><p>transform the items emitted by an Observable into Observables, then <strong>flatten the emissions from those into a single Observable</strong></p><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/rx-flatmap.png"><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">val dataManager = DataManager()</span><br><span class="line">val flatCourse = mutableListOf&lt;Course&gt;()</span><br><span class="line">val queryOrigin = dataManager.queryOrigin()</span><br><span class="line">Observable.fromIterable(queryOrigin)</span><br><span class="line">        .flatMap &#123; stu -&gt;</span><br><span class="line">            Observable.fromIterable(stu.courses)</span><br><span class="line">        &#125;.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .blockingSubscribe &#123; course -&gt;</span><br><span class="line">            flatCourse.add(course)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">val concatCourse = mutableListOf&lt;Course&gt;()</span><br><span class="line">Observable.fromIterable(queryOrigin)</span><br><span class="line">        .concatMap &#123; stu -&gt;</span><br><span class="line">            Observable.fromIterable(stu.courses)</span><br><span class="line">        &#125;.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .blockingSubscribe &#123; course -&gt;</span><br><span class="line">            concatCourse.add(course)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">println(<span class="string">"origin = $&#123;dataManager.queryOrigin()&#125;"</span>)</span><br><span class="line">println(<span class="string">"flatMap = $flatCourse"</span>)</span><br><span class="line">println(<span class="string">"concatMap = $concatCourse"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin = [Student(name=Jack-<span class="number">0</span>, courses=[Course(name=English-<span class="number">0</span>)]), Student(name=Jack-<span class="number">1</span>, courses=[Course(name=English-<span class="number">1</span>)]), Student(name=Jack-<span class="number">2</span>, courses=[Course(name=English-<span class="number">2</span>)])]</span><br><span class="line">flatMap = [Course(name=English-<span class="number">0</span>), Course(name=English-<span class="number">1</span>), Course(name=English-<span class="number">2</span>)]</span><br><span class="line">concatMap = [Course(name=English-<span class="number">0</span>), Course(name=English-<span class="number">1</span>), Course(name=English-<span class="number">2</span>)]</span><br></pre></td></tr></table></figure><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/concat_vs_flatmap_1.png"><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/concat_vs_flatmap_2.png"><p>flatMap将一个发送事件的上游Observable变换为多个发送事件的Observables，然后将它们发射的事件合并后放进一个单独的Observable里。需要注意的是, flatMap并不保证事件的顺序，也就是说转换之后的Observables的顺序不必与转换之前的序列的顺序一致。</p><p>与flatMap对应的方法是contactMap，后者能够保证最终输出的顺序与上游发送的顺序一致。</p><blockquote><p>Both methods look pretty much the same, but there is a difference: operator usage when merging the final results.</p></blockquote><blockquote><p>The <strong>flatMap()</strong> method creates a new Observable by applying a function that you supply to each item emitted by the original Observable, where that function is itself an Observable that emits items, and then merges the results of that function applied to every item emitted by the original Observable, emitting these merged results.</p></blockquote><blockquote><p>Note that <strong>flatMap()</strong> may interleave the items emitted by the Observables that result from transforming the items emitted by the source Observable.</p></blockquote><blockquote><p>If it is important that these items not be <strong>interleaved</strong>, you can instead use the similar <strong>concatMap()</strong> method.</p></blockquote><blockquote><p>FlatMap对这些Observables发射的数据做的是合并(merge)操作，因此它们可能是交错的。也就说，传入的顺序可能跟出来的顺序不一样。如果要保证顺的的话，可以使用concatMap。</p></blockquote><h4 id="flatMapIterable"><a href="#flatMapIterable" class="headerlink" title="flatMapIterable"></a>flatMapIterable</h4><h4 id="switchMap"><a href="#switchMap" class="headerlink" title="switchMap"></a>switchMap</h4><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">val dataManager = DataManager()</span><br><span class="line"></span><br><span class="line">val switchMapCourse = mutableListOf&lt;String&gt;()</span><br><span class="line">val queryOrigin = dataManager.queryOrigin()</span><br><span class="line"></span><br><span class="line">Observable.fromIterable(queryOrigin)</span><br><span class="line">        .switchMap &#123; stu -&gt;</span><br><span class="line">            Observable.timer(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                    .map &#123; stu.name &#125;</span><br><span class="line">        &#125;.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .blockingSubscribe &#123; course -&gt;</span><br><span class="line">            switchMapCourse.add(course)</span><br><span class="line">        &#125;</span><br><span class="line">println(<span class="string">"origin = $&#123;dataManager.queryOrigin()&#125;"</span>)</span><br><span class="line">println(<span class="string">"switchMap = $switchMapCourse"</span>)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin = [Student(name=Jack-<span class="number">0</span>, courses=[Course(name=English-<span class="number">0</span>)]), Student(name=Jack-<span class="number">1</span>, courses=[Course(name=English-<span class="number">1</span>)]), Student(name=Jack-<span class="number">2</span>, courses=[Course(name=English-<span class="number">2</span>)])]</span><br><span class="line">switchMap = [Jack-<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>If just return a normal observable on switchMap(), example:</p><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromIterable(queryOrigin)</span><br><span class="line">        .switchMap &#123; stu -&gt;</span><br><span class="line">            Observable.just(stu.name)</span><br><span class="line">        &#125;.subscribeOn(Schedulers.newThread())</span><br><span class="line">        .blockingSubscribe &#123; course -&gt;</span><br><span class="line">            switchMapCourse.add(course)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin = [Student(name=Jack-<span class="number">0</span>, courses=[Course(name=English-<span class="number">0</span>)]), Student(name=Jack-<span class="number">1</span>, courses=[Course(name=English-<span class="number">1</span>)]), Student(name=Jack-<span class="number">2</span>, courses=[Course(name=English-<span class="number">2</span>)])]</span><br><span class="line">switchMap = [Jack-<span class="number">0</span>, Jack-<span class="number">1</span>, Jack-<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h4 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h4><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">        .cast(Number.class)</span><br><span class="line">        .subscribe(num -&gt; println(num)));</span><br></pre></td></tr></table></figure><h4 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h4><p>apply a function to each item emitted by an Observable, sequentially, and emit each successive value</p><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">val dataManager = DataManager()</span><br><span class="line"></span><br><span class="line">val scanStudent = mutableListOf&lt;Student&gt;()</span><br><span class="line">val queryOrigin = dataManager.queryOrigin()</span><br><span class="line"></span><br><span class="line">Observable.fromIterable(queryOrigin)</span><br><span class="line">        .scan &#123; lastStu: Student, student: Student -&gt;</span><br><span class="line">            println(<span class="string">"---------------------"</span>)</span><br><span class="line">            println(<span class="string">"lastStu $&#123;lastStu.name&#125;"</span>)</span><br><span class="line">            println(<span class="string">"current Stu $&#123;student.name&#125;"</span>)</span><br><span class="line">            println(<span class="string">"next Stu $&#123;lastStu.name&#125; + $&#123;student.name&#125;"</span>)</span><br><span class="line">            Student(name = <span class="string">"$&#123;lastStu.name&#125; + $&#123;student.name&#125;"</span>)</span><br><span class="line">        &#125;.subscribe &#123;</span><br><span class="line">            scanStudent.add(it)</span><br><span class="line">        &#125;</span><br><span class="line">println(<span class="string">"===================================================================================="</span>)</span><br><span class="line">println(<span class="string">"origin = $&#123;dataManager.queryOrigin()&#125;"</span>)</span><br><span class="line">println(<span class="string">"===================================================================================="</span>)</span><br><span class="line"><span class="keyword">for</span> (student in scanStudent) &#123;</span><br><span class="line">    println(<span class="string">"student $&#123;student.name&#125;"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">lastStu Jack-<span class="number">0</span></span><br><span class="line">current Stu Jack-<span class="number">1</span></span><br><span class="line">next Stu Jack-<span class="number">0</span> + Jack-<span class="number">1</span></span><br><span class="line">---------------------</span><br><span class="line">lastStu Jack-<span class="number">0</span> + Jack-<span class="number">1</span></span><br><span class="line">current Stu Jack-<span class="number">2</span></span><br><span class="line">next Stu Jack-<span class="number">0</span> + Jack-<span class="number">1</span> + Jack-<span class="number">2</span></span><br><span class="line">====================================================================================</span><br><span class="line">origin = [Student(name=Jack-<span class="number">0</span>, courses=[Course(name=English-<span class="number">0</span>)]), Student(name=Jack-<span class="number">1</span>, courses=[Course(name=English-<span class="number">1</span>)]), Student(name=Jack-<span class="number">2</span>, courses=[Course(name=English-<span class="number">2</span>)])]</span><br><span class="line">====================================================================================</span><br><span class="line">student Jack-<span class="number">0</span></span><br><span class="line">student Jack-<span class="number">0</span> + Jack-<span class="number">1</span></span><br><span class="line">student Jack-<span class="number">0</span> + Jack-<span class="number">1</span> + Jack-<span class="number">2</span></span><br></pre></td></tr></table></figure><h4 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h4><p>periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time</p><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line">        .buffer(<span class="number">2</span>)</span><br><span class="line">        .subscribe &#123;</span><br><span class="line">            println(it)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time</p><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/rx-window-theory.png"><p>Window is similar to Buffer, but rather than emitting packets of items from the source Observable, it emits Observables, each one of which emits a subset of items from the source Observable and then terminates with an onCompleted notification. </p><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/rx-buffer-vs-windwos-1.png"><img src="/2019/07/06/Java/Rx/Rx-Quick-Start/rx-buffer-vs-windwos-2.png"><p>Window和Buffer类似，但不是发射来自原始Observable的数据包，它发射的是Observable，这些Observables中的每一个都发射原始Observable数据的一个子集，最后发射一个onCompleted通知。<br>以下面的程序为例，这里我们首先生成了一个由10个数字组成的整数序列，然后使用window函数将它们每3个作为一组，每组会返回一个对应的Observable对象。<br>这里我们对该返回的结果进行订阅并进行消费，因为10个数字，所以会被分成4个组，每个对应一个Observable：</p><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(<span class="number">1</span>, <span class="number">10</span>).window(<span class="number">3</span>)</span><br><span class="line">            .subscribe &#123; observable -&gt;</span><br><span class="line">                observable.subscribe &#123; integer -&gt;</span><br><span class="line">                    println(observable.hashCode().toString() + <span class="string">" : "</span> + integer)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">901506536</span> : <span class="number">1</span></span><br><span class="line"><span class="number">901506536</span> : <span class="number">2</span></span><br><span class="line"><span class="number">901506536</span> : <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="number">747464370</span> : <span class="number">4</span></span><br><span class="line"><span class="number">747464370</span> : <span class="number">5</span></span><br><span class="line"><span class="number">747464370</span> : <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="number">1513712028</span> : <span class="number">7</span></span><br><span class="line"><span class="number">1513712028</span> : <span class="number">8</span></span><br><span class="line"><span class="number">1513712028</span> : <span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">1018547642</span> : <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h4><p>divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key</p><p>groupBy用于分组元素，它可以被用来根据指定的条件将元素分成若干组。</p><p><strong>Example 1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable.concat(</span><br><span class="line">            Observable.range(<span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">            Observable.range(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    ).groupBy &#123; integer -&gt;</span><br><span class="line">        integer</span><br><span class="line">    &#125;.subscribe &#123; groupedObservable: GroupedObservable&lt;Int, Int&gt; -&gt;</span><br><span class="line">        groupedObservable.subscribe &#123; println(<span class="string">"key $&#123;groupedObservable.key&#125; -&gt; value $it"</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">key <span class="number">1</span> -&gt; value <span class="number">1</span></span><br><span class="line">key <span class="number">2</span> -&gt; value <span class="number">2</span></span><br><span class="line">key <span class="number">3</span> -&gt; value <span class="number">3</span></span><br><span class="line">key <span class="number">4</span> -&gt; value <span class="number">4</span></span><br><span class="line">key <span class="number">1</span> -&gt; value <span class="number">1</span></span><br><span class="line">key <span class="number">2</span> -&gt; value <span class="number">2</span></span><br><span class="line">key <span class="number">3</span> -&gt; value <span class="number">3</span></span><br><span class="line">key <span class="number">4</span> -&gt; value <span class="number">4</span></span><br><span class="line">key <span class="number">5</span> -&gt; value <span class="number">5</span></span><br><span class="line">key <span class="number">6</span> -&gt; value <span class="number">6</span></span><br></pre></td></tr></table></figure><hr><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><h4 id="average"><a href="#average" class="headerlink" title="average"></a>average</h4><h4 id="count"><a href="#count" class="headerlink" title="count"></a>count</h4><h4 id="max"><a href="#max" class="headerlink" title="max"></a>max</h4><h4 id="min"><a href="#min" class="headerlink" title="min"></a>min</h4><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>apply a function to each item emitted by an Observable, sequentially, and emit the final value</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://reactivex.io/documentation/operators.html" target="_blank" rel="noopener">http://reactivex.io/documentation/operators.html</a></li><li><a href="https://maxwell-nc.github.io/android/rxjava2-6.html" target="_blank" rel="noopener">https://maxwell-nc.github.io/android/rxjava2-6.html</a></li><li><a href="https://medium.com/mindorks/rxjava-operator-map-vs-flatmap-427c09678784" target="_blank" rel="noopener">https://medium.com/mindorks/rxjava-operator-map-vs-flatmap-427c09678784</a></li><li><a href="https://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/" target="_blank" rel="noopener">https://fernandocejas.com/2015/01/11/rxjava-observable-tranformation-concatmap-vs-flatmap/</a></li><li><a href="https://my.oschina.net/u/2277632/blog/2986715" target="_blank" rel="noopener">https://my.oschina.net/u/2277632/blog/2986715</a></li><li><a href="https://juejin.im/post/5b72f76551882561354462dd" target="_blank" rel="noopener">https://juejin.im/post/5b72f76551882561354462dd</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Basic-Theory&quot;&gt;&lt;a href=&quot;#Basic-Theory&quot; class=&quot;headerlink&quot; title=&quot;Basic Theory&quot;&gt;&lt;/a&gt;Basic Theory&lt;/h3&gt;&lt;img src=&quot;/2019/07/06/Java/Rx/Rx-
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="RxJava" scheme="https://sulangsss.github.io/categories/Java/RxJava/"/>
    
    
      <category term="RxJava" scheme="https://sulangsss.github.io/tags/RxJava/"/>
    
      <category term="QuickStart" scheme="https://sulangsss.github.io/tags/QuickStart/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin sort</title>
    <link href="https://sulangsss.github.io/2019/07/06/Java/Kotlin/sort/"/>
    <id>https://sulangsss.github.io/2019/07/06/Java/Kotlin/sort/</id>
    <published>2019-07-05T16:08:22.000Z</published>
    <updated>2019-07-06T06:15:53.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Define-Class"><a href="#Define-Class" class="headerlink" title="Define Class"></a>Define Class</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    var name: String = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    var age: Int = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    var money: Double = <span class="number">0.0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val persons = mutableListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">persons.add(Person(<span class="string">"Hello-1"</span>, <span class="number">1</span>, <span class="number">10.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-5"</span>, <span class="number">5</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-3"</span>, <span class="number">3</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-2"</span>, <span class="number">2</span>, <span class="number">100.0</span>))</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br><span class="line">println(<span class="string">"========================="</span>)</span><br><span class="line">persons.sortBy &#123; it.age &#125;</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Person(name=Hello-<span class="number">1</span>, age=<span class="number">1</span>, money=<span class="number">10.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">5</span>, age=<span class="number">5</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">3</span>, age=<span class="number">3</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">2</span>, age=<span class="number">2</span>, money=<span class="number">100.0</span>)</span><br><span class="line">=========================</span><br><span class="line">Person(name=Hello-<span class="number">1</span>, age=<span class="number">1</span>, money=<span class="number">10.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">2</span>, age=<span class="number">2</span>, money=<span class="number">100.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">3</span>, age=<span class="number">3</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">5</span>, age=<span class="number">5</span>, money=<span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>sortBy 为正序排列，跟其对应的降序方法为 sortByDescending。</p><hr><h3 id="sortWith"><a href="#sortWith" class="headerlink" title="sortWith"></a>sortWith</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">val persons = mutableListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">persons.add(Person(<span class="string">"Hello-1"</span>, <span class="number">1</span>, <span class="number">10.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-5"</span>, <span class="number">5</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-3"</span>, <span class="number">3</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-2"</span>, <span class="number">2</span>, <span class="number">100.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-6"</span>, <span class="number">2</span>, <span class="number">50.0</span>))</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br><span class="line">println(<span class="string">"========================="</span>)</span><br><span class="line">persons.sortWith(compareBy(&#123; it.age &#125;, &#123; it.money &#125;))</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Person(name=Hello-<span class="number">1</span>, age=<span class="number">1</span>, money=<span class="number">10.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">5</span>, age=<span class="number">5</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">3</span>, age=<span class="number">3</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">2</span>, age=<span class="number">2</span>, money=<span class="number">100.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">6</span>, age=<span class="number">2</span>, money=<span class="number">50.0</span>)</span><br><span class="line">=========================</span><br><span class="line">Person(name=Hello-<span class="number">1</span>, age=<span class="number">1</span>, money=<span class="number">10.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">6</span>, age=<span class="number">2</span>, money=<span class="number">50.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">2</span>, age=<span class="number">2</span>, money=<span class="number">100.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">3</span>, age=<span class="number">3</span>, money=<span class="number">20.0</span>)</span><br><span class="line">Person(name=Hello-<span class="number">5</span>, age=<span class="number">5</span>, money=<span class="number">20.0</span>)</span><br></pre></td></tr></table></figure><p>sortWith 方法中，传入的 compareBy({属性1},{属性2},…)参数，参数个数是可变的。但是都是默认的升序排列。</p><p>可以给sortWith传入一个Comparator对象，来达到一个更高级更复杂的逻辑。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">val persons = mutableListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">persons.add(Person(<span class="string">"Hello-1"</span>, <span class="number">1</span>, <span class="number">10.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-5"</span>, <span class="number">5</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-3"</span>, <span class="number">3</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-2"</span>, <span class="number">2</span>, <span class="number">100.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-6"</span>, <span class="number">2</span>, <span class="number">50.0</span>))</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br><span class="line">println(<span class="string">"========================="</span>)</span><br><span class="line">val comparator: Comparator&lt;Person&gt; = Comparator &#123; o1, o2 -&gt;</span><br><span class="line">    <span class="keyword">if</span> (o2.age == o1.age) &#123;</span><br><span class="line">        o1.money.compareTo(o2.money)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o1.age - o2.age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">persons.sortWith(comparator)</span><br><span class="line"><span class="comment">//  persons.sortWith(compareBy(&#123; it.age &#125;, &#123; it.money &#125;))</span></span><br><span class="line">persons.forEach(::println)</span><br></pre></td></tr></table></figure><hr><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">data class <span class="title">Person</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    var name: String = <span class="string">""</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    var age: Int = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    var money: Double = <span class="number">0.0</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> : Comparable&lt;Person&gt; </span>&#123;</span><br><span class="line">    <span class="function">override fun <span class="title">compareTo</span><span class="params">(other: Person)</span>: Int </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (other.age == <span class="keyword">this</span>.age) &#123;</span><br><span class="line">            <span class="keyword">this</span>.money.compareTo(other.money)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age - other.age</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">val persons = mutableListOf&lt;Person&gt;()</span><br><span class="line"></span><br><span class="line">persons.add(Person(<span class="string">"Hello-1"</span>, <span class="number">1</span>, <span class="number">10.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-5"</span>, <span class="number">5</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-3"</span>, <span class="number">3</span>, <span class="number">20.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-2"</span>, <span class="number">2</span>, <span class="number">100.0</span>))</span><br><span class="line">persons.add(Person(<span class="string">"Hello-6"</span>, <span class="number">2</span>, <span class="number">50.0</span>))</span><br><span class="line"></span><br><span class="line">persons.forEach(::println)</span><br><span class="line">println(<span class="string">"========================="</span>)</span><br><span class="line">persons.sort()</span><br><span class="line">persons.forEach(::println)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Define-Class&quot;&gt;&lt;a href=&quot;#Define-Class&quot; class=&quot;headerlink&quot; title=&quot;Define Class&quot;&gt;&lt;/a&gt;Define Class&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/categories/Java/Kotlin/"/>
    
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/tags/Kotlin/"/>
    
      <category term="sort" scheme="https://sulangsss.github.io/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>Linux total-vm and rss</title>
    <link href="https://sulangsss.github.io/2019/06/28/Linux/Basic/total-vm-and-rss/"/>
    <id>https://sulangsss.github.io/2019/06/28/Linux/Basic/total-vm-and-rss/</id>
    <published>2019-06-28T09:00:06.000Z</published>
    <updated>2019-06-28T09:03:19.328Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Issue: GCP kill some pod at node</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Memory cgroup out of memory: Kill process 2177348 (java) score 1465 or sacrifice child Killed process 2177348 (java) total-vm:19172696kB, anon-rss:12547720kB, file-rss:17176kB, shmem-rss:57592kB</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Issue: GCP kill some pod at no
      
    
    </summary>
    
      <category term="Linux" scheme="https://sulangsss.github.io/categories/Linux/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Linux/Basic/"/>
    
    
      <category term="Linux" scheme="https://sulangsss.github.io/tags/Linux/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/tags/Basic/"/>
    
      <category term="rss" scheme="https://sulangsss.github.io/tags/rss/"/>
    
      <category term="total-vm" scheme="https://sulangsss.github.io/tags/total-vm/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 如何高效地插入大量数据</title>
    <link href="https://sulangsss.github.io/2019/06/04/DB/MySQL/How-Batch-Insert-Large-Data/"/>
    <id>https://sulangsss.github.io/2019/06/04/DB/MySQL/How-Batch-Insert-Large-Data/</id>
    <published>2019-06-04T01:55:07.000Z</published>
    <updated>2019-06-04T02:48:10.143Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.cnblogs.com/micrari/p/7112781.html" target="_blank" rel="noopener">https://www.cnblogs.com/micrari/p/7112781.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/mic
      
    
    </summary>
    
      <category term="DB" scheme="https://sulangsss.github.io/categories/DB/"/>
    
      <category term="MySQL" scheme="https://sulangsss.github.io/categories/DB/MySQL/"/>
    
    
      <category term="DB" scheme="https://sulangsss.github.io/tags/DB/"/>
    
      <category term="MySQL" scheme="https://sulangsss.github.io/tags/MySQL/"/>
    
      <category term="Prepared-Statements" scheme="https://sulangsss.github.io/tags/Prepared-Statements/"/>
    
  </entry>
  
  <entry>
    <title>Command Query Responsibility Segregation</title>
    <link href="https://sulangsss.github.io/2019/06/04/Architecture/CQRS/Command%20Query%20Responsibility%20Segregation/"/>
    <id>https://sulangsss.github.io/2019/06/04/Architecture/CQRS/Command Query Responsibility Segregation/</id>
    <published>2019-06-03T16:47:19.000Z</published>
    <updated>2019-06-04T02:45:41.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://microservices.io/patterns/data/cqrs.html" target="_blank" rel="noopener">https://microservices.io/patterns/data/cqrs.html</a></li><li><a href="https://spring.io/blog/2016/03/22/springone2gx-2015-replay-building-microservices-with-event-sourcing-and-cqrs" target="_blank" rel="noopener">https://spring.io/blog/2016/03/22/springone2gx-2015-replay-building-microservices-with-event-sourcing-and-cqrs</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://microservices.io/pa
      
    
    </summary>
    
      <category term="Architecture" scheme="https://sulangsss.github.io/categories/Architecture/"/>
    
      <category term="CQRS" scheme="https://sulangsss.github.io/categories/Architecture/CQRS/"/>
    
    
      <category term="CQRS" scheme="https://sulangsss.github.io/tags/CQRS/"/>
    
  </entry>
  
  <entry>
    <title>Tools Menu</title>
    <link href="https://sulangsss.github.io/2019/06/02/Tools/Tools-Menu/"/>
    <id>https://sulangsss.github.io/2019/06/02/Tools/Tools-Menu/</id>
    <published>2019-06-02T03:34:06.000Z</published>
    <updated>2019-06-02T03:45:10.621Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><h4 id="ShellCheck"><a href="#ShellCheck" class="headerlink" title="ShellCheck"></a>ShellCheck</h4><p>ShellCheck - A shell script static analysis tool</p><blockquote><p><a href="https://github.com/koalaman/shellcheck" target="_blank" rel="noopener">https://github.com/koalaman/shellcheck</a></p></blockquote><hr><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h4 id="Dockly"><a href="#Dockly" class="headerlink" title="Dockly"></a>Dockly</h4><ol><li><p>Install</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g dockly</span><br></pre></td></tr></table></figure></li><li><p>Usage</p></li></ol><ul><li>= – Refresh the Dockly interface,</li><li>/ – Search the containers list view,</li><li>i – Display the information about the currently selected container or service,</li><li><return> – Show logs of the current container or service,</return></li><li>v – Toggle between Containers and Services view,</li><li>l – Launch a /bin/bash session on the selected Container,</li><li>r – Restart the selected Container,</li><li>s – Stop the selected Container,</li><li>h – Show HELP window,</li><li>q – Quit Dockly.</li></ul><blockquote><p><a href="https://github.com/lirantal/" target="_blank" rel="noopener">https://github.com/lirantal/</a><br><a href="https://www.ostechnix.com/install-node-js-linux/" target="_blank" rel="noopener">https://www.ostechnix.com/install-node-js-linux/</a><br><a href="https://www.ostechnix.com/dockly-manage-docker-containers-from-terminal/" target="_blank" rel="noopener">https://www.ostechnix.com/dockly-manage-docker-containers-from-terminal/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Shell&quot;&gt;&lt;a href=&quot;#Shell&quot; class=&quot;headerlink&quot; title=&quot;Shell&quot;&gt;&lt;/a&gt;Shell&lt;/h3&gt;&lt;h4 id=&quot;ShellCheck&quot;&gt;&lt;a href=&quot;#ShellCheck&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Tools" scheme="https://sulangsss.github.io/categories/Tools/"/>
    
    
      <category term="Tools Menu" scheme="https://sulangsss.github.io/tags/Tools-Menu/"/>
    
  </entry>
  
  <entry>
    <title>ip-masq-agent</title>
    <link href="https://sulangsss.github.io/2019/05/31/Kubenetes/GCP/ip-masq-agent/"/>
    <id>https://sulangsss.github.io/2019/05/31/Kubenetes/GCP/ip-masq-agent/</id>
    <published>2019-05-31T03:15:06.000Z</published>
    <updated>2019-05-31T03:15:38.035Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#create_manual" target="_blank" rel="noopener">https://cloud.google.com/kubernetes-engine/docs/how-to/ip-masquerade-agent#create_manual</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.google.com/ku
      
    
    </summary>
    
      <category term="Kubernetes" scheme="https://sulangsss.github.io/categories/Kubernetes/"/>
    
      <category term="GCP" scheme="https://sulangsss.github.io/categories/Kubernetes/GCP/"/>
    
    
      <category term="GCP" scheme="https://sulangsss.github.io/tags/GCP/"/>
    
      <category term="ip-masq-agent" scheme="https://sulangsss.github.io/tags/ip-masq-agent/"/>
    
  </entry>
  
  <entry>
    <title>Red-Green-Refactor Pattern</title>
    <link href="https://sulangsss.github.io/2019/05/28/TDD/Basic/Red-Green-Refactor%20Pattern/"/>
    <id>https://sulangsss.github.io/2019/05/28/TDD/Basic/Red-Green-Refactor Pattern/</id>
    <published>2019-05-28T11:51:19.000Z</published>
    <updated>2019-06-03T16:41:51.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://medium.com/@syukri.mullia/basic-tdd-red-green-refactor-pattern-4046381b95a6" target="_blank" rel="noopener">https://medium.com/@syukri.mullia/basic-tdd-red-green-refactor-pattern-4046381b95a6</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Refe
      
    
    </summary>
    
      <category term="TDD" scheme="https://sulangsss.github.io/categories/TDD/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/TDD/Basic/"/>
    
    
      <category term="TDD" scheme="https://sulangsss.github.io/tags/TDD/"/>
    
      <category term="Basic-TDD" scheme="https://sulangsss.github.io/tags/Basic-TDD/"/>
    
      <category term="Red-Green" scheme="https://sulangsss.github.io/tags/Red-Green/"/>
    
  </entry>
  
  <entry>
    <title>Java JVM On Docker</title>
    <link href="https://sulangsss.github.io/2019/05/28/Docker/JVM/Java-JVM-On-Docker/"/>
    <id>https://sulangsss.github.io/2019/05/28/Docker/JVM/Java-JVM-On-Docker/</id>
    <published>2019-05-28T11:51:19.000Z</published>
    <updated>2019-05-28T12:30:45.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>你是否曾经经历过在Docker中运行基于JVM的应用程序时出现“随机”故障？或者一些奇怪的死机？两者都有可能是由于Java 8中的糟糕的Docker支持引起。</p><p>Docker使用控制组(cgroups)来限制对资源的使用。在容器中运行应用程序时限制其对内存和CPU的使用绝对是一个好主意，它可以防止应用程序占用全部可用的内存和/或CPU，因而导致在同一系统上运行的其他容器无法响应。限制资源的使用可以提高应用程序的可靠性和稳定性。它还为硬件容量的规划提供了依据。在像诸如Kubernetes或DC/OS这样的编排系统上运行容器时，这一点尤为重要。</p><p>JVM 可以“看到”系统上所有可用的内存和 CPU 内核，并保持与这些资源的一致。在默认情况下，JVM 会将 max heap size 设置为系统内存的 1/4，并将一些线程池个数(比如GC)设置为与物理 CPU 内核的数量一致。</p><blockquote><p>本文中使用的是遵循GNU GPL v2 许可授权的OpenJDK官方Docker镜像。这里描述的对Docker的支持在Oracle Java SE 开发工具包(JDK)版本8的更新191中被引入。Oracle在2019年4月修改了Java 8更新的许可政策，自Java SE 8更新211后的商业使用不再免费。    </p></blockquote><hr><h3 id="Practice"><a href="#Practice" class="headerlink" title="Practice"></a>Practice</h3><p>我们一起来看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Vector;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryEater</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">byte</span> b[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1048576</span>];</span><br><span class="line">      v.add(b);</span><br><span class="line">      Runtime rt = Runtime.getRuntime();</span><br><span class="line">      System.out.println( <span class="string">"free memory: "</span> + rt.freeMemory() );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We run it on a system with 64GB of memory, so let’s check the default maximum heap size:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti openjdk:8u181-jdk</span><br><span class="line">java -XX:+PrintFlagsFinal -version | grep MaxHeap</span><br><span class="line">    uintx MaxHeapFreeRatio = 100</span><br><span class="line">    uintx MaxHeapSize := 16819159040 &#123;product&#125;</span><br><span class="line"></span><br><span class="line">openjdk version <span class="string">"1.8.0_181"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_181-8u181-b13-2~deb9u1-b13)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure><p>As said — it’s 1/4 of physical memory — 16GB. What will happen if we limit the memory using docker cgroups? Let’s check:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti -m 512M openjdk:8u181-jdk</span><br><span class="line">javac MemoryEater.java</span><br><span class="line"></span><br><span class="line">Note: MemoryEater.java uses unchecked or unsafe operations.</span><br><span class="line">Note: Recompile with -Xlint:unchecked <span class="keyword">for</span> details.</span><br><span class="line"></span><br><span class="line">java MemoryEater</span><br><span class="line"></span><br><span class="line">free memory: 1003980048</span><br><span class="line">free memory: 1003980048</span><br><span class="line">free memory: 1003980048</span><br><span class="line">[...]</span><br><span class="line">free memory: 803562640</span><br><span class="line">free memory: 802514048</span><br><span class="line">free memory: 801465456</span><br><span class="line">free memory: 800416864</span><br><span class="line">Killed</span><br></pre></td></tr></table></figure><p>The JVM process was killed. Since it was a child process — the container itself survived, but normally when java is the only process inside a container (with PID 1) the container will crash.</p><p>Let’s look into system logs:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">dcos-agent-1 kernel: java invoked oom-killer: gfp_mask=0xd0, order=0, oom_score_adj=0</span><br><span class="line">dcos-agent-1 kernel: java cpuset=eca214e0fcd4b245eecb2a80c05e9d7f8688fc36979c510d2fb9afab2ce55712 mems_allowed=0</span><br><span class="line">dcos-agent-1 kernel: CPU: 6 PID: 4142 Comm: java Tainted: G               ------------ T 3.10.0-693.17.1.el7.x86_64 <span class="comment">#1</span></span><br><span class="line">dcos-agent-1 kernel: Hardware name: Supermicro Super Server/X10SRi-F, BIOS 2.0 12/17/2015</span><br><span class="line">dcos-agent-1 kernel: Call Trace:</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff816a6071&gt;] dump_stack+0x19/0x1b</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff816a1466&gt;] dump_header+0x90/0x229</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff81187dc6&gt;] ? find_lock_task_mm+0x56/0xc0</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff811f36a8&gt;] ? try_get_mem_cgroup_from_mm+0x28/0x60</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff81188274&gt;] oom_kill_process+0x254/0x3d0</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff812ba2fc&gt;] ? selinux_capable+0x1c/0x40</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff811f73c6&gt;] mem_cgroup_oom_synchronize+0x546/0x570</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff811f6840&gt;] ? mem_cgroup_charge_common+0xc0/0xc0</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff81188b04&gt;] pagefault_out_of_memory+0x14/0x90</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff8169f82e&gt;] mm_fault_error+0x68/0x12b</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff816b3a21&gt;] __do_page_fault+0x391/0x450</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff816b3b15&gt;] do_page_fault+0x35/0x90</span><br><span class="line">dcos-agent-1 kernel: [&lt;ffffffff816af8f8&gt;] page_fault+0x28/0x30</span><br><span class="line">dcos-agent-1 kernel: Task <span class="keyword">in</span> /docker/eca214e0fcd4b245eecb2a80c05e9d7f8688fc36979c510d2fb9afab2ce55712 killed as a result of <span class="built_in">limit</span> of /docker/eca214e0fc</span><br><span class="line">5e9d7f8688fc36979c510d2fb9afab2ce55712</span><br><span class="line">dcos-agent-1 kernel: memory: usage 524180kB, <span class="built_in">limit</span> 524288kB, failcnt 314788</span><br><span class="line">dcos-agent-1 kernel: memory+swap: usage 1048576kB, <span class="built_in">limit</span> 1048576kB, failcnt 6</span><br><span class="line">dcos-agent-1 kernel: kmem: usage 0kB, <span class="built_in">limit</span> 9007199254740988kB, failcnt 0</span><br><span class="line">dcos-agent-1 kernel: Memory cgroup stats <span class="keyword">for</span> /docker/eca214e0fcd4b245eecb2a80c05e9d7f8688fc36979c510d2fb9afab2ce55712: cache:28KB rss:524152KB rss_huge</span><br><span class="line">:0KB swap:524396KB inactive_anon:262176KB active_anon:261976KB inactive_file:8KB active_file:4KB unevictable:0KB</span><br><span class="line">dcos-agent-1 kernel: [ pid ]   uid  tgid total_vm      rss nr_ptes swapents oom_score_adj name</span><br><span class="line">dcos-agent-1 kernel: [ 1400]     0  1400     4985      418      14      139             0 bash</span><br><span class="line">dcos-agent-1 kernel: [ 4141]     0  4141  4956003   126966     606   137837             0 java</span><br><span class="line">dcos-agent-1 kernel: Memory cgroup out of memory: Kill process 4162 (java) score 1012 or sacrifice child</span><br><span class="line">dcos-agent-1 kernel: Killed process 4141 (java) total-vm:19824012kB, anon-rss:495748kB, file-rss:12116kB, shmem-rss:0kB</span><br></pre></td></tr></table></figure><p>Failures like these can be very difficult to debug — there is nothing in the application logs. It can be especially difficult on managed systems like AWS ECS.</p><p>And how about CPUs? Let’s check it again running a small program which displays the number of available processors:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableProcessors</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check the number of processors available</span></span><br><span class="line">      System.out.println(<span class="string">""</span>+Runtime.getRuntime().availableProcessors());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let’s run it in a docker container with cpu number set to 1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -ti --cpus 1 openjdk:8u181-jdk</span><br><span class="line">javac AvailableProcessors.java</span><br><span class="line">java AvailableProcessors</span><br><span class="line">12</span><br></pre></td></tr></table></figure><p>Not good — there are 12 CPUs on this system indeed. So even the number of available processors is limited to 1, the JVM will try to use 12.</p><blockquote><p>for example the GC threads number is set by this formula: On a machine with N hardware threads where N is greater than 8, the parallel collector uses a fixed fraction of N as the number of garbage collector threads. The fraction is approximately 5/8 for large values of N. At values of N below 8, the number used is N.</p></blockquote><p>In our case:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep ParallelGCThreads</span><br><span class="line">uintx ParallelGCThreads = 10 &#123;product&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>The new Java version (10 and above) docker support is already built-in. But sometimes upgrading is not an option — for example if the application is incompatible with the new JVM.</p><p>The good news: Docker support was also backported to Java 8. Let’s check the newest openjdk image tagged as <strong>8u212</strong>. </p><p>We’ll limit the memory to 1G and use 1 CPU: <strong>docker run -ti –cpus 1 -m 1G openjdk:8u212-jdk</strong></p><p>The memory:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version | grep MaxHeap</span><br><span class="line">    uintx MaxHeapFreeRatio                          = 70                                  &#123;manageable&#125;</span><br><span class="line">    uintx MaxHeapSize                              := 268435456                           &#123;product&#125;</span><br><span class="line">openjdk version <span class="string">"1.8.0_212"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_212-8u212-b01-1~deb9u1-b01)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.212-b01, mixed mode)</span><br><span class="line"><span class="comment"># It’s 256M — exactly 1/4 of allocated memory.</span></span><br><span class="line"></span><br><span class="line">java AvailableProcessors</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>Moreover, there are some new settings:</p><ul><li>-XX:InitialRAMPercentage</li><li>-XX:MaxRAMPercentage</li><li>-XX:MinRAMPercentage</li></ul><p>If for some reason the new JVM behaviour is not desired it can be switched off using <strong>-XX:-UseContainerSupport</strong>.</p><blockquote><p>On Kuberntes<br>imits.cpu  &lt;==&gt;  –cpu-quota  # docker inspect中的CpuQuota值<br>requests.cpu  &lt;==&gt;  –cpu-shares  # docker inspect中的CpuShares值</p></blockquote><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54" target="_blank" rel="noopener">https://blog.softwaremill.com/docker-support-in-new-java-8-finally-fd595df0ca54</a></li><li><a href="https://www.chainnews.com/articles/631552101870.htm" target="_blank" rel="noopener">https://www.chainnews.com/articles/631552101870.htm</a></li><li><a href="https://stackoverflow.com/questions/54292282/clarification-of-meaning-new-jvm-memory-parameters-initialrampercentage-and-minr/54297753#54297753" target="_blank" rel="noopener">https://stackoverflow.com/questions/54292282/clarification-of-meaning-new-jvm-memory-parameters-initialrampercentage-and-minr/54297753#54297753</a></li><li><a href="https://www.cnblogs.com/yehaifeng/p/9596399.html" target="_blank" rel="noopener">https://www.cnblogs.com/yehaifeng/p/9596399.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;你是否曾经经历过在Docker中运行基于JVM的应用程序时出
      
    
    </summary>
    
      <category term="Docker" scheme="https://sulangsss.github.io/categories/Docker/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/categories/Docker/JVM/"/>
    
    
      <category term="Docker" scheme="https://sulangsss.github.io/tags/Docker/"/>
    
      <category term="JVM" scheme="https://sulangsss.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Mockito</title>
    <link href="https://sulangsss.github.io/2019/05/28/TDD/Mockito/"/>
    <id>https://sulangsss.github.io/2019/05/28/TDD/Mockito/</id>
    <published>2019-05-28T11:51:19.000Z</published>
    <updated>2019-06-18T12:00:27.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-1-4-39a85e42b8" target="_blank" rel="noopener">https://medium.com/joe-tsai/mockk-%E4%B8%80%E6%AC%BE%E5%BC%B7%E5%A4%A7%E7%9A%84-kotlin-mocking-library-part-1-4-39a85e42b8</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title=&quot;Reference&quot;&gt;&lt;/a&gt;Reference&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/joe-tsai
      
    
    </summary>
    
      <category term="TDD" scheme="https://sulangsss.github.io/categories/TDD/"/>
    
    
      <category term="TDD" scheme="https://sulangsss.github.io/tags/TDD/"/>
    
      <category term="Mockito" scheme="https://sulangsss.github.io/tags/Mockito/"/>
    
  </entry>
  
  <entry>
    <title>How to calculate margin?</title>
    <link href="https://sulangsss.github.io/2019/05/28/Futures/How-to-calculate-margin/"/>
    <id>https://sulangsss.github.io/2019/05/28/Futures/How-to-calculate-margin/</id>
    <published>2019-05-28T02:25:22.000Z</published>
    <updated>2019-05-28T07:21:31.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Margin = Collateral + uGnL + eGnL</p><blockquote><p>uGnL ：Unrealized Gains and Losses; eGnL ：Estimated Gains and Losses.</p></blockquote><ul><li>Margin Requirements are requirements on margins for the user to perform certain actions. </li><li>Initial Margin is required to increase a position.</li><li>Maintenance Margin to keep a position. </li></ul><hr><h3 id="Margin-Impacts"><a href="#Margin-Impacts" class="headerlink" title="Margin Impacts"></a>Margin Impacts</h3><img src="/2019/05/28/Futures/How-to-calculate-margin/margin_impact.png"><p>Positions and orders all require a certain amount of margin and, at the same time(同时), impact(影响) available margin. In the table above, we categorize positions and orders and show how their requirements and impacts are determined when considered separately.</p><p>Under margin impact, we further classify different impacts into 3 sub-categories: <strong>settled</strong>, <strong>unsettled</strong>, and <strong>probable</strong>.</p><ul><li><p>Settled margin impacts have already been settled. So to calculate available margin, settled margin impacts should be left out(忽略，不考虑), as they have already been incorporated(合并的) into collateral balance. </p></li><li><p>Unsettled margin impacts are <strong>unrealized PnL</strong>, <strong>accrued interests</strong>, and <strong>fee</strong>, <strong>unsettled</strong>, but payable if a settlement occurs right away. </p></li><li><p>Probable margin impact consider a probable scenario or a possible scenario where most negative impact happens.</p></li></ul><hr><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><p>A container is a collection of positions and open orders under the same Portfolio, sharing the same margin pool in their common settlement currency.</p><p>Under a portfolio, positions settled in the same currency will be collected into the same container with a communal margin shared among them. A winning position’s unrealized profit adds to collateral, bolsters(支持,支撑) the shared margin, and helps avoid liquidation of other losing positions in the container.</p><p>To segregate  positions settled in a common currency, consider allocate them to different portfolios.</p><h4 id="Aggregate-总体的-合计的-Requirements-amp-Impacts"><a href="#Aggregate-总体的-合计的-Requirements-amp-Impacts" class="headerlink" title="Aggregate(总体的,合计的) Requirements &amp; Impacts"></a>Aggregate(总体的,合计的) Requirements &amp; Impacts</h4><p>Aggregating margin requirements and impacts at the portfolio level isn’t simply adding them up. Instead, it is another exercise of finding out the worst scenario(情形,情况) that demands the most collateral. The aggregation is done at 2 layers.</p><p><strong>Contract Level</strong></p><p>At the contract level, we collect all orders and position for the contract and then:</p><ol><li>Convert incoming market orders into incoming limit orders;</li><li>Categorize open orders and incoming limit orders buy orders and sell orders;</li><li>With everything else (market price, model price, etc.) held equal, consider 2 scenarios<ol><li>All buy orders filled at their limit prices;</li><li>All sell orders filled at their limit prices;</li></ol></li></ol><p>Given current position holdings, either of the scenarios where a bigger collateral is demanded shall be considered in checking margin sufficiency and determining free collateral.</p><p>In the expression above, <strong>subscript o denotes orders on either buy or sell side</strong>. The scenario under which the expression evaluates to be bigger, In the following calculation.</p><p>At contract level, the required margin and margin impact are the following formula evaluated in the worse scenario.</p><img src="/2019/05/28/Futures/How-to-calculate-margin/worst_required_margin_and_impact_margin_formula.png"><p><strong>Portfolio Level</strong></p><p>At the portfolio level, contracts are grouped by their settlement currency into containers. So the Required Margin and Margin Impact for a portfolio and specific settlement currency, is the summations of contract level RM and MI.</p><p><strong>Margin Sufficiency</strong></p><p>When checking for margin sufficiency at portfolio level (i.e. container level), we simply evaluate the inequality below across contracts under the container in question.</p><img src="/2019/05/28/Futures/How-to-calculate-margin/margin_suffiency.png"><p>The left hand side is simply collateral adjusted by <strong>margin impacts</strong> from positions and their related orders in the container.</p><p>The right hand side of the inequality computes the required margin for the container by summing up the <strong>required margin for each contract</strong>.</p><p><strong>Free Collateral</strong></p><p>Free collateral is the amount of collateral that can be removed from a container. Removing such amount must not:</p><ul><li>Immediately cause <strong>liquidation</strong> or auto deleveraging of positions in the container;</li><li>Cause the container to be <strong>insufficient</strong> for the initial margin requirement;</li><li>Exceed the total collateral in the container.</li></ul><p>So the free collateral value for a container is the smaller of the 2 values below:</p><img src="/2019/05/28/Futures/How-to-calculate-margin/free_collateral_formula.png"><p><strong>Margin Coverage</strong></p><p>Margin coverage ratios show how much margin one has to cover the margin requirements imposed on a container. They are defined as <strong>IMC</strong> and <strong>MMC</strong>.</p><img src="/2019/05/28/Futures/How-to-calculate-margin/IMC_MMC_formula.png"><p>When a container’s <strong>IMC falls below 1</strong>, a trader will not be able to increase the size of positions in it. And so on our trading terminal, when <strong>IMC falls lower than 1</strong>, its indicator will lit up in red.</p><p>When a container’s MMC falls towards 1, a liquidation looms imminent. Unlike IMC, which can stay below 1 for a period, once MMC touches 1, liquidation kicks in and almost instantly brings MMC above 1. To warning users about the approaching liquidation, <strong>we lit the MMC indicator in red when the following ratio falls below 1</strong>.</p><img src="/2019/05/28/Futures/How-to-calculate-margin/MMC_formula.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Margin = Collateral + uGnL + e
      
    
    </summary>
    
      <category term="Futures" scheme="https://sulangsss.github.io/categories/Futures/"/>
    
    
      <category term="Futures" scheme="https://sulangsss.github.io/tags/Futures/"/>
    
      <category term="Margin" scheme="https://sulangsss.github.io/tags/Margin/"/>
    
  </entry>
  
  <entry>
    <title>正确输出Log的姿势</title>
    <link href="https://sulangsss.github.io/2019/05/26/Java/Log/%E6%AD%A3%E7%A1%AE%E8%BE%93%E5%87%BALog%E7%9A%84%E5%A7%BF%E5%8A%BF/"/>
    <id>https://sulangsss.github.io/2019/05/26/Java/Log/正确输出Log的姿势/</id>
    <published>2019-05-26T10:54:22.000Z</published>
    <updated>2019-05-26T13:43:18.510Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Slf4j"><a href="#Slf4j" class="headerlink" title="Slf4j"></a>Slf4j</h3><p>全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 commons-logging 是一样的概念，它们都不是具体的日志框架，你可以指定其他主流的日志实现框架。</p><hr><h3 id="Log级别及使用说明"><a href="#Log级别及使用说明" class="headerlink" title="Log级别及使用说明"></a>Log级别及使用说明</h3><img src="/2019/05/26/Java/Log/正确输出Log的姿势/log-level.png"><table><thead><tr><th>日志级别</th><th>描述</th></tr></thead><tbody><tr><td>OFF</td><td>关闭：最高级别，不输出日志。</td></tr><tr><td>FATAL</td><td>致命：输出非常严重的可能会导致应用程序终止的错误。</td></tr><tr><td>ERROR</td><td>错误：输出错误，但应用还能继续运行。</td></tr><tr><td>WARN</td><td>警告：输出可能潜在的危险状况。</td></tr><tr><td>INFO</td><td>信息：输出应用运行过程的详细信息。</td></tr><tr><td>DEBUG</td><td>调试：输出更细致的对调试应用有用的信息。</td></tr><tr><td>TRACE</td><td>跟踪：输出更细致的程序运行轨迹。</td></tr><tr><td>ALL</td><td>所有：输出所有级别信息。</td></tr></tbody></table><p>日志输出关系，如下图所示：</p><img src="/2019/05/26/Java/Log/正确输出Log的姿势/output-level.png"><h4 id="日志场景说明"><a href="#日志场景说明" class="headerlink" title="日志场景说明"></a>日志场景说明</h4><ul><li>DEBUG：记录对调试程序有帮助的信息。</li><li>INFO：用来记录程序运行现场，虽然此处并未发生错误，但是对排查其他错误具有指导意义。</li><li>WARN：可以用来记录程序运行现场，但是更偏向于表明此处有出现潜在错误的可能。</li><li>ERROR：表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行。</li><li>FATAL：表明当前程序运行出现了严重的错误事件，并且将会导致应用程序中断。</li></ul><p>需要注意点：</p><ul><li>避免无效日志打印：日志配置设置 additivity=”false”。</li><li>区别对待错误日志：WARN 与 ERROR 都是与错误有关的日志级别，但不要一发生错误就笼统地输出 ERROR 级别日志。一些业务异常是可以通过引导重试就能恢复正常的，例如用户输入参数错误。在这种情况下，记录日志是为了在用户咨询时可以还原现场，如果输出为 ERROR 级别就不适合了。ERROR 级别只记录系统逻辑错误、异常或者违反重要的业务规则，其他错误都可以归为 WARN 级别。</li><li>保证记录内容完整：日志记录的内容包括现场上下文信息与异常堆栈信息。记录异常时，一定要输出异常堆栈，例如，logger.error(“xxxx: ${e.message}”, e)；日志中如果输出对象实例，要确保实例类重写了 toString() 方法，否则只输出对象的 hash code 值，没有意义。</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://juejin.im/post/5b9871895188255c57212459" target="_blank" rel="noopener">https://juejin.im/post/5b9871895188255c57212459</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Slf4j&quot;&gt;&lt;a href=&quot;#Slf4j&quot; class=&quot;headerlink&quot; title=&quot;Slf4j&quot;&gt;&lt;/a&gt;Slf4j&lt;/h3&gt;&lt;p&gt;全称：Simple Logging Facade for Java，即简单日志门面接口，和 Apache 的 com
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Log" scheme="https://sulangsss.github.io/categories/Java/Log/"/>
    
    
      <category term="Log" scheme="https://sulangsss.github.io/tags/Log/"/>
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>修昔底德陷阱</title>
    <link href="https://sulangsss.github.io/2019/05/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/%E4%BF%AE%E6%98%94%E5%BA%95%E5%BE%B7%E9%99%B7%E9%98%B1/"/>
    <id>https://sulangsss.github.io/2019/05/26/读书笔记/认知/修昔底德陷阱/</id>
    <published>2019-05-26T06:24:07.000Z</published>
    <updated>2019-05-26T06:10:24.405Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>“修昔底德陷阱”，是指<strong>一个新崛起的大国必然要挑战现存大国，而现存大国也必然会回应这种威胁，这样战争变得不可避免。</strong>此说法源自古希腊著名历史学家修昔底德，他认为，当一个崛起的大国与既有的统治霸主竞争时，双方面临的危险多数以战争告终。</p><p>这样的事例曾经发生在公元前5世纪，修昔底德自己的时代，新崛起的雅典震动了陆地霸主斯巴达，结果双方爆发了长达30年的战争，两国均遭毁灭。类似的事例也发生在16世纪的新崛起的新教英国与天主教的西班牙之间，以及19世纪末与20世纪初的老牌帝国英国与新兴强国日耳曼的德国之间。</p><hr><h3 id="修昔底德陷阱的由来"><a href="#修昔底德陷阱的由来" class="headerlink" title="修昔底德陷阱的由来"></a>修昔底德陷阱的由来</h3><p>修昔底德陷阱是古希腊大历史学家修昔底德在其不朽的名著—-《伯罗奔尼撒战争史》中阐述的一个核心思想，<strong>指新兴大国随着其力量的增强，一定会向老牌的霸权国家发起挑战，而老牌的霸权国家也一定会为了维护其霸权而全力打压新兴大国的崛起势头，甚至发动战争。</strong></p><p>《伯罗奔尼撒战争史》还指出：“使战争不可避免的真正原因是雅典势力的增长和因而引起斯巴达的恐惧。”但修昔底德并没有明确概括出修昔底德陷阱这个概念，而美国学者艾利森根据这一论断则提出“修昔底德陷阱”的概念，认为一个新崛起的大国必然要挑战现存大国，而现存大国也必然来回应这种威胁，这样战争变得不可避免。</p><p>2017年5月，这位美国著名国际问题专家、哈佛大学肯尼迪学院首任院长的格雷厄姆·艾利森（Graham Allison）出版了他的新书——《注定开战：美国和中国能否逃脱修昔底德陷阱？》（Destined for War: Can America and China Escape Thucydides’s Trap）。该书的出版，标志着这一概念的正式提出。</p><p>艾利森还说，我们不必成为中国的奴隶，但我们必须学会接受其强大，尽管有时它展示自己强大的方式令我们反感。而为了避免一场战争，这一点可能还不是我们必须要吞下最苦的药片。战争的风险是切实存在的，而其后果难以形容得可怕。</p><p>他特别强调第一次世界大战的典型性，说这次战争的根源就是新崛起的大国德国挑战了当时的现存大国英国，从而引发了世界灾难，正如同雅典挑战斯巴达，斯巴达便发动战争，导致整个希腊世界受到重创。</p><hr><h3 id="历史的回顾与思考"><a href="#历史的回顾与思考" class="headerlink" title="历史的回顾与思考"></a>历史的回顾与思考</h3><p>古希腊罗马的斯巴达和雅典的伯罗奔尼撒战争是修昔底德立论的现实基础，在艾利森看来，自是有着无可辩驳的逻辑和说服力，其他人类历史上的著名霸权兴衰交替的历史似乎也在佐证着他的论断。比如罗马和迦太基；西班牙和大英帝国；荷兰和大英帝国；法兰西帝国和大英帝国；德意志帝国和大英帝国；美利坚合众国和大日本帝国，和大英帝国，这些世界历史上著名的帝国之间的竞争和争斗，似乎也无不是如此的。再看中华帝国漫长的历史上，也是写满了霸权兴衰的斑斑血迹的，春秋五霸，战国七雄，秦汉相替，汉匈奴战争等等，都看不出有异曲不同工的妙处。</p><p>那么，在人类历史上究竟有没有不经过激烈的斗争甚至战争而实现的霸权的和平过渡呢？</p><p>应该说有的，最明显的例证就是大英帝国以和平的方式将霸权禅让给了美利坚合众国，但这一例证并不是在完全的意义上是如此的，因为大英帝国的霸权随着第二次世界大战的开始，已经处于分崩离析，土崩瓦解的局面下了，在欧洲，希特勒的德意志第三帝国横扫西欧大陆，一举打败了宿敌，号称世界第一陆上强国的法国，然后又兵锋直抵大英帝国的本土，上演了伦敦上空的大空战，之后又发动了巴巴罗莎计划，与苏维埃巨人苏联战成一团。</p><p>在远东，大日本帝国则早已占领中国的东北，建立了满洲国，七七事变后，又发动了全面的侵华战争，之后，又发动了太平洋战争，横扫了大英帝国在远东和东南亚的传统势力，大英帝国只剩下半条命，美利坚合众国则乘势崛起，不仅打败了所谓的大日本帝国，而且通过大西洋宪章，逼迫大英帝国的掌门人丘吉尔承诺殖民地独立，实质上也就是签下大英帝国解体的卖身契，所以说与其说是禅让，还不如说美国假途灭虢，或者说大英帝国只是将其残山剩水拿出来禅让于美国，不是将完整的霸权禅让于美国的，美利坚是以战争的手段夺得世界霸权的。这显然不同于经典的修昔底德陷阱，修昔底德陷阱过于简单地聚焦于两个大国之间的争霸，在概括第二次世界大战这样多个世界强国争霸的复杂局面时，就显得不够全面，不够贴切。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://baike.baidu.com/item/%E4%BF%AE%E6%98%94%E5%BA%95%E5%BE%B7%E9%99%B7%E9%98%B1" target="_blank" rel="noopener">https://baike.baidu.com/item/%E4%BF%AE%E6%98%94%E5%BA%95%E5%BE%B7%E9%99%B7%E9%98%B1</a></li><li><a href="https://zhuanlan.zhihu.com/p/45687804" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/45687804</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;“修昔底德陷阱”，是指&lt;strong&gt;一个新崛起的大国必然要
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/tags/%E8%AE%A4%E7%9F%A5/"/>
    
      <category term="修昔底德陷阱" scheme="https://sulangsss.github.io/tags/%E4%BF%AE%E6%98%94%E5%BA%95%E5%BE%B7%E9%99%B7%E9%98%B1/"/>
    
  </entry>
  
  <entry>
    <title>为什么牛奶宁可倒掉也不送人？</title>
    <link href="https://sulangsss.github.io/2019/05/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%A1%8C%E4%B8%9A/%E9%87%91%E8%9E%8D/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%89%9B%E5%A5%B6%E5%AE%81%E5%8F%AF%E5%80%92%E6%8E%89%E4%B9%9F%E4%B8%8D%E9%80%81%E4%BA%BA/"/>
    <id>https://sulangsss.github.io/2019/05/25/读书笔记/行业/金融/为什么牛奶宁可倒掉也不送人/</id>
    <published>2019-05-25T15:24:07.000Z</published>
    <updated>2019-05-25T16:59:17.163Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>为什么在大萧条的时候，资本家宁可倒掉牛奶也不愿意送人？</p><hr><h3 id="古典经济学"><a href="#古典经济学" class="headerlink" title="古典经济学"></a>古典经济学</h3><p>古典经济学，也就是亚当斯密和李嘉图那一套。古典经济学认为，<strong>自由竞争的市场机制这只”看不见的手”能够有效地调节资源配置并使其达到最优</strong>，而政府干预则会使得市场在某种程度扭曲，从而降低市场效率，所以<strong>政府管的越少越好</strong>。</p><p>这在上个世纪大萧条之前，是经济学界的主流观点，也广泛被资本主义国家政府接受。然而，<strong>市场并不是像古典经济学家假设的那样是可以达到完全竞争的</strong>，在现实社会中，很多因素导致市场失灵，市场失灵的结果就是<strong>资源错配</strong>——资本家卖不出去牛奶不得不倒掉的同时，穷人买不起食物不得不挨饿，这就是资源错配的结果。</p><hr><h3 id="资源错配的机理"><a href="#资源错配的机理" class="headerlink" title="资源错配的机理"></a>资源错配的机理</h3><p>市场的不完备性：</p><ul><li>滞后性</li><li>交易成本</li></ul><blockquote><p>机理是指为实现某一特定功能，一定的系统结构中各要素的内在工作方式以及诸要素在一定环境条件下相互联系、相互作用的运行规则和原理。</p></blockquote><h4 id="滞后性"><a href="#滞后性" class="headerlink" title="滞后性"></a>滞后性</h4><p>假设，今年猪肉价格很高，大家都动心了，但你即使现在立马开始养猪，那也至少要等几个月之后猪才能长大。而几个月后的市场行情，绝对不是现在的市场行情了。</p><p>大萧条之前的美国经济是怎样的？各个产业高速发展的黄金期（或者说过热期），各个产业都很繁荣，工人工资得以保障，消费水平上涨，那对牛奶等消费的需求就会程上升趋势。所以，奶农有扩大生产的动机。</p><p>但我们知道，市场有滞后性，<strong>大萧条来临的时候，其他产业出现问题，股票暴跌，工人失业，对牛奶的需求降低，牛奶价格暴跌</strong>。但奶农短期之内，无法对即时的市场做出反应，因为他现在的奶牛数量和生产量，都基于之前对未来的乐观市场局面的估计。他就算现在立马减少生产（卖牛或者杀牛），也要等几个月之后才能降下来产量。</p><p>那调整产量用的这几个月呢？牛奶生产出来了，然后呢？这就涉及到市场不完备的另一个特点了。</p><h4 id="交易成本"><a href="#交易成本" class="headerlink" title="交易成本"></a>交易成本</h4><p>大家要注意，在高度资本化和高度分工化的社会中，<strong>奶厂是不直接面对消费者的</strong>（消费者直接端着碗去养奶牛的人那里打奶，那是小农经济，跟我们讲的资本主义经济危机没有半毛钱关系。</p><p>牛奶从奶厂到消费者手里面，是有中间渠道和成本的。即使牛奶是免费的，消费者也不可能免费拿到牛奶。</p><p>为什么呢？牛奶消毒、储存、包装、运输、贩卖，都需要成本。这些成本，都是加到最后消费者要付的价格里面去的。哪怕资本家免费提供牛奶，运输工人免费运输，售货员甚至都不要工资，那包装盒总要钱的吧？储存总要钱的吧？运输车的汽油总要钱的吧？</p><p>当时大萧条的时候，社会是怎样的呢？<strong>工人普遍失业，没钱</strong>；就算奶厂白送牛奶，经过消毒、储存、包装、运输、贩卖这一系列程序，牛奶到商店里的价格，工人仍然买不起；工人买不起商店的牛奶；商店卖不出去牛奶，就不会进货；商店不进货，奶厂的牛奶就卖不出去；奶厂的牛奶卖不出去，就只能存着；储存需要电（低温），需要消毒，需要雇佣工人操作，都要钱的（而且存着也卖不出去，只会越存越多）。</p><p>所以，<strong>牛奶只能倒掉。</strong></p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>这就是由于市场的不完备性（滞后性和交易成本）导致的资源错配的典型案例。</p><p>所以，牛奶宁愿倒掉也不免费送人，是由于自由市场不完备造成的市场失灵的结果，说白了就是，奶厂的牛奶免费送人，工人也买不起，所以只能倒掉。这跟资本家的阴谋、为了维持价格宁愿不卖也要倒掉、万恶的资本主义、人性的丑恶没有一毛钱关系。</p><hr><h3 id="如何解决市场不完备带来的问题？"><a href="#如何解决市场不完备带来的问题？" class="headerlink" title="如何解决市场不完备带来的问题？"></a>如何解决市场不完备带来的问题？</h3><p>资源错配的根源找到了，就是市场不完备。那我们就<strong>让政府去解决市场不完备的问题</strong>。</p><h4 id="滞后性-1"><a href="#滞后性-1" class="headerlink" title="滞后性"></a>滞后性</h4><p>对此，政府就要出面，给奶农前瞻性的信息，让奶农知道，今年牛奶大涨价，并不能盲目扩大生产，否则明年大家都生产很多牛奶，奶价大跌，大家都受损——这里又涉及很复杂的社会心理层面的博弈问题，比如，政府是否有足够高的信誉。要是政府本身就没啥信用，腐败盛兴，那么调控就会出问题——你不让我们扩大生产，是不是就让你小姨子小舅子二姐夫三舅妈的厂子扩大生产，明年就便宜你们家亲戚了。</p><p>调控还可以是另一种形式——一个强有力的政府。商店里的牛奶不是卖不出去吗？我政府花钱买全买了，买了我发给公务员加餐也好，发给穷人当福利也好，给学校当营养餐也好，哪怕是买了我政府倒掉也好（至少奶厂不会倒闭了，奶农和工人不会破产了）。</p><p>这就要求你政府要强啊，该拿钱的时候要拿得出来啊（经济危机中牛奶真的是不值一提，花钱的地方海了去了，政府公信力和财力不够真的撑不下去）。</p><h4 id="交易成本-1"><a href="#交易成本-1" class="headerlink" title="交易成本"></a>交易成本</h4><p>这个也是政府可以操控的。你可以补贴啊：消毒、包装、储存、运输、售卖，你一环一环给它补贴，让这个环节流通起来，让交易成本降下来，自然而然，这个问题就解决了。</p><p>有人说了，是工人失业买不起牛奶，为啥不给工人发钱让他们买得起牛奶，尽给资本家补贴了？真是万恶的资本主义啊。</p><p>先理一下逻辑：</p><ul><li>工人为啥买不起牛奶？因为他失业了；</li><li>工人为啥失业？因为他的工厂倒闭了；</li><li>他的工厂为啥倒闭破产？因为东西卖不出去，所以资本家老板只能缩减生产，大幅裁员。</li></ul><p><strong>奶厂，就是这个社会生产的一环。</strong>只要政府能让奶厂这个环正常运转，那么奶农和奶厂工人就不会失业，他们就有工资拿，有工资拿就消费得起其他商品。</p><p>同样的，工人买不起牛奶，重要的不是补贴工人让他们买得起牛奶，而是让他们所在的行业这个环也运转起来，这样他们的工厂就不会减产裁员，工人就有工资拿，他们就买得起牛奶。</p><p>所以，<strong>宏观调控，就是对由于市场本身出问题而转不动的各行各业进行调控和补贴，让它们都转起来。只要各个环都转起来，经济就会正常运转。</strong></p><p>由此，可知为什么美国在大萧条后走出经济危机相对于很多国家比较容易了–<strong>美国政府很强大，也很有钱，而且公信力在国内还可以</strong>。</p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://www.zhihu.com/question/36274714" target="_blank" rel="noopener">https://www.zhihu.com/question/36274714</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;为什么在大萧条的时候，资本家宁可倒掉牛奶也不愿意送人？&lt;/p
      
    
    </summary>
    
      <category term="Finance" scheme="https://sulangsss.github.io/categories/Finance/"/>
    
    
      <category term="Finance" scheme="https://sulangsss.github.io/tags/Finance/"/>
    
      <category term="金融" scheme="https://sulangsss.github.io/tags/%E9%87%91%E8%9E%8D/"/>
    
      <category term="倒掉牛奶" scheme="https://sulangsss.github.io/tags/%E5%80%92%E6%8E%89%E7%89%9B%E5%A5%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java volatile 与 CAS 的区别</title>
    <link href="https://sulangsss.github.io/2019/05/13/Java/Advance/volatile%E4%B8%8ECAS%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://sulangsss.github.io/2019/05/13/Java/Advance/volatile与CAS的区别/</id>
    <published>2019-05-13T15:35:06.000Z</published>
    <updated>2019-05-13T16:36:44.218Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="锁的特性"><a href="#锁的特性" class="headerlink" title="锁的特性"></a>锁的特性</h4><p>锁具有两种主要特性：<strong>互斥</strong>和<strong>可见性</strong>。</p><ul><li>互斥指的是一次只允许一个线程持有某个特定的锁，因此可以保证共享数据内容的一致性；</li><li>可见性指的是必须确保锁被释放之前对共享数据的修改，随后获得锁的另一个线程能够知道该行为。</li></ul><h4 id="锁的代价"><a href="#锁的代价" class="headerlink" title="锁的代价"></a>锁的代价</h4><p>锁是用来做并发最简单的方式，当然其代价也是最高的。内核态的锁的时候需要操作系统进行一次上下文切换，加锁、释放锁会导致比较多的上下文切换和调度延时，等待锁的线程会被挂起直至锁释放。在上下文切换的时候，cpu之前缓存的指令和数据都将失效，对性能有很大的损失。操作系统对多线程的锁进行判断就像两姐妹在为一个玩具在争吵，然后操作系统就是能决定他们谁能拿到玩具的父母，这是很慢的。用户态的锁虽然避免了这些问题，但是其实它们只是在没有真实的竞争时才有效。</p><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有守护变量的锁，都采用独占的方式来访问这些变量，如果出现多个线程同时访问锁，那第一些线线程将被挂起，当线程恢复执行时，必须等待其它线程执行完他们的时间片以后才能被调度执行，在挂起和恢复执行过程中存在着很大的开销。锁还存在着其它一些缺点，当一个线程正在等待锁时，它不能做任何事。如果一个线程在持有锁的情况下被延迟执行，那么所有需要这个锁的线程都无法执行下去。如果被阻塞的线程优先级高，而持有锁的线程优先级低，将会导致优先级反转(Priority Inversion)。</p><h4 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h4><p>独占锁是一种<strong>悲观锁</strong>，synchronized就是一种独占锁，它假设最坏的情况，并且只有在确保其它线程不会造成干扰的情况下执行，会导致其它所有需要锁的线程挂起，等待持有锁的线程释放锁。而另一个更加有效的锁就是乐观锁。所谓<strong>乐观锁</strong>就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>与锁相比，volatile变量是一和更轻量级的同步机制，因为在使用这些变量时不会发生上下文切换和线程调度等操作，但是volatile变量也存在一些局限：<strong>不能用于构建原子的复合操作，因此当一个变量依赖旧值时就不能使用volatile变量。</strong></p><blockquote><p>所有读值操作都执行一个包含获取语义的读取操作，这些方法读取由参数address引用的值，然后使得CPU高速缓存内的相应字节失效；所有写值操作都执行一个包含释放语义的写入操作，这些方法将CPU高速缓存内的字节刷到内存中，然后将address参数引用的值修改为value参数所表示的值。</p></blockquote><p><strong>volatile变量具有”lock”的可见性，却不具备原子特性。</strong>也就是说线程能够自动发现volatile变量的最新值。volatile变量可以实现线程安全，但其应用有限。使用volatile变量的主要原因在于它使用非常简单，至少比使用锁机制要简单的多；其次便是性能原因了，某些情况下，它的性能要优于锁机制。此外，volatile操作不会造成阻塞。</p><p>使用volatile来确保线程安全的前提条件：</p><ul><li>对变量的写操作不依赖于当前值；</li><li>该变量没有包含在具有其他变量的不变式中。</li></ul><hr><h3 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h3><ul><li>all assignments of primitive types except for long and double</li><li>all assignments of references</li><li>all operations of java.concurrent.Atomic* classes</li><li>all assignments to volatile longs and doubles</li></ul><p><strong>常见的i++操作</strong></p><p>如果是非原子性操作，那么i++将分为三步完成：</p><ul><li>读取当前i的值；</li><li>对i进行自增；</li><li>写入i最新的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> var count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">dec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count -= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">fun <span class="title">getValue</span><span class="params">()</span>: Int </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有两个线程分别执行 inc() 和 dec() 操作，两个线程操作时序如下：</p><ol><li>Thread A 读取到 count 值为 0；</li><li>Thread B 读取到 count 值为 0；</li><li>Thread A inc()，count变成了 1；</li><li>Thread B dec()，变成了 -1；</li><li>Thread A 更新 count 的值为 1；</li><li>Thread B 更新 count 的值为 -1；</li></ol><p>执行的结果就是 Thread B 的写入操作覆盖了 Thread A的值。</p><p><strong>为什么long型赋值不是原子操作呢？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> foo = <span class="number">65465498L</span>;</span><br></pre></td></tr></table></figure><p>因为在实际中，Java会分两步写入这个long变量，先写32位，再写后32位。这样就线程不安全了。如果改成下面的就线程安全了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  volatile内部已经做了synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> foo;</span><br></pre></td></tr></table></figure><hr><h3 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVolatileAtomic</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    var count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    val threadCount = <span class="number">100</span></span><br><span class="line">    val volatileAtomic = TestVolatileAtomic()</span><br><span class="line">    var runningTimes = <span class="number">0</span></span><br><span class="line">    var errorTimes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        val countDownLatch = CountDownLatch(threadCount)</span><br><span class="line">        val startup = CountDownLatch(threadCount)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (index in <span class="number">0</span> until threadCount) &#123;</span><br><span class="line">            thread &#123;</span><br><span class="line">                startup.countDown()</span><br><span class="line">                <span class="comment">//  println("threadId $&#123;Thread.currentThread().id&#125; waiting")</span></span><br><span class="line">                startup.await()</span><br><span class="line">                volatileAtomic.inc()</span><br><span class="line">                countDownLatch.countDown()</span><br><span class="line">                <span class="comment">//  println("threadId $&#123;Thread.currentThread().id&#125; finish")</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        countDownLatch.await()</span><br><span class="line">        <span class="keyword">if</span> (volatileAtomic.count % threadCount != <span class="number">0</span>) &#123;</span><br><span class="line">            println(<span class="string">"count $&#123;volatileAtomic.count&#125;"</span>)</span><br><span class="line">            errorTimes += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        volatileAtomic.count = <span class="number">0</span></span><br><span class="line">        runningTimes += <span class="number">1</span></span><br><span class="line">        println(<span class="string">"runningTimes $runningTimes, errorTimes=$errorTimes"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">runningTimes 1128, errorTimes=9</span><br><span class="line">runningTimes 1129, errorTimes=9</span><br></pre></td></tr></table></figure><h4 id="Synchronized-确保”原子性”"><a href="#Synchronized-确保”原子性”" class="headerlink" title="Synchronized 确保”原子性”"></a>Synchronized 确保”原子性”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span> <span class="function">fun <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Atomic-Class-确保”原子性”"><a href="#Atomic-Class-确保”原子性”" class="headerlink" title="Atomic Class 确保”原子性”"></a>Atomic Class 确保”原子性”</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestVolatileAtomic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//  @Volatile</span></span><br><span class="line">    var count = AtomicInteger(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function">fun <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count.incrementAndGet()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://java-latte.blogspot.com/2012/10/what-is-atomicoperation-in-java-atomic.html" target="_blank" rel="noopener">http://java-latte.blogspot.com/2012/10/what-is-atomicoperation-in-java-atomic.html</a></li><li><a href="https://www.vogella.com/tutorials/JavaConcurrency/article.html" target="_blank" rel="noopener">https://www.vogella.com/tutorials/JavaConcurrency/article.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1152642" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1152642</a></li><li><a href="http://www.cnblogs.com/Mainz/p/3546347.html" target="_blank" rel="noopener">http://www.cnblogs.com/Mainz/p/3546347.html</a></li><li><a href="http://www.cnblogs.com/lucifer1982/archive/2008/03/23/1116981.html" target="_blank" rel="noopener">http://www.cnblogs.com/lucifer1982/archive/2008/03/23/1116981.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;锁的特性&quot;&gt;&lt;a href=&quot;#锁的特性&quot; cla
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="CAS" scheme="https://sulangsss.github.io/tags/CAS/"/>
    
      <category term="volatile" scheme="https://sulangsss.github.io/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>深入理解TCP握手</title>
    <link href="https://sulangsss.github.io/2019/05/09/Network/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    <id>https://sulangsss.github.io/2019/05/09/Network/TCP三次握手/</id>
    <published>2019-05-09T15:04:19.000Z</published>
    <updated>2019-05-18T15:59:02.156Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Three-way-Handshake"><a href="#Three-way-Handshake" class="headerlink" title="Three-way Handshake"></a>Three-way Handshake</h3><p>所谓三次握手(<strong>Three-way Handshake</strong>)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p><strong>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</strong>在 socket 编程中，客户端执行 connect() 时。将触发三次握手。</p><ol><li><p>第一次握手(SYN=1，seq=x)：客户端发送一个 TCP 的 SYN 标志位1的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里。发送完毕后，客户端进入 SYN_SEND 状态。</p></li><li><p>第二次握手(SYN=1，ACK=1, seq=y, ACKnum=x+1)：服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。发送完毕后，服务器端进入 SYN_RCVD 状态。</p></li><li><p>第三次握手(ACK=1，ACKnum=y+1)：客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。</p></li></ol><blockquote><p>SYN：同步序列编号（Synchronize Sequence Numbers），是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。<br>SYN攻击：利用TCP协议缺陷，发送了大量伪造的TCP连接请求，使得被攻击方资源耗尽，无法及时回应或处理正常的服务请求。一个正常的TCP连接需要三次握手，首先客户端发送一个包含SYN标志的数据包，其后服务器返回一个SYN/ACK的应答包，表示客户端的请求被接受，最后客户端再返回一个确认包ACK，这样才完成TCP连接。在服务器端发送应答包后，如果客户端不发出确认，服务器会等待到超时，期间这些半连接状态都保存在一个空间有限的缓存队列中；如果大量的SYN包发到服务器端后没有应答，就会使服务器端的TCP资源迅速耗尽，导致正常的连接不能进入，甚至会导致服务器的系统崩溃。</p></blockquote><hr><h3 id="Four-way-handshake"><a href="#Four-way-handshake" class="headerlink" title="Four-way handshake"></a>Four-way handshake</h3><p>断开 TCP 连接需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作，在 socket 编程中，任何一方执行 close() 操作即可产生挥手操作。</p><ol><li><p>第一次挥手(FIN=1，seq=x)：假设客户端想要关闭连接，客户端发送一个 FIN 标志位为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。</p></li><li><p>第二次挥手(ACK=1，ACKnum=x+1)：服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手(FIN=1，seq=y)：服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。</p></li><li><p>第四次挥手(ACK=1，ACKnum=y+1)：客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT 状态，等待可能出现的要求重传的 ACK 包。服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。</p></li></ol><hr><h3 id="SYN攻击"><a href="#SYN攻击" class="headerlink" title="SYN攻击"></a>SYN攻击</h3><p>SYN 攻击是一种典型的 DoS/DDoS 攻击。</p><p>在三次握手过程中，服务器发送 SYN-ACK 之后，收到客户端的 ACK 之前的 TCP 连接称为半连接(half-open connect)。此时服务器处于 SYN_RCVD 状态。当收到 ACK 后，服务器才能转入 ESTABLISHED 状态。</p><p>SYN 攻击指的是，攻击客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送SYN包，服务器回复确认包，并等待客户的确认。由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，导致目标系统运行缓慢，严重者会引起网络堵塞甚至系统瘫痪。</p><p><strong>如何检测SYN攻击？</strong></p><p>检测 SYN 攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。在 Linux/Unix 上可以使用系统自带的 netstats 命令来检测 SYN 攻击。</p><p><strong>如何防御 SYN 攻击？</strong></p><p>SYN攻击不能完全被阻止，除非将TCP协议重新设计。我们所做的是尽可能的减轻SYN攻击的危害，常见的防御 SYN 攻击的方法有如下几种：</p><ul><li>缩短超时（SYN Timeout）时间</li><li>增加最大半连接数</li><li>过滤网关防护</li><li>SYN cookies技术</li></ul><hr><h3 id="Attention"><a href="#Attention" class="headerlink" title="Attention"></a>Attention</h3><p>TCP 的三次握手最重要的就是协商传输数据用的序列号。那这个序列号究竟有些什么用呢？</p><p>这个序号能够帮助后续两端进行确认数据包是否收到，解决顺序、丢包问题；另外我们还可以看到有一个 win 字段，这是双方交流的窗口大小，这在每次传输数据过程中也会携带。主要是告诉对方，我窗口是这么大，别发多了或者别发太少。</p><p>TCP的特点是：</p><ul><li>顺序问题，依靠序号</li><li>丢包问题，依靠序号</li><li>流量控制，依靠滑动窗口</li><li>拥塞控制，依靠拥塞窗口+滑动窗口</li><li>连接维护，三次握手/四次挥手</li></ul><h4 id="顺序与丢包问题"><a href="#顺序与丢包问题" class="headerlink" title="顺序与丢包问题"></a>顺序与丢包问题</h4><p>由于数据在传输前我们已经有序号了，这里注意一下这个序号是随机的，重复的概率极低，避免了程序发生乱入的可能性。</p><p>由于我们每个数据包有序号，虽然发送与到达可能不是顺序的，但是TCP层收到数据后，可以根据序号进行重新排列；另外在这个排列过程中，发现有了1，2，3，5，6这几个包，一检查就知道4要么延时未到达，要么丢包了，等待重传。</p><p>这里需要重要说明的一点是。为了提升效率，TCP其实并不是收到一个包就发一个ack。那是如何ACK的呢？还是以上面为例，TCP收到了1，2，3，5，6这几个包，它可能会发送一个 ack(seq=3)的确认包，这样次一次确认了3个包。但是它不会发送 5，6的ack。因为4没有收到啊！一旦4延时到达或者重发到达，就会发送一个 ack(seq=6)，又一次确认了3个包。</p><h4 id="流量控制与拥塞控制"><a href="#流量控制与拥塞控制" class="headerlink" title="流量控制与拥塞控制"></a>流量控制与拥塞控制</h4><p>举例子说明，A给B发送数据，通过握手后，A知道B一次可以收 1000Byte 的数据（B有这么大的处理能力），那么这个时候滑动窗口就可以设置成 1000Byte。那是不是最后真的可以一次发这么多数据给B呢？还不是，这时候得问问拥塞窗口，老兄，现在网络情况怎么样？一次运 1000Byte 的数据有压力吗？拥塞窗口一通计算说不行，现在是高峰期，最多只能有 600Byte 的货上路。最终这次传数据的时候就是 600Byte。</p><blockquote><p>可以关注抓包数据的 win 值，一直在动态调整。</p></blockquote><p>每次能够发送多少数据，有这么一个公式：<strong>LastByteSend - LastByteAcked &lt;= min{cwnd,rwnd}</strong></p><blockquote><p>LastByteSend 是最后一个发送的字节的序号；LastByteAcked 最后一个被确认的字节的序号。</p></blockquote><p>这两个相减得到的是本次能够发送的数据，这个数据一定小于或等于 cwnd 与 rwnd 中最小的一个值。</p><hr><h3 id="Status-Machine"><a href="#Status-Machine" class="headerlink" title="Status Machine"></a>Status Machine</h3><h4 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h4><h4 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h4><hr><h3 id="是什么限制了你的连接"><a href="#是什么限制了你的连接" class="headerlink" title="是什么限制了你的连接"></a>是什么限制了你的连接</h3><p>以Nginx为服务端进行举例说明，当客户端调用 connect() 方式时，会向服务端发起三次握手操作，当连接建立成功，在服务器端会生成一个 socket 对象，称为接收数据的 socket。服务向客户端发起的 connect() 也会生成一个 socket 对象，该对象叫发送数据的 socket。</p><blockquote><p>确定一个 socket 所需的元素有：源IP、源Port、目标IP、目标Port和协议。</p></blockquote><p>这里之所针对收发数据分别建立不同的 socket 对象，主要是从效率和管理上考虑。</p><h4 id="连接上限是多少？"><a href="#连接上限是多少？" class="headerlink" title="连接上限是多少？"></a>连接上限是多少？</h4><p>在服务器监听端，IP 和 Port 都是固定的，那么只有客户端的 IP 和 Port 是可变化的，假设使用的是 IPv4，那么理论上的连接数应该是 2^32(IP) * 2^16(Port) = 2^48。但实际上是服务器端是不能建立这么多连接的，因为每一个 socket 都需要消耗内存，以及每一个进程的文件描述符是有上限的，这些都限制了最终的连接数。</p><h4 id="提高连接数的手段"><a href="#提高连接数的手段" class="headerlink" title="提高连接数的手段"></a>提高连接数的手段</h4><ol><li>多进程</li><li>多线程</li><li>IO多路复用</li><li>协程</li></ol><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="https://juejin.im/post/5cd103e2f265da03804383e1" target="_blank" rel="noopener">https://juejin.im/post/5cd103e2f265da03804383e1</a></li><li><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html" target="_blank" rel="noopener">https://hit-alibaba.github.io/interview/basic/network/TCP.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Three-way-Handshake&quot;&gt;&lt;a href=&quot;#Three-way-Handshake&quot; class=&quot;headerlink&quot; title=&quot;Three-way Handshake&quot;&gt;&lt;/a&gt;Three-way Handshake&lt;/h3&gt;&lt;p&gt;所谓
      
    
    </summary>
    
      <category term="Network" scheme="https://sulangsss.github.io/categories/Network/"/>
    
    
      <category term="Network" scheme="https://sulangsss.github.io/tags/Network/"/>
    
      <category term="TCP" scheme="https://sulangsss.github.io/tags/TCP/"/>
    
      <category term="三次握手" scheme="https://sulangsss.github.io/tags/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
      <category term="四次握手" scheme="https://sulangsss.github.io/tags/%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java Bean Memory</title>
    <link href="https://sulangsss.github.io/2019/05/08/Java/Advance/Java-Bean-Memory/"/>
    <id>https://sulangsss.github.io/2019/05/08/Java/Advance/Java-Bean-Memory/</id>
    <published>2019-05-08T05:13:06.000Z</published>
    <updated>2019-05-08T06:53:37.460Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="Java-Object-Structure"><a href="#Java-Object-Structure" class="headerlink" title="Java Object Structure"></a>Java Object Structure</h4><p>一个Java对象在Heap的表示，可以分为三部分：</p><ul><li>Object Header</li><li>Class Pointer</li><li>Fields</li></ul><p>每个普通Java对象在堆(heap)中都有一个头信息(object header)，头信息是必不可少的，记录着对象的状态。</p><img src="/2019/05/08/Java/Advance/Java-Bean-Memory/object_header.png"><ul><li>32位：hash(25) + age(4) + lock(3) = 32bit</li><li>64位：unused(25+1) + hash(31) + age(4) + lock(3) = 64bit</li></ul><p>在Java中，一切皆对象；每个类都有一个父类，Class Pointer就是当前对象父类的一个指针，在32位系统中，这个指针为4byte；在64位系统中，如果开启指针压缩(-XX:+UseCompressedOops)或者JVM堆的最大值小于32G，这个指针也是4byte，否则是8byte。</p><p>关于字段(Fields)，这里指的是类的实例字段；也就是说不包括静态字段，因为这个字段是共享内存的，只会存在一份。</p><h4 id="java-lang-Integer"><a href="#java-lang-Integer" class="headerlink" title="java.lang.Integer"></a>java.lang.Integer</h4><p>在32位系统上，计算java.lang.Integer对象内存占用。</p><p>Object Header和Pointer都是固定的，4 + 4 = 8 byte，数值int占用4 byte，所以总共占用 4 + 4 + 4 = 12byte。此外，Heap的内存分配是按照 8byte 对齐的，因此该对象实际内存占用是 16byte。</p><h4 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h4><p>在Java中还有一种特殊的对象，数组！这个对象有点特殊，它比其他对象多了一个属性：长度(length)。所以我们计算数组长度的时候，需要额外加上一个长度的字段，即一个int的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>4(object header) + 4(pointer) + 4(length) + 4*10(10个int大小) = 52byte，由于需要8位对齐，所以最终大小为 56byte。</p><hr><h3 id="节约内存原则"><a href="#节约内存原则" class="headerlink" title="节约内存原则"></a>节约内存原则</h3><h4 id="尽量使用基本类型，而不是包装类型"><a href="#尽量使用基本类型，而不是包装类型" class="headerlink" title="尽量使用基本类型，而不是包装类型"></a>尽量使用基本类型，而不是包装类型</h4><p>一个java.lang.Integer占用 16byte，而一个int占用 4byte，4:1 的比例！也就是说整数类的类型是基本类型内存的4倍！</p><h4 id="斟酌字段类型，在满足容量前提下，尽量用小字段"><a href="#斟酌字段类型，在满足容量前提下，尽量用小字段" class="headerlink" title="斟酌字段类型，在满足容量前提下，尽量用小字段"></a>斟酌字段类型，在满足容量前提下，尽量用小字段</h4><p>数据库建表的时候字段类型需要仔细推敲，同样JavaBean中的属性字段类型也需要仔细斟酌。不要吝啬使用short，byte，boolean，如果短类型能放下数据，尽量不要使用更长的类型。一个long比一个int才多4byte，但是你要想，如果内存中有100W个long，那就白白浪费了约4MB空间，不要小看这一点点的空间浪费，因为随便一个应用的JVM中，对象都能达到上千万！内存是节省出来的。</p><h4 id="如果可能，尽量用数组，少用集合"><a href="#如果可能，尽量用数组，少用集合" class="headerlink" title="如果可能，尽量用数组，少用集合"></a>如果可能，尽量用数组，少用集合</h4><p>你知道一个ArrayList集合，如果里面放了10个数字，占用多少内存吗？让我们算算：</p><p>ArrayList中有两个字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">* The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">* empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">* will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>Object Header占 4byte，Pointer占 4byte，一个int字段(size)占 4byte，elementData数组本身占 12(4+4+4)byte，数组中10个Integer对象占 10 × 16 = 160byte。所以整个集合空间大小为 4 + 4 + 4 + 12 + 160 = 184byte。</p><p>如果我们用int[]代替集合呢，12 + 4 × 10 = 52byte，对其后 56byte。集合跟数组的比例是 184:56，超过3:1。</p><p>数组中是可以使用基本类型的，但是集合中只能放包装类型！</p><p>如果实在需要使用集合，推荐一个比较节约内存的集合工具，fastutil。这里面包含了JKD集合中绝大部分的实现，而且比较省内存。</p><h4 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h4><p>以下方法根具体场景的数据有关系，可以根据实际情况进行激进优化节省内存。</p><ul><li>时间用long/int表示，不用 Date 或者 String。</li><li>短字符串如果能穷举或者转换成ascii表示，可以用long或者int表示。</li></ul><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul><li><a href="http://blog.lichengwu.cn/java/2014/01/05/building-memory-efficient-javabean/" target="_blank" rel="noopener">http://blog.lichengwu.cn/java/2014/01/05/building-memory-efficient-javabean/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;h4 id=&quot;Java-Object-Structure&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Bean" scheme="https://sulangsss.github.io/tags/Bean/"/>
    
      <category term="Memory" scheme="https://sulangsss.github.io/tags/Memory/"/>
    
  </entry>
  
</feed>
