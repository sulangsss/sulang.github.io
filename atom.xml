<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sulang blog</title>
  
  <subtitle>python java android django web</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulangsss.github.io/"/>
  <updated>2018-12-01T13:26:15.597Z</updated>
  <id>https://sulangsss.github.io/</id>
  
  <author>
    <name>sulang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Rust Scopes and Ownership</title>
    <link href="https://sulangsss.github.io/2019/09/01/Rust/Basic/Scopes/"/>
    <id>https://sulangsss.github.io/2019/09/01/Rust/Basic/Scopes/</id>
    <published>2019-09-01T05:24:03.000Z</published>
    <updated>2018-12-01T13:26:15.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>Scopes play an important part in ownership, borrowing, and lifetimes. </p><p>That is, they indicate to the compiler when borrows are valid, when resources can be freed, and when variables are created or destroyed.</p><h3 id="What’s-RAII"><a href="#What’s-RAII" class="headerlink" title="What’s RAII"></a>What’s RAII</h3><p> Rust enforces RAII, so whenever an object goes out of scope, its destructor is called and its owned resources are freed.</p><blockquote><p> RAII: Resource Acquisition Is Initialization</p></blockquote><p> This behavior shields against resource leak bugs, so you’ll never have to manually free memory or worry about memory leaks again! </p><p> Here’s a quick showcase:</p> <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">fn</span> <span class="title">create_box</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Allocate an integer on the heap</span></span><br><span class="line">    <span class="keyword">let</span> _box1 = <span class="built_in">Box</span>::new(<span class="number">3i32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `_box1` is destroyed here, and memory gets freed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Allocate an integer on the heap</span></span><br><span class="line">    <span class="keyword">let</span> _box2 = <span class="built_in">Box</span>::new(<span class="number">5i32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A nested scope:</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Allocate an integer on the heap</span></span><br><span class="line">        <span class="keyword">let</span> _box3 = <span class="built_in">Box</span>::new(<span class="number">4i32</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// `_box3` is destroyed here, and memory gets freed</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creating lots of boxes just for fun</span></span><br><span class="line">    <span class="comment">// There's no need to manually free memory!</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0u32</span>..<span class="number">1_000</span> &#123;</span><br><span class="line">        create_box();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `_box2` is destroyed here, and memory gets freed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memory analyzer：rustc main.rs &amp;&amp; valgrind ./main</p><h3 id="Destructor"><a href="#Destructor" class="headerlink" title="Destructor"></a>Destructor</h3><p>The notion of a destructor in Rust is provided through the <strong>Drop</strong> trait. The destructor is called when the resource goes out of scope. </p><p>This trait is not required to be implemented for every type, only implement it for your type if you require its own destructor logic.</p><p>showcase:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ToDrop</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> ToDrop &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"ToDrop is being dropped"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = ToDrop;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Made a ToDrop!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Made a ToDrop!</span><br><span class="line">ToDrop is being dropped</span><br></pre></td></tr></table></figure><h3 id="Ownership"><a href="#Ownership" class="headerlink" title="Ownership"></a>Ownership</h3><p>Because variables are in charge of freeing their own resources, <strong>resources can only have one owner</strong>.</p><p>This also prevents resources from being freed more than once. Note that not all variables own resources (e.g. references).</p><p>When doing assignments (let x = y) or passing function arguments by value (foo(x)), the ownership of the resources is transferred. <strong>In Rust-speak, this is known as a move.</strong></p><p><strong>After moving resources, the previous owner can no longer be used. This avoids creating dangling pointers.</strong></p><p>Example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes ownership of the heap allocated memory</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">destroy_box</span></span>(c: <span class="built_in">Box</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Destroying a box that contains &#123;&#125;"</span>, c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `c` is destroyed and the memory freed</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// _Stack_ allocated integer</span></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *Copy* `x` into `y` - no resources are moved</span></span><br><span class="line">    <span class="keyword">let</span> y = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Both values can be independently used</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;, and y is &#123;&#125;"</span>, x, y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `a` is a pointer to a _heap_ allocated integer</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">Box</span>::new(<span class="number">5i32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a contains: &#123;&#125;"</span>, a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *Move* `a` into `b`</span></span><br><span class="line">    <span class="keyword">let</span> b = a;</span><br><span class="line">    <span class="comment">// The pointer address of `a` is copied (not the data) into `b`.</span></span><br><span class="line">    <span class="comment">// Both are now pointers to the same heap allocated data, but</span></span><br><span class="line">    <span class="comment">// `b` now owns it.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! `a` can no longer access the data, because it no longer owns the</span></span><br><span class="line">    <span class="comment">// heap memory</span></span><br><span class="line">    <span class="comment">//println!("a contains: &#123;&#125;", a);</span></span><br><span class="line">    <span class="comment">// TODO ^ Try uncommenting this line</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// This function takes ownership of the heap allocated memory from `b`</span></span><br><span class="line">    destroy_box(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Since the heap memory has been freed at this point, this action would</span></span><br><span class="line">    <span class="comment">// result in dereferencing freed memory, but it's forbidden by the compiler</span></span><br><span class="line">    <span class="comment">// Error! Same reason as the previous Error</span></span><br><span class="line">    <span class="comment">//println!("b contains: &#123;&#125;", b);</span></span><br><span class="line">    <span class="comment">// TODO ^ Try uncommenting this line</span></span><br><span class="line">    <span class="comment">// error[E0382]: use of moved value: `a`</span></span><br><span class="line">    <span class="comment">// println!("a contains: &#123;&#125;", a)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，不论是b，还是a，在调用destroy_box()后，都失去了ownership。</p><h3 id="Borrowing"><a href="#Borrowing" class="headerlink" title="Borrowing"></a>Borrowing</h3><p>Most of the time, we’d like to access data without taking ownership over it. To accomplish this, Rust uses a <strong>borrowing</strong> mechanism. Instead of passing objects by value (T), objects can be passed by reference (&amp;T).</p><p>Example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This function takes ownership of a box and destroys it</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">eat_box_i32</span></span>(boxed_i32: <span class="built_in">Box</span>&lt;<span class="built_in">i32</span>&gt;) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Destroying box that contains &#123;&#125; on eat_box_i32 function"</span>, boxed_i32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function borrows an i32</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrow_i32</span></span>(borrowed_i32: &amp;<span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"This int is: &#123;&#125; on borrow_i32 function"</span>, borrowed_i32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Create a boxed i32, and a stacked i32</span></span><br><span class="line">    <span class="keyword">let</span> boxed_i32 = <span class="built_in">Box</span>::new(<span class="number">5_i32</span>);</span><br><span class="line">    <span class="keyword">let</span> stacked_i32 = <span class="number">6_i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Borrow the contents of the box. Ownership is not taken,</span></span><br><span class="line">    <span class="comment">// so the contents can be borrowed again.</span></span><br><span class="line">    borrow_i32(&amp;boxed_i32);</span><br><span class="line">    borrow_i32(&amp;stacked_i32);</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Take a reference to the data contained inside the box</span></span><br><span class="line">        <span class="keyword">let</span> _ref_to_i32: &amp;<span class="built_in">i32</span> = &amp;boxed_i32;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error!</span></span><br><span class="line">        <span class="comment">// Can't destroy `boxed_i32` while the inner value is borrowed.</span></span><br><span class="line">        <span class="comment">// eat_box_i32(boxed_i32);</span></span><br><span class="line">        <span class="comment">// FIXME ^ Comment out this line</span></span><br><span class="line">        borrow_i32(&amp;_ref_to_i32);</span><br><span class="line">        <span class="comment">// `_ref_to_i32` goes out of scope and is no longer borrowed.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `boxed_i32` can now give up ownership to `eat_box` and be destroyed</span></span><br><span class="line">     eat_box_i32(boxed_i32);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在block里面，调用eat_box_i32()尝试destroy boxed_i32前，boxed_i32已经被_ref_to_i32借用了，而且eat_box_i32()被包含在_ref_to_i32的scope里面，此时，eat_box_i32()试图destroy boxed_i32是不可能的事情。</p><h4 id="Mutability"><a href="#Mutability" class="headerlink" title="Mutability"></a>Mutability</h4><p>Mutable data can be mutably borrowed using &amp;mut T. This is called a mutable reference and gives read/write access to the borrower. </p><p>In contrast, &amp;T borrows the data via an immutable reference, and the borrower can read the data but not modify it:</p><p>Example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(dead_code)]</span></span><br><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Book</span></span> &#123;</span><br><span class="line">    <span class="comment">// `&amp;'static str` is a reference to a string allocated in read only memory</span></span><br><span class="line">    author: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    title: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">    year: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a reference to a book</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">borrow_book</span></span>(book: &amp;Book) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I immutably borrowed &#123;&#125; - &#123;&#125; edition"</span>, book.title, book.year);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a reference to a mutable book and changes `year` to 2014</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new_edition</span></span>(book: &amp;<span class="keyword">mut</span> Book) &#123;</span><br><span class="line">    book.year = <span class="number">2014</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I mutably borrowed &#123;&#125; - &#123;&#125; edition"</span>, book.title, book.year);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Create an immutable Book named `immutabook`</span></span><br><span class="line">    <span class="keyword">let</span> immutabook = Book &#123;</span><br><span class="line">        <span class="comment">// string literals have type `&amp;'static str`</span></span><br><span class="line">        author: <span class="string">"Douglas Hofstadter"</span>,</span><br><span class="line">        title: <span class="string">"Gödel, Escher, Bach"</span>,</span><br><span class="line">        year: <span class="number">1979</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a mutable copy of `immutabook` and call it `mutabook`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mutabook = immutabook;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immutably borrow an immutable object</span></span><br><span class="line">    borrow_book(&amp;immutabook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immutably borrow a mutable object</span></span><br><span class="line">    borrow_book(&amp;mutabook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Borrow a mutable object as mutable</span></span><br><span class="line">    new_edition(&amp;<span class="keyword">mut</span> mutabook);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error! Cannot borrow an immutable object as mutable</span></span><br><span class="line">    <span class="comment">// new_edition(&amp;mut immutabook);</span></span><br><span class="line">    <span class="comment">// FIXME ^ Comment out this line</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> modify_immute_book = immutabook;</span><br><span class="line">    new_edition(&amp;<span class="keyword">mut</span> modify_immute_book)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Freezing"><a href="#Freezing" class="headerlink" title="Freezing"></a>Freezing</h4><p>When data is immutably borrowed, it also freezes. Frozen data can’t be modified via the original object until all references to it go out of scope:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> _mutable_integer = <span class="number">7i32</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Borrow `_mutable_integer`</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> _large_integer = &amp;_mutable_integer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error! `_mutable_integer` is frozen in this scope</span></span><br><span class="line">        <span class="comment">// cannot assign to `_mutable_integer` because it is borrowed</span></span><br><span class="line">        <span class="comment">// _mutable_integer = 50;</span></span><br><span class="line">        <span class="comment">// FIXME ^ Comment out this line</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"before :&#123;&#125;"</span>, _large_integer);</span><br><span class="line">        _large_integer = &amp;<span class="number">30i32</span>;</span><br><span class="line">        <span class="comment">// `_large_integer` goes out of scope</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"after :&#123;&#125;"</span>, _large_integer)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ok! `_mutable_integer` is not frozen in this scope</span></span><br><span class="line">    _mutable_integer = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Aliasing"><a href="#Aliasing" class="headerlink" title="Aliasing"></a>Aliasing</h4><p>Data can be immutably borrowed any number of times, but while immutably borrowed, the original data can’t be mutably borrowed. On the other hand, only one mutable borrow is allowed at a time. The original data can be borrowed again only after the mutable reference goes out of scope.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>, z: <span class="built_in">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> point = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> borrowed_point = &amp;point;</span><br><span class="line">        <span class="keyword">let</span> another_borrow = &amp;point;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Data can be accessed via the references and the original owner</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Point has coordinates: (&#123;&#125;, &#123;&#125;, &#123;&#125;)"</span>,</span><br><span class="line">                 borrowed_point.x, another_borrow.y, point.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error! Can't borrow point as mutable because it's currently</span></span><br><span class="line">        <span class="comment">// borrowed as immutable.</span></span><br><span class="line">        <span class="comment">//let mutable_borrow = &amp;mut point;</span></span><br><span class="line">        <span class="comment">// TODO ^ Try uncommenting this line</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Immutable references go out of scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> mutable_borrow = &amp;<span class="keyword">mut</span> point;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Change data via mutable reference</span></span><br><span class="line">        mutable_borrow.x = <span class="number">5</span>;</span><br><span class="line">        mutable_borrow.y = <span class="number">2</span>;</span><br><span class="line">        mutable_borrow.z = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error! Can't borrow `point` as immutable because it's currently</span></span><br><span class="line">        <span class="comment">// borrowed as mutable.</span></span><br><span class="line">        <span class="comment">//let y = &amp;point.y;</span></span><br><span class="line">        <span class="comment">// TODO ^ Try uncommenting this line</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Error! Can't print because `println!` takes an immutable reference.</span></span><br><span class="line">        <span class="comment">//println!("Point Z coordinate is &#123;&#125;", point.z);</span></span><br><span class="line">        <span class="comment">// TODO ^ Try uncommenting this line</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ok! Mutable references can be passed as immutable to `println!`</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Point has coordinates: (&#123;&#125;, &#123;&#125;, &#123;&#125;)"</span>,</span><br><span class="line">                 mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutable reference goes out of scope</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Immutable references to point are allowed again</span></span><br><span class="line">    <span class="keyword">let</span> borrowed_point = &amp;point;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Point now has coordinates: (&#123;&#125;, &#123;&#125;, &#123;&#125;)"</span>,</span><br><span class="line">             borrowed_point.x, borrowed_point.y, borrowed_point.z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在第一个block里面，point已经被borrowed_point借用，此时如果试图进行mutable borrow是禁止的，但是immutable是可以多次的。即，如果一个对象已经被borrow了，都不能再进行mutable borrrow，除非borrow已经结束。</p></li><li><p>在第二个block里面，point已经被mutable borrow，此时即使是immutable borrow也是不允许的。</p></li></ul><h3 id="The-Ref-Pattern"><a href="#The-Ref-Pattern" class="headerlink" title="The Ref Pattern"></a>The Ref Pattern</h3><p>When doing pattern matching or destructuring via the let binding, the ref keyword can be used to take references to the fields of a struct/tuple. </p><p>The example below shows a few instances where this can be useful:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Clone, Copy)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="string">'Q'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A `ref` borrow on the left side of an assignment is equivalent to</span></span><br><span class="line">    <span class="comment">// an `&amp;` borrow on the right side.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">ref</span> ref_c1 = c;</span><br><span class="line">    <span class="keyword">let</span> ref_c2 = &amp;c;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"ref_c1 equals ref_c2: &#123;&#125;"</span>, *ref_c1 == *ref_c2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> point = Point &#123; x: <span class="number">1</span>, y: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `ref` is also valid when destructuring a struct.</span></span><br><span class="line">    <span class="keyword">let</span> _copy_of_x = &#123;</span><br><span class="line">        <span class="comment">// `ref_to_x` is a reference to the `x` field of `point`.</span></span><br><span class="line">        <span class="keyword">let</span> Point &#123; x: <span class="keyword">ref</span> ref_to_x, y: _ &#125; = point;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Return a copy of the `x` field of `point`.</span></span><br><span class="line">        *ref_to_x</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"copy_of_x: &#123;&#125;"</span>, _copy_of_x);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A mutable copy of `point`</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mutable_point = point;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// `ref` can be paired with `mut` to take mutable references.</span></span><br><span class="line">        <span class="keyword">let</span> Point &#123; x: _, y: <span class="keyword">ref</span> <span class="keyword">mut</span> mut_ref_to_y &#125; = mutable_point;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Mutate the `y` field of `mutable_point` via a mutable reference.</span></span><br><span class="line">        *mut_ref_to_y = <span class="number">3</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"point is (&#123;&#125;, &#123;&#125;)"</span>, point.x, point.y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"mutable_point is (&#123;&#125;, &#123;&#125;)"</span>, mutable_point.x, mutable_point.y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A mutable tuple that includes a pointer</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> mutable_tuple = (<span class="built_in">Box</span>::new(<span class="number">5u32</span>), <span class="number">3u32</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"original tuple is &#123;:?&#125;"</span>, mutable_tuple);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Destructure `mutable_tuple` to change the value of `last`.</span></span><br><span class="line">        <span class="keyword">let</span> (_, <span class="keyword">ref</span> <span class="keyword">mut</span> last) = mutable_tuple;</span><br><span class="line">        *last = <span class="number">2u32</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"tuple is &#123;:?&#125;"</span>, mutable_tuple);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ref_c1 equals ref_c2: <span class="literal">true</span></span><br><span class="line">copy_of_x: 1</span><br><span class="line">point is (1, 0)</span><br><span class="line">mutable_point is (1, 3)</span><br><span class="line">original tuple is (5, 3)</span><br><span class="line">tuple is (5, 2)</span><br></pre></td></tr></table></figure><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://doc.rust-lang.org/stable/rust-by-example" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/rust-by-example</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;Scopes play an important part 
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Rust/Basic/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Primer" scheme="https://sulangsss.github.io/tags/Primer/"/>
    
      <category term="Scopes" scheme="https://sulangsss.github.io/tags/Scopes/"/>
    
      <category term="Ownership" scheme="https://sulangsss.github.io/tags/Ownership/"/>
    
  </entry>
  
  <entry>
    <title>Rust Lifetimes</title>
    <link href="https://sulangsss.github.io/2019/09/01/Rust/Basic/Lifetimes/"/>
    <id>https://sulangsss.github.io/2019/09/01/Rust/Basic/Lifetimes/</id>
    <published>2019-09-01T05:24:03.000Z</published>
    <updated>2018-12-01T10:22:59.265Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>A lifetime is a construct the compiler (or more specifically, its borrow checker) uses to ensure all borrows are valid. </p><p>Specifically, a variable’s lifetime begins when it is created and ends when it is destroyed. <strong>While lifetimes and scopes are often referred to together, they are not the same.</strong></p><p>Take, for example, the case where we borrow a variable via &amp;. The borrow has a lifetime that is determined by where it is declared. </p><p>As a result, <strong>the borrow is valid as long as it ends before the lender is destroyed. However, the scope of the borrow is determined by where the reference is used.</strong></p><p>showcase:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lifetimes are annotated below with lines denoting the creation</span></span><br><span class="line"><span class="comment">// and destruction of each variable.</span></span><br><span class="line"><span class="comment">// `i` has the longest lifetime because its scope entirely encloses</span></span><br><span class="line"><span class="comment">// both `borrow1` and `borrow2`. The duration of `borrow1` compared</span></span><br><span class="line"><span class="comment">// to `borrow2` is irrelevant since they are disjoint.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">3</span>; <span class="comment">// Lifetime for `i` starts. ────────────────┐</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow1 = &amp;i; <span class="comment">// `borrow1` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow1: &#123;&#125;"</span>, borrow1); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow1 ends. ──────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">    &#123; <span class="comment">//                                                   │</span></span><br><span class="line">        <span class="keyword">let</span> borrow2 = &amp;i; <span class="comment">// `borrow2` lifetime starts. ──┐│</span></span><br><span class="line">        <span class="comment">//                                                ││</span></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"borrow2: &#123;&#125;"</span>, borrow2); <span class="comment">//              ││</span></span><br><span class="line">    &#125; <span class="comment">// `borrow2` ends. ─────────────────────────────────┘│</span></span><br><span class="line">    <span class="comment">//                                                     │</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that no names or types are assigned to label lifetimes. This restricts how lifetimes will be able to be used as we will see.</p><p>需要注意的是，lifetime需要开发人员自己去标记出来，IDE并不会帮助你标记一个变量的lifetime。</p><p>从上面的代码可知，i的lifetime和scope的周期完全不同，scope周期 &lt;= lifetime周期。</p><hr><h3 id="Elision-annotation"><a href="#Elision-annotation" class="headerlink" title="Elision annotation"></a>Elision annotation</h3><p>Some lifetime patterns are overwhelmingly(强制地) common and so the borrow checker will implicitly add them to save typing and to improve readability. This process of implicit addition is called elision. Elision exists in Rust solely because these patterns are common.</p><p>The following code shows a few examples of elision. For a more comprehensive description of elision</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `elided_input` and `annotated_input` essentially have identical signatures</span></span><br><span class="line"><span class="comment">// because the lifetime of `elided_input` is elided by the compiler:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">elided_input</span></span>(x: &amp;<span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`elided_input`: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">annotated_input</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`annotated_input`: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similarly, `elided_pass` and `annotated_pass` have identical signatures</span></span><br><span class="line"><span class="comment">// because the lifetime is added implicitly to `elided_pass`:</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">elided_pass</span></span>(x: &amp;<span class="built_in">i32</span>) -&gt; &amp;<span class="built_in">i32</span> &#123; x &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">annotated_pass</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">i32</span> &#123; x &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    elided_input(&amp;x);</span><br><span class="line">    annotated_input(&amp;x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`elided_pass`: &#123;&#125;"</span>, elided_pass(&amp;x));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`annotated_pass`: &#123;&#125;"</span>, annotated_pass(&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Ignoring elision, function signatures with lifetimes have a few constraints:</p><ul><li>any reference must have an annotated lifetime.</li><li>any reference being returned must have the same lifetime as an input or be static.</li></ul><p>Additionally, note that returning references without input is banned if it would result in returning references to invalid data. The following example shows off(强调) some valid forms of functions with lifetimes:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// One input reference with lifetime `'a` which must live</span></span><br><span class="line"><span class="comment">// at least as long as the function.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_one</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`print_one`: x is &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutable references are possible with lifetimes as well.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_one</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    *x += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Multiple elements with different lifetimes. In this case, it</span></span><br><span class="line"><span class="comment">// would be fine for both to have the same lifetime `'a`, but</span></span><br><span class="line"><span class="comment">// in more complex cases, different lifetimes may be required.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_multi</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"`print_multi`: x is &#123;&#125;, y is &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returning references that have been passed in is acceptable.</span></span><br><span class="line"><span class="comment">// However, the correct lifetime must be returned.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">pass_x</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>, _: &amp;<span class="symbol">'b</span> <span class="built_in">i32</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">i32</span> &#123; x &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String &#123; &amp;String::from("foo") &#125;</span></span><br><span class="line"><span class="comment">// The above is invalid: `'a` must live longer than the function.</span></span><br><span class="line"><span class="comment">// Here, `&amp;String::from("foo")` would create a `String`, followed by a</span></span><br><span class="line"><span class="comment">// reference. Then the data is dropped upon exiting the scope, leaving</span></span><br><span class="line"><span class="comment">// a reference to invalid data to be returned.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    print_one(&amp;x);</span><br><span class="line">    print_multi(&amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> z = pass_x(&amp;x, &amp;y);</span><br><span class="line">    print_one(z);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> t = <span class="number">3</span>;</span><br><span class="line">    add_one(&amp;<span class="keyword">mut</span> t);</span><br><span class="line">    print_one(&amp;t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果function有返回值，则返回值必须声明lifetime。</p><hr><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Case-Explicit-annotation"><a href="#Case-Explicit-annotation" class="headerlink" title="Case: Explicit annotation"></a>Case: Explicit annotation</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// `print_refs` takes two references to `i32` which have different</span></span><br><span class="line"><span class="comment">// lifetimes `'a` and `'b`. These two lifetimes must both be at</span></span><br><span class="line"><span class="comment">// least as long as the function `print_refs`.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_refs</span></span>&lt;<span class="symbol">'a</span>, <span class="symbol">'b</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">i32</span>, y: &amp;<span class="symbol">'b</span> <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125; and y is &#123;&#125;"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A function which takes no arguments, but has a lifetime parameter `'a`.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">failed_borrow</span></span>&lt;<span class="symbol">'a</span>&gt;() &#123;</span><br><span class="line">    <span class="keyword">let</span> _x = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ERROR: `_x` does not live long enough</span></span><br><span class="line">    <span class="comment">//let y: &amp;'a i32 = &amp;_x;</span></span><br><span class="line">    <span class="comment">// Attempting to use the lifetime `'a` as an explicit type annotation</span></span><br><span class="line">    <span class="comment">// inside the function will fail because the lifetime of `&amp;_x` is shorter</span></span><br><span class="line">    <span class="comment">// than that of `y`. A short lifetime cannot be coerced into a longer one.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Create variables to be borrowed below.</span></span><br><span class="line">    <span class="keyword">let</span> (four, nine) = (<span class="number">4</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Borrows (`&amp;`) of both variables are passed into the function.</span></span><br><span class="line">    print_refs(&amp;four, &amp;nine);</span><br><span class="line">    <span class="comment">// Any input which is borrowed must outlive the borrower.</span></span><br><span class="line">    <span class="comment">// In other words, the lifetime of `four` and `nine` must</span></span><br><span class="line">    <span class="comment">// be longer than that of `print_refs`.</span></span><br><span class="line"></span><br><span class="line">    failed_borrow();</span><br><span class="line">    <span class="comment">// `failed_borrow` contains no references to force `'a` to be</span></span><br><span class="line">    <span class="comment">// longer than the lifetime of the function, but `'a` is longer.</span></span><br><span class="line">    <span class="comment">// Because the lifetime is never constrained, it defaults to `'static`.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;A lifetime is a construct the 
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Rust/Basic/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Primer" scheme="https://sulangsss.github.io/tags/Primer/"/>
    
      <category term="Lifetimes" scheme="https://sulangsss.github.io/tags/Lifetimes/"/>
    
  </entry>
  
  <entry>
    <title>Rust Higher Order Functions</title>
    <link href="https://sulangsss.github.io/2019/09/01/Rust/Basic/HigherOrderFunctions/"/>
    <id>https://sulangsss.github.io/2019/09/01/Rust/Basic/HigherOrderFunctions/</id>
    <published>2019-09-01T04:24:03.000Z</published>
    <updated>2018-12-01T05:09:18.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">is_odd</span></span>(n: <span class="built_in">u32</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">    n % <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Find the sum of all the squared odd numbers under 1000"</span>);</span><br><span class="line">    <span class="keyword">let</span> upper = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Imperative approach</span></span><br><span class="line">    <span class="comment">// Declare accumulator variable</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> acc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Iterate: 0, 1, 2, ... to infinity</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="number">0</span>.. &#123;</span><br><span class="line">        <span class="comment">// Square the number</span></span><br><span class="line">        <span class="keyword">let</span> n_squared = n * n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n_squared &gt;= upper &#123;</span><br><span class="line">            <span class="comment">// Break loop if exceeded the upper limit</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> is_odd(n_squared) &#123;</span><br><span class="line">            <span class="comment">// Accumulate value, if it's odd</span></span><br><span class="line">            acc += n_squared;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"imperative style: &#123;&#125;"</span>, acc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Functional approach</span></span><br><span class="line">    <span class="keyword">let</span> sum_of_squared_odd_numbers: <span class="built_in">u32</span> =</span><br><span class="line">        (<span class="number">0</span>..).map(|n| n * n)                             <span class="comment">// All natural numbers squared</span></span><br><span class="line">             .take_while(|&amp;n_squared| n_squared &lt; upper) <span class="comment">// Below upper limit</span></span><br><span class="line">             .filter(|&amp;n_squared| is_odd(n_squared))     <span class="comment">// That are odd</span></span><br><span class="line">             .fold(<span class="number">0</span>, |acc, n_squared| acc + n_squared); <span class="comment">// Sum them</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"functional style: &#123;&#125;"</span>, sum_of_squared_odd_numbers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;h4 id=&quot;Case-1&quot;&gt;&lt;a href=&quot;#Case-1&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Rust/Basic/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Primer" scheme="https://sulangsss.github.io/tags/Primer/"/>
    
      <category term="Higher Order Functions" scheme="https://sulangsss.github.io/tags/Higher-Order-Functions/"/>
    
  </entry>
  
  <entry>
    <title>Rust Closures</title>
    <link href="https://sulangsss.github.io/2019/09/01/Rust/Basic/Closures/"/>
    <id>https://sulangsss.github.io/2019/09/01/Rust/Basic/Closures/</id>
    <published>2019-09-01T04:24:03.000Z</published>
    <updated>2018-12-01T04:58:43.090Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><h4 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1"></a>Case 1</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Increment via closures and functions.</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">function</span></span>(i: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Closures are anonymous, here we are binding them to references</span></span><br><span class="line">    <span class="comment">// Annotation is identical to function annotation but is optional</span></span><br><span class="line">    <span class="comment">// as are the `&#123;&#125;` wrapping the body. These nameless functions</span></span><br><span class="line">    <span class="comment">// are assigned to appropriately named variables.</span></span><br><span class="line">    <span class="keyword">let</span> closure_annotated = |i: <span class="built_in">i32</span>| -&gt; <span class="built_in">i32</span> &#123; i + <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> closure_inferred = |i| i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Call the function and closures.</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"function: &#123;&#125;"</span>, function(i));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"closure_annotated: &#123;&#125;"</span>, closure_annotated(i));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"closure_inferred: &#123;&#125;"</span>, closure_inferred(i));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A closure taking no arguments which returns an `i32`.</span></span><br><span class="line">    <span class="comment">// The return type is inferred.</span></span><br><span class="line">    <span class="keyword">let</span> one = || <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"closure returning one: &#123;&#125;"</span>, one());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>: 2</span><br><span class="line">closure_annotated: 2</span><br><span class="line">closure_inferred: 2</span><br><span class="line">closure returning one: 1</span><br></pre></td></tr></table></figure><h4 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2"></a>Case 2</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::mem;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> color = <span class="string">"green"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A closure to print `color` which immediately borrows (`&amp;`)</span></span><br><span class="line">    <span class="comment">// `color` and stores the borrow and closure in the `print`</span></span><br><span class="line">    <span class="comment">// variable. It will remain borrowed until `print` goes out of</span></span><br><span class="line">    <span class="comment">// scope. `println!` only requires `by reference` so it doesn't</span></span><br><span class="line">    <span class="comment">// impose anything more restrictive.</span></span><br><span class="line">    <span class="keyword">let</span> print = || <span class="built_in">println!</span>(<span class="string">"`color`: &#123;&#125;"</span>, color);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the closure using the borrow.</span></span><br><span class="line">    print();</span><br><span class="line">    print();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A closure to increment `count` could take either `&amp;mut count`</span></span><br><span class="line">    <span class="comment">// or `count` but `&amp;mut count` is less restrictive so it takes</span></span><br><span class="line">    <span class="comment">// that. Immediately borrows `count`.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// A `mut` is required on `inc` because a `&amp;mut` is stored inside.</span></span><br><span class="line">    <span class="comment">// Thus, calling the closure mutates the closure which requires</span></span><br><span class="line">    <span class="comment">// a `mut`.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> inc = || &#123;</span><br><span class="line">        count += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"`count`: &#123;&#125;"</span>, count);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call the closure.</span></span><br><span class="line">    inc();</span><br><span class="line">    inc();</span><br><span class="line">    <span class="comment">// count = 10; error[E0506]: cannot assign to `count` because it is borrowed</span></span><br><span class="line">    <span class="comment">// println!("return count and change &#123;&#125;", count);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//let _reborrow = &amp;mut count;</span></span><br><span class="line">    <span class="comment">// ^ <span class="doctag">TODO:</span> try uncommenting this line.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// A non-copy type.</span></span><br><span class="line">    <span class="keyword">let</span> movable = <span class="built_in">Box</span>::new(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `mem::drop` requires `T` so this must take by value. A copy type</span></span><br><span class="line">    <span class="comment">// would copy into the closure leaving the original untouched.</span></span><br><span class="line">    <span class="comment">// A non-copy must move and so `movable` immediately moves into</span></span><br><span class="line">    <span class="comment">// the closure.</span></span><br><span class="line">    <span class="keyword">let</span> consume = || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"`movable`: &#123;:?&#125;"</span>, movable);</span><br><span class="line">        mem::<span class="built_in">drop</span>(movable);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// `consume` consumes the variable so this can only be called once.</span></span><br><span class="line">    consume();</span><br><span class="line">    <span class="comment">//consume();</span></span><br><span class="line">    <span class="comment">// ^ <span class="doctag">TODO:</span> Try uncommenting this line.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">`color`: green</span><br><span class="line">`color`: green</span><br><span class="line">`count`: 1</span><br><span class="line">`count`: 2</span><br><span class="line">`movable`: 3</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Example&quot;&gt;&lt;a href=&quot;#Example&quot; class=&quot;headerlink&quot; title=&quot;Example&quot;&gt;&lt;/a&gt;Example&lt;/h3&gt;&lt;h4 id=&quot;Case-1&quot;&gt;&lt;a href=&quot;#Case-1&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Rust/Basic/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Primer" scheme="https://sulangsss.github.io/tags/Primer/"/>
    
      <category term="Closures" scheme="https://sulangsss.github.io/tags/Closures/"/>
    
  </entry>
  
  <entry>
    <title>从ACID聊到CAP</title>
    <link href="https://sulangsss.github.io/2018/12/02/DistributedSystem/CAP/%E4%BB%8EACID%E8%81%8A%E5%88%B0CAP/"/>
    <id>https://sulangsss.github.io/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/</id>
    <published>2018-12-02T11:50:18.000Z</published>
    <updated>2018-12-02T11:59:41.034Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>在使用数据库的时候，心里会假定这里面的数据都是 100% 准确的。回想一下，你在工作中有没有这样做过：</p><ul><li>有人给你反映了一个问题，说数据错了，你的自然反应是去检查代码有没有问题，而不会想到去确认数据库有没有问题？</li><li>为了更快更方便地执行单元测试，你认为通过 Mock 数据加上断言（assertion）来代替数据库中实际存储的数据是完全没问题的。</li></ul><p>如果你这样做过，或者有过这样的看法，那你一定是在假定：<strong>数据都是100%准确的</strong>。</p><p>现在不妨来思考下，数据库为什么会使你有这样的认知？是因为数据库的开发团队对其测试到位吗？其实，真正起到决定性作用的是数据库背后的设计理念<strong>ACID</strong>。</p><h3 id="What’s-ACID"><a href="#What’s-ACID" class="headerlink" title="What’s ACID"></a>What’s ACID</h3><p>ACID: Atomicity, Consistency, Isolation, Durability。</p><p>Andreas Reuter 和 TheoHärder 这两位前辈在 1983 年提出它，指出一个数据库“事务”只要满足这4个特性，在任何情况下数据都能保证准确。</p><p><strong>“事务”是数据库的执行单元</strong>，除了我们平时用显式声明的 <strong>transaction</strong> 之类关键字包裹的代码外，每一条单独的SQL，也是以事务的形式执行的。比如，当你在一条SQL中同时 insert 多笔数据的时候，一旦发生异常，所有的这几笔数据最终都不会被插入到目标表中，会一并撤销。</p><p>在保证达到这个效果的过程中，ACID的四个特性分别起到了什么作用呢？</p><hr><h4 id="Atomicity"><a href="#Atomicity" class="headerlink" title="Atomicity"></a>Atomicity</h4><p>一句话来概括原子性，用于保证每个事务被视为单个完整的个体，不可分割。满足原子性的事务，要么完全成功，要么完全失败，不允许存在其他中间状态。</p><p>通常这点指的是我们同时执行多条SQL语句的时候，可以将这些SQL语句的生效与否捆绑到一起，以保证最终要么全部数据被更新到数据库，要么全部都不更新到数据库。</p><p><strong>Example: 小明让小王代购了一些东西回来，需要在微信上支付给他1000元</strong></p><p>当小明输入完金额点击“确认转账”之后，执行的 SQL 至少是这样的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> balance = balance - <span class="number">1000</span> <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'小明的 id'</span><span class="string">``</span></span><br><span class="line"><span class="keyword">update</span> balance = balance + <span class="number">1000</span> <span class="keyword">from</span> <span class="keyword">account</span> <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'小王的 id'</span></span><br></pre></td></tr></table></figure><p>注意，这两条语句中只要任意一条执行失败，而另外一条执行成功，那么从原子性的要求来说，所有执行成功的修改都需要一并撤销，恢复到最初的状态，这个撤销操作我们称为“回滚”。否则，微信体系中的总余额会无故多出或少了 1000 元。</p><p>数据库中原子性的主流实现方案是通过日志来做的，每一次操作数据前都会先将当前数据记录到日志中，这样在需要回滚时，我们只要把 Undo Log 中的数据拿出来还原，就可以撤销已经执行成功的操作。</p><p>原子性是四个特性中最核心的一个，仅关注当前的这一次操作，不考虑是否存在其它的什么操作。</p><hr><h4 id="Isolation"><a href="#Isolation" class="headerlink" title="Isolation"></a>Isolation</h4><p>在上面小明和小王的故事中，如果再出现一个人小张，他也让小王代购了东西要付钱，会出现新的情况，例如</p><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-1.png"><p>注意一下红字部分。我们发现，这个时候哪怕两次转账的事务分别保证了原子性，并且执行成功，最终的结果还是有可能出错。</p><p>上图中的现象，我们称为“丢失更新”（Lost Update）。当然，还有其他可能产生的现象，比如脏读、不可重复读、幻读，等等。</p><p>不过，我们暂时不需要过多纠结于这些现象，只要记得：<strong>当仅满足原子性的前提下，如果遇到并发执行，依旧会出现数据错误</strong>。</p><p>所以，这时候我们需要通过隔离性的指导来避免这些问题。<strong>隔离性本质上指导解决的是一个资源竞争问题，通俗点说，就是多个事务并发执行后的状态，应该和它们串行执行后的状态是一致的</strong>。</p><p>在数据库中解决资源竞争问题与其它软件系统无异，就用锁。在数据库中对锁的运用不同，因此产生了不同的隔离级别，不同的隔离级别对应解决的是前面提到的这些异常现象。</p><ul><li>读未提交（Read Uncommitted）解决了丢失更新</li><li>读已提交（Read committed）多解决了脏读</li><li>可重复读（Repeatable Read）又多解决了不可重复读问题</li><li>最高级别的可序列化（Serializable）解决了全部这 4 个问题，即丢失更新、脏读、不可重复度、幻读。</li></ul><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-2.png"><blockquote><p>脏读：一个事务中读到(SELECT)了另一个事务还没有提交更新的数据。<br>不重复读：在同一个事务里，前后两次相同的SELECT语句会读到不同的结果。侧重点在于更新修改数据。<br>幻读：表示在同一事务中，使用相同的查询语句，第二次查询时，莫名的多出了一些之前不存在数据，或者莫名的不见了一些数据。幻读与不可重复读的区别：幻读的侧重点在于新增和删除。</p></blockquote><p>其实在实际的运用中，遇到的场景会更复杂，所以詹姆士·格雷（Jim Gray）等人在 1995 发表了论文“对 ANSI SQL 隔离级别的批评（A Critique of ANSI SQL Isolation Levels）”将上表做了扩充，增加了<strong>游标稳定（Cursor Stability）</strong>和<strong>快照隔离（Snapshot Isolation）</strong>隔离级别，指导我们在做隔离时，可以为获得更好的性能进行一些新的尝试。</p><hr><h4 id="Durability"><a href="#Durability" class="headerlink" title="Durability"></a>Durability</h4><p>当你使用一些云产品写文章的时候，洋洋洒洒写了几千字，安心睡觉去了，第二天起来发现内容停留在刚起笔的那几个字。任何的数据变更完成之后，就相当于成为了“历史”，需要保存下来才能为未来所用。因此数据库需要具备持久性，才能为我们所依赖用于存储数据。</p><p>如今，我们几乎都是利用硬盘作为数据库的存储介质，来保证持久性。那么理论上，除非硬盘本身故障，否则都不应该出现这样一种情况：一条SQL变更成功后，发生数据丢失或者数据回到更早的状态。</p><hr><h4 id="Consistency"><a href="#Consistency" class="headerlink" title="Consistency"></a>Consistency</h4><p><strong>一致性的含义其实很简单，就是最终结果的对与错，是否是你所希望的结果。</strong>任何系统如果无法确保产生的数据结果与预期一致，那么整个系统其实是没有价值的。</p><p>回到前面小明和小王的例子。只要小明账户少了1000元，小王账户必须要多出1000元，这才是我们所希望的结果，否则都是错的，也就是“不一致”的。</p><p>这么一说，一致性和原子性意思好像差不多啊？关于这点可以这样来理解：</p><ul><li>原子性关注的是关系和过程，确保指定的SQL之间是一个命运共同体。比如鸡蛋孵小鸡这个过程，必然是鸡蛋破了后小鸡再出来，而不是鸡蛋破了，小鸡不见了或者鸡蛋没破，不知道从哪哪冒出来个小鸡。</li><li>而一致性关注的是结果，这个结果的预期是你来定的，如何达到这个结果的过程并不是它所包含的概念。还是鸡蛋孵小鸡这个事，比如你预期一个鸡蛋里只能孵出一个小鸡，那么如果最终9个鸡蛋里出现了10个小鸡，这时就是不一致的。</li></ul><p>由于一致性只表示一个结果，它只是指引出一个正确的工作方向。而要达到这个正确的结果并不完全是由数据库保证的，它只是一个按规则办事的“监督者”。</p><p>但是，它提供了主键、外键、约束、字段类型等，让你可以在不同层面上定义什么是“一致”。一旦不符合你的定义，数据库就会抛出异常来提醒你，这里不符合你的预期了。</p><hr><h3 id="ACID-间的联系"><a href="#ACID-间的联系" class="headerlink" title="ACID 间的联系"></a>ACID 间的联系</h3><p>原子性（A）、隔离性（I）、持久性（D）是为达到一致性（C）而存在的。</p><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-3.png"><p>可以理解为，只要满足了原子性（A）、隔离性（I）、持久性（D）那么数据存储层面的一致性（C）自然也就满足了。</p><p>不过，站在一个完整的系统角度来说，要达到真正的一致性，还需要我们在Coding的时候有意识的去定义达到“正确结果”的代码逻辑。</p><h3 id="What’s-CAP"><a href="#What’s-CAP" class="headerlink" title="What’s CAP"></a>What’s CAP</h3><p>聊ACID的原因是为了引出分布式系统中的一个经典定理——CAP。</p><p><strong>CAP是指导我们进行多进程之间交互的设计理论</strong>，告诉我们该如何去权衡一致性（C）、可用性（A）、分区容错性（P），这也是它这三个字母所表达的含义。</p><blockquote><p><strong>Robert Greiner CAP</strong><br>第一版：<br>Any distributed system can’t guaranty C, A, and P simultaneously.<br>第二版：<br>In a distributed system (a collection of interconnected nodes that share data), you can only have two out of(从..) the following three guarantees across a write/read pari:<br>Consistency, Availability, and Partition Tolerance - one of them must be sacrified.</p></blockquote><p>两个版本的差异点：</p><ul><li>第二版定义了什么才是CAP理论探讨的分布式系统（强调interconnected and share data）。为什么要强调这两点？因为分布式系统并不一定会互联和共享数据。比如Memcache，相互之间就没有连接和共享数据，因此Memcache集群并不符合CAP理论探讨的对象。而MySQL集群就是互联和进行数据复制的，因此是CAP理论探讨的对象。</li><li>第二版强调了 write/read pair，CAP关注的是对数据的读写操作，而不是分布式系统的所有功能。例如，ZooKeeper的选举机制就不是CAP探讨的对象。</li></ul><p>如果你知道分布式系统理论中的CAP定理，肯定会好奇ACID和CAP两者定义的“一致性”表示的是不是同一个意思。其实不是：</p><ul><li>描述的主体不同，ACID中的C指的是数据库事务的一致性，而CAP中的C指的是程序之间请求的一致性。</li><li>对结果的定义也有些差异，CAP中的C除了一致性之外还带着一些原子性的意思，一次操作中产生的多个请求要被视为一个完整的个体，不可分割，这个特点和数据库中的原子性是一致的。</li></ul><p>所以你会发现，CAP定理中所表述的“一个请求”类似于数据库ACID中的“一条SQL”，并且还保留了原子性和一致性的含义。然后基于分布式的场景，衍生了分区容错性以及可用性的概念。CAP定理作为后来者，为分布式系统而生，是分布式系统设计的指导方针。理解了 ACID，更有利于你去理解 CAP。</p><hr><h4 id="Consistency-1"><a href="#Consistency-1" class="headerlink" title="Consistency"></a>Consistency</h4><blockquote><p>第一版：<br>All nodes see the same data at the same time.<br>第二版：<br>A read is guraranteed to return the most recent write for a given client</p></blockquote><p>两个版本差异点：</p><ul><li>第一版从Node角度描述，第二版从Client的角度描述。第二版更符合我们观察和评估系统的方式，即站在客户端的角度来观察系统的特征和行为。</li><li>第一版关键词<strong>see</strong>，第二版<strong>read</strong>。第二版从Client的读写角度来描述一致性，定义更加精确。</li><li>第一版强调同一时刻所有Node拥有相同的数据，第二版强调Client读取到总是最新的数据（这对于集群中的多个节点来说，可能在同一时刻拥有不同的数据。对于系统执行事务来说，在事务过程中，系统其实处于一个不一致的状态，不同节点的数据并不完全一致，此时Client是无法读取到没有提交的数据。但是当事务提交以后，Client是可以读取到事务写入的数据，如果事务失败则会进行回滚，Client也不会读取到事务中间写入的数据）。</li></ul><hr><h4 id="Available"><a href="#Available" class="headerlink" title="Available"></a>Available</h4><blockquote><p>第一版：<br>Every request gets a response on success / failure.<br>第二版：<br>A non-failing node will return a reasonable response within a reasonable amount of time(no error or timeout).</p></blockquote><p>两个版本的差异：</p><ul><li>第一版强调 every request，第二版强调 a non-failing node。第一版并不严谨，因为只有非故障节点才能满足可用性要求，如果节点本身就故障了，发给节点的请求不一定就能得到一个响应。</li><li>第一版的 success / failure 太宽泛，在实际中没有指导意义，第二版明确了不能超时和不能出错，但要提出合理的结果，需要注意的是没有说”正确”的结果，例如，应该返回200但实际是301，肯定是不正确的结果，但是一个合理的结果。</li></ul><hr><h4 id="Partition-Tolerance"><a href="#Partition-Tolerance" class="headerlink" title="Partition Tolerance"></a>Partition Tolerance</h4><blockquote><p>第一版：<br>System continues to work despite message loss or partial failure.<br>第二版：<br>The system will continue to funtion when network partitions occur.</p></blockquote><p>两个版本的差异：</p><ul><li>第一版用workd，第二版用function。work强调运行，只要系统不宕机，都可以说系统在work，即使返回错误，或拒绝服务都是在work。function强调履行其职能（正确地发挥其功能作用），即返回reasonable response。</li><li>第一版描述分区用的是message loss or partial failure，第二版直接用network partitions。第一版只是说明了message loss造成了分区，但没有详细解释message loss指的是什么，如果说的是丢包，那就太狭隘了，因为它只是网路故障中的一种。而第二版直接说现象，即发生了分区现象。造成这个现象的原因可能是丢包，连接中断或拥塞等等，只要导致了网络分区，就通通算在一起。</li></ul><hr><h3 id="CAP应用"><a href="#CAP应用" class="headerlink" title="CAP应用"></a>CAP应用</h3><p>CAP理论定义是三个要素中只能取两个，但是在实际的分布式环境中，P是一个必要的要素，因为网络本身无法做到100%可靠，所以分区是一个必然的现象。</p><p>假如我们选择CA（放弃P），那么当发生分区现象时，为了保证C，系统需要禁止写入操作，因为当有写入请求时，系统返回error。这又和A冲突了，因为A要去返回no error和no timeout。因此分布式系统理论上不可能选择CA架构，只能选CP或AP架构。</p><hr><h4 id="CP架构"><a href="#CP架构" class="headerlink" title="CP架构"></a>CP架构</h4><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-4.png"><p>假设，此时所有Node上面的index=0。</p><p>为了保证一致性，当分区现象发生后，Node1节点上的index已经更新为1，但由于Node1与Node2之间的网络出了问题，造成数据同步失败，Node2上的index仍然为0。</p><p>此时客户端访问Node2，Node2因为C的要求，Node2需要返回Error信息，提示客户端“系统发生了错误”，这种方式违背了A的要求，因此CAP三者只能满足CP。</p><hr><h4 id="AP架构"><a href="#AP架构" class="headerlink" title="AP架构"></a>AP架构</h4><img src="/2018/12/02/DistributedSystem/CAP/从ACID聊到CAP/pc-4.png"><p>假设，此时所有Node上面的index=0。</p><p>为了保证可用性，当分区现象发生后，Node1节点上的index已经更新为1，但由于Node1与Node2之间的网络出了问题，造成数据同步失败，Node2上的index仍然为0。</p><p>此时客户端访问Node2，Node2因为A的要求，Node2将当前index=0的数据返回给客户端，而实际上当前最新的数据是index=1，这就不满足C的要求了，因此CAP三者只能满足CP。</p><h4 id="CPA关注的粒度是数据，而不是整个系统"><a href="#CPA关注的粒度是数据，而不是整个系统" class="headerlink" title="CPA关注的粒度是数据，而不是整个系统"></a>CPA关注的粒度是数据，而不是整个系统</h4><p>每个系统不可能只处理一种数据，而是包含多种类型的数据，有的数据必须选择CP，有的数据必须选择AP。</p><p>如果我们在做设计时，从整个系统的角度去选择CP还是AP，就会发现顾此失彼，无论怎么做都是有问题的。</p><p>例如，SSO系统包含用户账号信息（用户ID和密码）、用户其他信息（昵称、性别、手机号等等）。</p><p>通常情况下，用户账号数据会选择CP，而用户其他信息会选择AP。如果限定了整个系统为CP，则不符合用户其他信息的应用场景，同理可知，限定系统为AP也是不行的。</p><p>例如，账户资金系统，用户可用余额信息选择CP（例如，避免双花问题），用户账户流水信息选择AP。</p><p>所以在CAP理论落地实践时，需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（AP或CP），而不是直接限定系统所有数据都是同一个策略。</p><hr><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://www.infoq.cn/article/Q1Dlq-tcyjEX6GVmRuoy" target="_blank" rel="noopener">https://www.infoq.cn/article/Q1Dlq-tcyjEX6GVmRuoy</a><br><a href="http://www.zsythink.net/archives/1233" target="_blank" rel="noopener">http://www.zsythink.net/archives/1233</a><br>Robert Greiner CAP 1.0: <a href="http://robertgreiner.com/2014/06/cap-theorem-explained/" target="_blank" rel="noopener">http://robertgreiner.com/2014/06/cap-theorem-explained/</a><br>Robert Greiner CAP 2.0: <a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" target="_blank" rel="noopener">http://robertgreiner.com/2014/08/cap-theorem-revisited/</a><br>Zookeeper的Leader选举: <a href="http://www.cnblogs.com/leesf456/p/6107600.html" target="_blank" rel="noopener">http://www.cnblogs.com/leesf456/p/6107600.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;在使用数据库的时候，心里会假定这里面的数据都是 100% 准
      
    
    </summary>
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/categories/DistributedSystem/"/>
    
      <category term="CAP" scheme="https://sulangsss.github.io/categories/DistributedSystem/CAP/"/>
    
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/tags/DistributedSystem/"/>
    
      <category term="ACID" scheme="https://sulangsss.github.io/tags/ACID/"/>
    
      <category term="CAP" scheme="https://sulangsss.github.io/tags/CAP/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Distributed System</title>
    <link href="https://sulangsss.github.io/2018/11/30/DistributedSystem/What&#39;s%20Distributed%20Sytem/"/>
    <id>https://sulangsss.github.io/2018/11/30/DistributedSystem/What&#39;s Distributed Sytem/</id>
    <published>2018-11-30T13:52:18.000Z</published>
    <updated>2018-12-02T06:42:00.769Z</updated>
    
    <content type="html"><![CDATA[<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><ul><li>“分布式系统”等于 SOA、ESB、微服务这些东西吗？</li><li>“分布式系统”是各种中间件吗？</li><li>中间件起到什么作用？</li><li>单程序+单数据库，是一个分布式系统吗？</li></ul><h4 id="核心点"><a href="#核心点" class="headerlink" title="核心点"></a>核心点</h4><ul><li>分而治之</li><li>高内聚，低耦合</li><li>中间件是一个标准化的结果</li><li>“分布式” 这个词只是意味着形态上是散列状的，而“一分为二”和“一分为 N”本质上并没有区别</li></ul><h4 id="中间件起到什么作用？"><a href="#中间件起到什么作用？" class="headerlink" title="中间件起到什么作用？"></a>中间件起到什么作用？</h4><p>中间件起到的是标准化的作用。中间件只是承载这些标准化想法的介质、工具，可以起到引导和约束的效果，以此起到大大降低系统复杂度和协作成本的作用。</p><p>中间件都具备的一个价值：为了在软件系统的迭代过程中，避免将精力过多地花费在某个子功能下众多差异不大的选项中。</p><ul><li>MQ 框架标准化了不同应用程序间非实时异步通信的方式。</li><li>RPC 框架标准化了不同应用程序间实时通讯的方式。</li><li>DAL（Data Access Layer，数据访问层）框架标准化了应用程序和数据库之间通讯的方式。</li></ul><p>所以，<strong>虽然分布式系统中会运用中间件，但分布式系统却不仅仅停留在用了什么中间件上。</strong>你需要清楚每一类中间件背后是对什么进行了标准化，它的目的是什么，带来了哪些副作用，等等。只有如此，你才能真正识别不同技术框架之间的区别，找到真正适合当前系统的技术框架。</p><h4 id="软件的本质"><a href="#软件的本质" class="headerlink" title="软件的本质"></a>软件的本质</h4><p>软件的本质是一套代码，而代码只是一段文字，除了提供文字所表述的信息之外，本身无法“动”起来。</p><p>但是，想让它“动”起来，使其能够完成一件我们指定的事情，前提是需要一个宿主来给予它生命。这个宿主就是计算机，它可以让代码变成一连串可执行的“动作”，然后通过数据这个“燃料”的触发，“动”起来。</p><p>这个持续的活动过程，又被描述为一个运行中的“进程”。</p><h4 id="分布式系统的本质"><a href="#分布式系统的本质" class="headerlink" title="分布式系统的本质"></a>分布式系统的本质</h4><p>维基百科：分布式系统是一种其组件位于不同的联网计算机上的系统，然后通过互相传递消息来进行通信和协调。为了达到共同的目标，这些组件会相互作用。</p><p>用一句话来总结，涉及多个进程协作才能提供一个完整功能的系统就是“分布式系统”。</p><p><strong>关键两点：分治和冗余</strong></p><p><strong>分治</strong></p><p>过程分解：分解 -&gt; 治理 -&gt; 归并</p><p>这么做的好处是：问题越小越容易被解决，并且，只要解决了所有子问题，父问题就都可以被解决了。</p><p>但是，这么做的时候，需要满足一个最重要的条件：不同分支上的子问题，不能相互依赖，需要各自独立。因为一旦包含了依赖关系，子问题和父问题之间就失去了可以被“归并”的意义。</p><p>在软件开发领域，我们把这个概念称为“耦合度”和“内聚度”，这两个度量概念非常重要。</p><blockquote><p>耦合度，指的是软件模块之间相互依赖的程度。比如，每次调用方法 A 之后都需要同步调用方法 B，那么此时方法 A 和 B 间的耦合度是高的。<br>内聚度，指的是模块内的元素具有的共同点的相似程度。比如，一个类中的多个方法有很多的共同之处，都是做支付相关的处理，那么这个类的内聚度是高的。<br>内聚度通常与耦合度形成对比。低耦合通常与高内聚相关，反之亦然。</p></blockquote><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://www.infoq.cn/article/pdCpOo*AcZ0xuI3LP45a" target="_blank" rel="noopener">https://www.infoq.cn/article/pdCpOo*AcZ0xuI3LP45a</a><br><a href="https://www.infoq.cn/article/lw_Ax10OXkL2zcIDRkJ1" target="_blank" rel="noopener">https://www.infoq.cn/article/lw_Ax10OXkL2zcIDRkJ1</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;QA&quot;&gt;&lt;a href=&quot;#QA&quot; class=&quot;headerlink&quot; title=&quot;QA&quot;&gt;&lt;/a&gt;QA&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;“分布式系统”等于 SOA、ESB、微服务这些东西吗？&lt;/li&gt;
&lt;li&gt;“分布式系统”是各种中间件吗？&lt;/li&gt;
&lt;li&gt;中间
      
    
    </summary>
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/categories/DistributedSystem/"/>
    
    
      <category term="DistributedSystem" scheme="https://sulangsss.github.io/tags/DistributedSystem/"/>
    
  </entry>
  
  <entry>
    <title>Aeron Error</title>
    <link href="https://sulangsss.github.io/2018/11/30/Java/LowLatency/AeronError/"/>
    <id>https://sulangsss.github.io/2018/11/30/Java/LowLatency/AeronError/</id>
    <published>2018-11-30T09:01:22.000Z</published>
    <updated>2018-11-30T09:22:59.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MediaDriver-keepalive-older-than-ms-10000"><a href="#MediaDriver-keepalive-older-than-ms-10000" class="headerlink" title="MediaDriver keepalive older than (ms): 10000"></a>MediaDriver keepalive older than (ms): 10000</h3><p>Solution: aeron.close()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;MediaDriver-keepalive-older-than-ms-10000&quot;&gt;&lt;a href=&quot;#MediaDriver-keepalive-older-than-ms-10000&quot; class=&quot;headerlink&quot; title=&quot;MediaDrive
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="Aeron" scheme="https://sulangsss.github.io/tags/Aeron/"/>
    
  </entry>
  
  <entry>
    <title>Rust Data Structure</title>
    <link href="https://sulangsss.github.io/2018/11/29/Rust/Basic/DataStructure/"/>
    <id>https://sulangsss.github.io/2018/11/29/Rust/Basic/DataStructure/</id>
    <published>2018-11-29T15:24:03.000Z</published>
    <updated>2018-12-01T13:26:12.575Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Data-Structure"><a href="#Data-Structure" class="headerlink" title="Data Structure"></a>Data Structure</h4><h4 id="Primitive"><a href="#Primitive" class="headerlink" title="Primitive"></a>Primitive</h4><ul><li>signed integers: i8, i16, i32, i64, i128 and isize (pointer size)</li><li>unsigned integers: u8, u16, u32, u64, u128 and usize (pointer size)</li><li>floating point: f32, f64</li><li>char Unicode scalar values like ‘a’, ‘α’ and ‘∞’ (4 bytes each)</li><li>bool either true or false</li><li>unit type (), whose only possible value is an empty tuple: ()</li></ul><h4 id="Compound"><a href="#Compound" class="headerlink" title="Compound"></a>Compound</h4><ul><li>arrays like [1, 2, 3]</li><li>tuples like (1, true)</li></ul><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/rust-by-example/index.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Data-Structure&quot;&gt;&lt;a href=&quot;#Data-Structure&quot; class=&quot;headerlink&quot; title=&quot;Data Structure&quot;&gt;&lt;/a&gt;Data Structure&lt;/h4&gt;&lt;h4 id=&quot;Primitive&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
      <category term="Basic" scheme="https://sulangsss.github.io/categories/Rust/Basic/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Primer" scheme="https://sulangsss.github.io/tags/Primer/"/>
    
      <category term="Data Structure" scheme="https://sulangsss.github.io/tags/Data-Structure/"/>
    
  </entry>
  
  <entry>
    <title>Cargo Tutorial</title>
    <link href="https://sulangsss.github.io/2018/11/29/Rust/cargo/"/>
    <id>https://sulangsss.github.io/2018/11/29/Rust/cargo/</id>
    <published>2018-11-29T15:24:03.000Z</published>
    <updated>2018-11-29T15:25:29.159Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p><strong>craete project</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new hello_world --bin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Basic&quot;&gt;&lt;a href=&quot;#Basic&quot; class=&quot;headerlink&quot; title=&quot;Basic&quot;&gt;&lt;/a&gt;Basic&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;craete project&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlig
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Cargo" scheme="https://sulangsss.github.io/tags/Cargo/"/>
    
  </entry>
  
  <entry>
    <title>Kryo Attention</title>
    <link href="https://sulangsss.github.io/2018/11/29/Java/Kryo/Attention/"/>
    <id>https://sulangsss.github.io/2018/11/29/Java/Kryo/Attention/</id>
    <published>2018-11-29T03:00:03.000Z</published>
    <updated>2018-11-29T03:10:45.861Z</updated>
    
    <content type="html"><![CDATA[<h3 id="com-esotericsoftware-kryo-KryoException-Encountered-unregistered-class-ID-XXXX"><a href="#com-esotericsoftware-kryo-KryoException-Encountered-unregistered-class-ID-XXXX" class="headerlink" title="com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: XXXX"></a>com.esotericsoftware.kryo.KryoException: Encountered unregistered class ID: XXXX</h3><p>当Kryo写出一个对象的实例时，首先可能需要写出一些标识对象类的东西。默认情况下，写入完整类名，然后写入该对象的字节。后续出现的同一类对象图的对象用变长的int来写（using a variable length int）。</p><p>写类的名字有点低效，所以类可以事先注册：kryo.register(SomeClass.class);这样的话，SomeClass 注册到了 Kryo，它将该类与一个 int 型的 ID 相关联。当 Kryo 写出 SomeClass 的一个实例时，它会写出这个 int ID。这比写出类名更有效。在反序列化期间，注册的类必须具有序列化期间相同的 ID 。还有一种情况是kryo每次写入类的完整信息，而不是通过int类型的ID号去代替。</p><p>两种情况如何取舍呢？写id的情况，效率会高一些，但是缺陷很明显：所有系列化涉及到的类都需要代码里手工kryo.register(),否则报告unregistered class ID；另外，kryo不能保证”每次jvm重启之后，或者在多台jvm机器之间，同一个类注册到kryo的class ID会相同”，所以这就导致该模式应用于集群会存在严重问题，所以用id代替类信息的模式不建议使用，而且，默认该功能也是关闭的，除非你在代码中显性的调用了以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kryo.register(SomeClass.class);</span><br><span class="line"><span class="comment">//  或者：</span></span><br><span class="line">Kryo.setRegistrationRequired(<span class="keyword">true</span>)；</span><br></pre></td></tr></table></figure><p>所以遇到Encountered unregistered class ID之类的问题，首先要检查该功能是否被不经意的开启了。如果确保未开启该功能，再考虑以下情况：就是对象太大，导致系列化结果不完整，因为output对象默认的缓存字节数并不大，实际对象超出大小的时候，系列化的时候并不会报告错误，但是系列化结果已经不完整，从而导致反系列化的时候会失败，报告的错误一般也是Encountered unregistered class ID。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;com-esotericsoftware-kryo-KryoException-Encountered-unregistered-class-ID-XXXX&quot;&gt;&lt;a href=&quot;#com-esotericsoftware-kryo-KryoException-En
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kryo" scheme="https://sulangsss.github.io/categories/Java/Kryo/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Kryo" scheme="https://sulangsss.github.io/tags/Kryo/"/>
    
  </entry>
  
  <entry>
    <title>Rust Installation</title>
    <link href="https://sulangsss.github.io/2018/11/29/Rust/Installation/"/>
    <id>https://sulangsss.github.io/2018/11/29/Rust/Installation/</id>
    <published>2018-11-28T16:50:03.000Z</published>
    <updated>2018-11-28T17:43:32.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><ol><li>nightly</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustup install nightly</span><br></pre></td></tr></table></figure><ol start="2"><li>Racer 是 Rust 代码补全库，被很多编辑器所需要（除了 Interllij Rust）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cargo install racer</span></span><br><span class="line">cargo +nightly install racer</span><br><span class="line"><span class="comment"># 代码补全需要源代码，下载源代码</span></span><br><span class="line">rustup component add rust-src</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mac Linux</span></span><br><span class="line"><span class="built_in">export</span> RUST_SRC_PATH=<span class="string">"<span class="variable">$(rustc --print sysroot)</span>/lib/rustlib/src/rust/src"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>Plugin</li></ol><ul><li>rustfmt</li></ul><ol start="4"><li>CodeLLDB</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install llvm --with-python --with-lldb</span><br></pre></td></tr></table></figure><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://zhuanlan.zhihu.com/p/26944087" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26944087</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Install&quot;&gt;&lt;a href=&quot;#Install&quot; class=&quot;headerlink&quot; title=&quot;Install&quot;&gt;&lt;/a&gt;Install&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;nightly&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="Rust" scheme="https://sulangsss.github.io/categories/Rust/"/>
    
    
      <category term="Rust" scheme="https://sulangsss.github.io/tags/Rust/"/>
    
      <category term="Installation" scheme="https://sulangsss.github.io/tags/Installation/"/>
    
  </entry>
  
  <entry>
    <title>Difference on Volume</title>
    <link href="https://sulangsss.github.io/2018/11/25/Kubenetes/Volume/DifferenceOnVolume/"/>
    <id>https://sulangsss.github.io/2018/11/25/Kubenetes/Volume/DifferenceOnVolume/</id>
    <published>2018-11-25T07:48:18.000Z</published>
    <updated>2018-11-25T07:27:41.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="emptyDir"><a href="#emptyDir" class="headerlink" title="emptyDir"></a>emptyDir</h3><p>emptyDir类型的Volume在Pod分配到Node上时被创建，Kubernetes会在Node上自动分配一个目录，因此无需指定宿主机Node上对应的目录文件。 这个目录的初始内容为空，当Pod从Node上移除时，emptyDir中的数据会被永久删除。</p><p>注：容器的crashing事件并不会导致emptyDir中的数据被删除。</p><h4 id="apply-to-scene"><a href="#apply-to-scene" class="headerlink" title="apply to scene"></a>apply to scene</h4><ul><li>临时空间，例如基于磁盘的合并排序</li><li>设置检查点以从崩溃事件中恢复未执行完毕的长计算</li><li>保存内容管理器容器从Web服务器容器提供数据时所获取的文件</li></ul><p>默认情况下，emptyDir可以使用任何类型的由node节点提供的后端存储。如果你有特殊的场景，需要使用tmpfs作为emptyDir的可用存储资源也是可以的，只需要在创建emptyDir卷时增加一个emptyDir.medium字段的定义，并赋值为”Memory”即可。</p><p>注：在使用tmpfs文件系统作为emptyDir的存储后端时，如果遇到node节点重启，则emptyDir中的数据也会全部丢失。同时，你编写的任何文件也都将计入Container的内存使用限制。</p><hr><h3 id="hostPath"><a href="#hostPath" class="headerlink" title="hostPath"></a>hostPath</h3><p>hostPath类型则是映射node文件系统中的文件或者目录到pod里。在使用hostPath类型的存储卷时，也可以设置type字段，支持的类型有文件、目录、File、Socket、CharDevice和BlockDevice。</p><h4 id="apply-to-scene-1"><a href="#apply-to-scene-1" class="headerlink" title="apply to scene"></a>apply to scene</h4><ul><li>当运行的容器需要访问Docker内部结构时，如使用hostPath映射/var/lib/docker到容器；</li><li>当在容器中运行cAdvisor时，可以使用hostPath映射/dev/cgroups到容器中；</li></ul><p>注意事项：</p><ul><li>配置相同的pod（如通过podTemplate创建），可能在不同的Node上表现不同，因为不同节点上映射的文件内容不同</li><li>当Kubernetes增加了资源敏感的调度程序，hostPath使用的资源不会被计算在内</li><li>宿主机下创建的目录只有root有写权限。你需要让你的程序运行在privileged container上，或者修改宿主机上的文件权限。</li></ul><h3 id="emptyDir和hostPath在功能上的异同"><a href="#emptyDir和hostPath在功能上的异同" class="headerlink" title="emptyDir和hostPath在功能上的异同"></a>emptyDir和hostPath在功能上的异同</h3><ul><li>二者都是node节点的本地存储卷方式；</li><li>emptyDir可以选择把数据存到tmpfs类型的本地文件系统中去，hostPath并不支持这一点；</li><li>hostPath除了支持挂载目录外，还支持File、Socket、CharDevice和BlockDevice，既支持把已有的文件和目录挂载到容器中，也提供了“如果文件或目录不存在，就创建一个”的功能；</li><li>emptyDir是临时存储空间，完全不提供持久化支持；</li><li>hostPath的卷数据是持久化在node节点的文件系统中的，即便pod已经被删除了，volume卷中的数据还会留存在node节点上；</li></ul><hr><h3 id="local-volume"><a href="#local-volume" class="headerlink" title="local volume"></a>local volume</h3><hr><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://www.kubernetes.org.cn/4846.html" target="_blank" rel="noopener">https://www.kubernetes.org.cn/4846.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;emptyDir&quot;&gt;&lt;a href=&quot;#emptyDir&quot; class=&quot;headerlink&quot; title=&quot;emptyDir&quot;&gt;&lt;/a&gt;emptyDir&lt;/h3&gt;&lt;p&gt;emptyDir类型的Volume在Pod分配到Node上时被创建，Kubernetes会在
      
    
    </summary>
    
      <category term="Kuberntes" scheme="https://sulangsss.github.io/categories/Kuberntes/"/>
    
      <category term="Volume" scheme="https://sulangsss.github.io/categories/Kuberntes/Volume/"/>
    
    
      <category term="Kuberntes" scheme="https://sulangsss.github.io/tags/Kuberntes/"/>
    
      <category term="Volume" scheme="https://sulangsss.github.io/tags/Volume/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://sulangsss.github.io/2018/11/25/Kubenetes/Volume/DynamicVolume/"/>
    <id>https://sulangsss.github.io/2018/11/25/Kubenetes/Volume/DynamicVolume/</id>
    <published>2018-11-25T07:32:23.163Z</published>
    <updated>2018-11-25T07:32:23.163Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mac Common Tools</title>
    <link href="https://sulangsss.github.io/2018/11/25/Mac/Toos/Common/"/>
    <id>https://sulangsss.github.io/2018/11/25/Mac/Toos/Common/</id>
    <published>2018-11-25T04:07:27.000Z</published>
    <updated>2018-11-25T10:08:38.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="KeyRemap4MacBook"><a href="#KeyRemap4MacBook" class="headerlink" title="KeyRemap4MacBook"></a>KeyRemap4MacBook</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;KeyRemap4MacBook&quot;&gt;&lt;a href=&quot;#KeyRemap4MacBook&quot; class=&quot;headerlink&quot; title=&quot;KeyRemap4MacBook&quot;&gt;&lt;/a&gt;KeyRemap4MacBook&lt;/h3&gt;
      
    
    </summary>
    
      <category term="Mac" scheme="https://sulangsss.github.io/categories/Mac/"/>
    
      <category term="Tools" scheme="https://sulangsss.github.io/categories/Mac/Tools/"/>
    
    
      <category term="Mac" scheme="https://sulangsss.github.io/tags/Mac/"/>
    
      <category term="Common Tools" scheme="https://sulangsss.github.io/tags/Common-Tools/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin detekt</title>
    <link href="https://sulangsss.github.io/2018/11/24/Java/Kotlin/detekt/"/>
    <id>https://sulangsss.github.io/2018/11/24/Java/Kotlin/detekt/</id>
    <published>2018-11-24T14:27:22.000Z</published>
    <updated>2018-11-28T16:43:17.959Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/categories/Java/Kotlin/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/tags/Kotlin/"/>
    
      <category term="detekt" scheme="https://sulangsss.github.io/tags/detekt/"/>
    
  </entry>
  
  <entry>
    <title>IDE Intellij</title>
    <link href="https://sulangsss.github.io/2018/11/24/DevTools/IDE/Intellij/"/>
    <id>https://sulangsss.github.io/2018/11/24/DevTools/IDE/Intellij/</id>
    <published>2018-11-24T05:28:19.000Z</published>
    <updated>2018-11-24T12:31:48.423Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Booting-Debug-mode-is-didn’t-smoothly-on-MacOS"><a href="#Booting-Debug-mode-is-didn’t-smoothly-on-MacOS" class="headerlink" title="Booting Debug mode is didn’t smoothly on MacOS"></a>Booting Debug mode is didn’t smoothly on MacOS</h3><p>Cause: Java8 Bug</p><p><strong>方法一</strong></p><p>查看本机名字<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /private/etc/hosts</span><br><span class="line"><span class="comment"># replace 127.0.0.1       localhost </span></span><br><span class="line"><span class="comment"># with 127.0.0.1       localhost       [hostname].local</span></span><br></pre></td></tr></table></figure><p><strong>方法二</strong></p><p>vm option 添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Djava.net.preferIPv4Stack=<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Booting-Debug-mode-is-didn’t-smoothly-on-MacOS&quot;&gt;&lt;a href=&quot;#Booting-Debug-mode-is-didn’t-smoothly-on-MacOS&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="DevTools" scheme="https://sulangsss.github.io/categories/DevTools/"/>
    
      <category term="IDE" scheme="https://sulangsss.github.io/categories/DevTools/IDE/"/>
    
    
      <category term="DevTools" scheme="https://sulangsss.github.io/tags/DevTools/"/>
    
      <category term="IDE" scheme="https://sulangsss.github.io/tags/IDE/"/>
    
      <category term="Intellij" scheme="https://sulangsss.github.io/tags/Intellij/"/>
    
  </entry>
  
  <entry>
    <title>Instrumentation</title>
    <link href="https://sulangsss.github.io/2018/11/22/Java/Advance/Instrumentation/"/>
    <id>https://sulangsss.github.io/2018/11/22/Java/Advance/Instrumentation/</id>
    <published>2018-11-22T02:13:06.000Z</published>
    <updated>2018-11-22T02:15:03.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introducation"><a href="#Introducation" class="headerlink" title="Introducation"></a>Introducation</h3><h4 id="What-is-a-Java-Agent"><a href="#What-is-a-Java-Agent" class="headerlink" title="What is a Java Agent?"></a>What is a Java Agent?</h4><p>In general, a java agent is just a specially crafted jar file. It utilizes the Instrumentation API that the JVM provides to alter existing byte-code that is loaded in a JVM.</p><p>For an agent to work, we need to define two methods:</p><ul><li>premain – will statically load the agent using -javaagent parameter at JVM startup</li><li>agentmain – will dynamically load the agent into the JVM using the Java Attach API</li></ul><p>An interesting concept to keep in mind is that a JVM implementation, like Oracle, OpenJDK, and others, can provide a mechanism to start agents dynamically, but it is not a requirement.</p><h3 id="Refer"><a href="#Refer" class="headerlink" title="Refer"></a>Refer</h3><blockquote><p><a href="https://www.baeldung.com/java-instrumentation" target="_blank" rel="noopener">https://www.baeldung.com/java-instrumentation</a><br><a href="https://juejin.im/post/5ac32eba5188255c313af0dd" target="_blank" rel="noopener">https://juejin.im/post/5ac32eba5188255c313af0dd</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-jse61/index.html</a><br><a href="http://www.iocoder.cn/SkyWalking/agent-plugin-system/" target="_blank" rel="noopener">http://www.iocoder.cn/SkyWalking/agent-plugin-system/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introducation&quot;&gt;&lt;a href=&quot;#Introducation&quot; class=&quot;headerlink&quot; title=&quot;Introducation&quot;&gt;&lt;/a&gt;Introducation&lt;/h3&gt;&lt;h4 id=&quot;What-is-a-Java-Agent&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Instrumentation" scheme="https://sulangsss.github.io/tags/Instrumentation/"/>
    
  </entry>
  
  <entry>
    <title>职称</title>
    <link href="https://sulangsss.github.io/2018/11/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/%E8%81%8C%E7%A7%B0/"/>
    <id>https://sulangsss.github.io/2018/11/19/读书笔记/认知/职称/</id>
    <published>2018-11-19T14:24:07.000Z</published>
    <updated>2018-11-21T03:00:26.058Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构层次"><a href="#结构层次" class="headerlink" title="结构层次"></a>结构层次</h3><ol><li>董事会 board of director，制定政策</li><li>董事（公司的老板们）</li><li>董事长 chairman of the board（董事们任命)，股份最多</li><li>CEO（chief executive officer），行政级别最高领导人，最高决策人，董事会任命，执行政策</li><li>CFO（chief financial officer）部门老大</li><li>COO（chief operating officer）部门老大</li><li>CTO（chief technology officer）部门老大</li><li>总监，主管，项目经理 etc.</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;结构层次&quot;&gt;&lt;a href=&quot;#结构层次&quot; class=&quot;headerlink&quot; title=&quot;结构层次&quot;&gt;&lt;/a&gt;结构层次&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;董事会 board of director，制定政策&lt;/li&gt;
&lt;li&gt;董事（公司的老板们）&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/tags/%E8%AE%A4%E7%9F%A5/"/>
    
      <category term="职称" scheme="https://sulangsss.github.io/tags/%E8%81%8C%E7%A7%B0/"/>
    
  </entry>
  
  <entry>
    <title>开曼群岛</title>
    <link href="https://sulangsss.github.io/2018/11/19/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/%E5%BC%80%E6%9B%BC%E7%BE%A4%E5%B2%9B/"/>
    <id>https://sulangsss.github.io/2018/11/19/读书笔记/认知/开曼群岛/</id>
    <published>2018-11-19T14:24:07.000Z</published>
    <updated>2018-11-19T14:21:43.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>个人所得税，不交</li><li>公司所得税，不交</li><li>资本利得税，不交</li><li>不动产税，不交</li><li>遗产税，不交</li></ol><h3 id="VIE"><a href="#VIE" class="headerlink" title="VIE"></a>VIE</h3><p>Variable Interest Entity 可变利益实体</p><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>在新加坡生产一台 Mac Pro，以$200价格卖给 -&gt; 开曼群岛财务公司，以$900卖给 -&gt; 美国Apple公司，以$1000 -&gt; 分销商</p><p>在美国，Apple实际上只为$100交税，规避了大部分税收。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;优势&quot;&gt;&lt;a href=&quot;#优势&quot; class=&quot;headerlink&quot; title=&quot;优势&quot;&gt;&lt;/a&gt;优势&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;个人所得税，不交&lt;/li&gt;
&lt;li&gt;公司所得税，不交&lt;/li&gt;
&lt;li&gt;资本利得税，不交&lt;/li&gt;
&lt;li&gt;不动产税，不交&lt;/l
      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E8%AE%A4%E7%9F%A5/"/>
    
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="开曼群岛" scheme="https://sulangsss.github.io/tags/%E5%BC%80%E6%9B%BC%E7%BE%A4%E5%B2%9B/"/>
    
      <category term="认知" scheme="https://sulangsss.github.io/tags/%E8%AE%A4%E7%9F%A5/"/>
    
  </entry>
  
  <entry>
    <title>Nginx SSL</title>
    <link href="https://sulangsss.github.io/2018/11/19/Nginx/SSL/"/>
    <id>https://sulangsss.github.io/2018/11/19/Nginx/SSL/</id>
    <published>2018-11-19T09:38:18.000Z</published>
    <updated>2018-11-19T09:22:23.380Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Conf"><a href="#Conf" class="headerlink" title="Conf"></a>Conf</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># use let's encrypt ssl</span></span><br><span class="line">listen 80;</span><br><span class="line">listen 443 default_server ssl;</span><br><span class="line">ssl_certificate /etc/letsencrypt/live/sit.leverup.com/fullchain.pem;</span><br><span class="line">ssl_certificate_key /etc/letsencrypt/live/sit.leverup.com/privkey.pem;</span><br><span class="line">charset utf-8;</span><br><span class="line">server_name sit.leverup.com;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Conf&quot;&gt;&lt;a href=&quot;#Conf&quot; class=&quot;headerlink&quot; title=&quot;Conf&quot;&gt;&lt;/a&gt;Conf&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="Server" scheme="https://sulangsss.github.io/categories/Server/"/>
    
      <category term="Nginx" scheme="https://sulangsss.github.io/categories/Server/Nginx/"/>
    
    
      <category term="Nginx" scheme="https://sulangsss.github.io/tags/Nginx/"/>
    
      <category term="SSL" scheme="https://sulangsss.github.io/tags/SSL/"/>
    
      <category term="Conf" scheme="https://sulangsss.github.io/tags/Conf/"/>
    
  </entry>
  
</feed>
