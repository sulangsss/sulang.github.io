<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>sulang blog</title>
  
  <subtitle>python java android django web</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulangsss.github.io/"/>
  <updated>2018-10-29T08:39:42.939Z</updated>
  <id>https://sulangsss.github.io/</id>
  
  <author>
    <name>sulang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vim Keymap</title>
    <link href="https://sulangsss.github.io/2018/10/29/Vim/Keymap/"/>
    <id>https://sulangsss.github.io/2018/10/29/Vim/Keymap/</id>
    <published>2018-10-29T07:01:22.000Z</published>
    <updated>2018-10-29T08:39:42.939Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Edit"><a href="#Edit" class="headerlink" title="Edit"></a>Edit</h3><p>dd删除一行，yy复制一行，cc删除一行文本并开始插入，&gt;&gt; 当前行缩进一格，==自动缩进当前行</p><h3 id="Move-Cursor"><a href="#Move-Cursor" class="headerlink" title="Move Cursor"></a>Move Cursor</h3><p>$ - 从光标位置到行尾</p><p>^ - 从光标位置到行首，不包含缩进空白 </p><p>0 - 从光标位置到行首，包含缩进空白 </p><p>gg - 从光标位置到文件开头 </p><p>G - 从光标位置到文件结尾 </p><p>% - 从光标位置到另一边匹配的括号 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Edit&quot;&gt;&lt;a href=&quot;#Edit&quot; class=&quot;headerlink&quot; title=&quot;Edit&quot;&gt;&lt;/a&gt;Edit&lt;/h3&gt;&lt;p&gt;dd删除一行，yy复制一行，cc删除一行文本并开始插入，&amp;gt;&amp;gt; 当前行缩进一格，==自动缩进当前行&lt;/p&gt;
&lt;h3
      
    
    </summary>
    
      <category term="Vim" scheme="https://sulangsss.github.io/categories/Vim/"/>
    
    
      <category term="Vim" scheme="https://sulangsss.github.io/tags/Vim/"/>
    
      <category term="Keymap" scheme="https://sulangsss.github.io/tags/Keymap/"/>
    
  </entry>
  
  <entry>
    <title>马克·彭德格拉斯特 - For God,Country &amp;Coca-Cola 可口可乐传</title>
    <link href="https://sulangsss.github.io/2018/10/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E4%BC%A0%E8%AE%B0/%E5%8F%AF%E5%8F%A3%E5%8F%AF%E4%B9%90%E4%BC%A0/"/>
    <id>https://sulangsss.github.io/2018/10/29/读书笔记/传记/可口可乐传/</id>
    <published>2018-10-29T05:07:07.000Z</published>
    <updated>2018-10-29T06:01:32.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h3><img src="/2018/10/29/读书笔记/传记/可口可乐传/core.png">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;核心内容&quot;&gt;&lt;a href=&quot;#核心内容&quot; class=&quot;headerlink&quot; title=&quot;核心内容&quot;&gt;&lt;/a&gt;核心内容&lt;/h3&gt;&lt;img src=&quot;/2018/10/29/读书笔记/传记/可口可乐传/core.png&quot;&gt;

      
    
    </summary>
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书笔记" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="可口可乐传" scheme="https://sulangsss.github.io/tags/%E5%8F%AF%E5%8F%A3%E5%8F%AF%E4%B9%90%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>FMEA（Failure mode and effects analysis）</title>
    <link href="https://sulangsss.github.io/2018/10/28/Architecture/FMEA/"/>
    <id>https://sulangsss.github.io/2018/10/28/Architecture/FMEA/</id>
    <published>2018-10-28T14:01:22.000Z</published>
    <updated>2018-10-29T03:07:17.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Term"><a href="#Term" class="headerlink" title="Term"></a>Term</h3><p>FEMA：故障模式与影响分析，一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重程度进行分类，以确定失效对于系统的最终影响。<strong>它是一套分析和思考的方法，而不是某个领域的技能或工具。</strong></p><h3 id="应用于架构领域"><a href="#应用于架构领域" class="headerlink" title="应用于架构领域"></a>应用于架构领域</h3><p>FMEA分析方法：</p><ul><li>给出初始的架构设计图</li><li>假设架构中某个部件发生故障</li><li>分析次故障对系统功能造成的影响</li><li>根据分析结果，判断架构是否需要进行优化</li></ul><p>FMEA分析方法，其实是一个分析表，表格包含部分</p><ul><li>功能点：从用户的角度来看的功能点。比如用户管理系统，FEMA分析的是”登录“，”注册“功能点。</li><li>故障模式：系统会出现什么样的故障，包括故障点和故障形式。故障模式描述尽量精确，多用量化描述，避免使用泛华的描述。</li><li>故障影响：当发生故障模式中描述的故障时，功能点具体会受到什么影响。常见的影响：功能点偶尔不可用、功能点完全不可用、部分用户功能点不可用、功能点响应缓慢、功能点出错等等</li><li>严重程度：站在业务的角度看，故障影响程度一般分为：致命、高、中、低、无。严重程度 = 功能点重要程度 <em> 故障影响范围 </em> 功能点受损程度</li><li>故障原因</li><li>故障概率：某个具体故障原因发生的概率。一般分为：高、中、低。</li><li>风险程度：综合严重程度和故障概率一起判断某个故障的最终等级，风险程度 = 严重程度 * 故障概率。</li><li>已有措施：针对具体的故障原因，系统现在是否提供了某些措施来应对，包括检测告警、容错、自恢复等等。</li><li>规避措施：为了降低故障发生概率而做的一些事情，可以是技术手段，也可以是管理手段。<ul><li>为了避免新引入的MongoDB丢失数据，在MySQL中冗余一份</li><li>为了降低某些疑难bug的出现，每天凌晨重启机器</li></ul></li><li>解决措施：为了能够解决问题而做的一些事情，一般都是技术手段。<ul><li>为了解决密码暴力破解，增加密码重试次数限制</li><li>为了解决拖库导致密码泄露，将数据库中的敏感数据加密保存</li></ul></li><li>后续规划</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Term&quot;&gt;&lt;a href=&quot;#Term&quot; class=&quot;headerlink&quot; title=&quot;Term&quot;&gt;&lt;/a&gt;Term&lt;/h3&gt;&lt;p&gt;FEMA：故障模式与影响分析，一种在各行各业都有广泛应用的可用性分析方法，通过对系统范围内潜在的故障模式加以分析，并按照严重
      
    
    </summary>
    
      <category term="Architecture" scheme="https://sulangsss.github.io/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="https://sulangsss.github.io/tags/Architecture/"/>
    
      <category term="FMEA" scheme="https://sulangsss.github.io/tags/FMEA/"/>
    
  </entry>
  
  <entry>
    <title>DS AVL Tree</title>
    <link href="https://sulangsss.github.io/2018/10/26/DS/AVL-Tree/"/>
    <id>https://sulangsss.github.io/2018/10/26/DS/AVL-Tree/</id>
    <published>2018-10-26T02:28:19.000Z</published>
    <updated>2018-10-28T13:59:35.799Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="DS" scheme="https://sulangsss.github.io/categories/DS/"/>
    
    
      <category term="DS" scheme="https://sulangsss.github.io/tags/DS/"/>
    
      <category term="Tree" scheme="https://sulangsss.github.io/tags/Tree/"/>
    
      <category term="AVL" scheme="https://sulangsss.github.io/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>DS Tree</title>
    <link href="https://sulangsss.github.io/2018/10/26/DS/Tree/"/>
    <id>https://sulangsss.github.io/2018/10/26/DS/Tree/</id>
    <published>2018-10-26T02:28:19.000Z</published>
    <updated>2018-10-28T10:47:50.749Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tree-Feature"><a href="#Tree-Feature" class="headerlink" title="Tree Feature"></a>Tree Feature</h3><ul><li>一个节点，即只有根节点，也可以是一棵树</li><li>其中任何一个节点与下面所有节点构成的树称为子树</li><li>根节点没有父节点，而子叶节点没有子节点</li><li>除根节点外，任何节点有且仅有一个父节点</li><li>任何节点可以有0~n个子节点</li><li>高度与深度的区别：叶子节点定义高度为1<ul><li>高度：从节点到其子叶节点经过的最长路径</li><li>深度：从根节点往下到叶节点最长路径（根节点为1）</li><li>相同深度的节点，高度不一定相同</li></ul></li></ul><h3 id="Binary-Search-Tree（二叉查找树）"><a href="#Binary-Search-Tree（二叉查找树）" class="headerlink" title="Binary Search Tree（二叉查找树）"></a>Binary Search Tree（二叉查找树）</h3><p>遍历方式</p><ul><li>前序遍历</li><li>中序遍历</li><li>后序遍历</li></ul><h3 id="AVL-平衡二叉树"><a href="#AVL-平衡二叉树" class="headerlink" title="AVL(平衡二叉树)"></a>AVL(平衡二叉树)</h3><p>一种平衡二叉查找树，增加和删除节点后通过树形旋转重新达到平衡。</p><p>一颗完美平衡的树查找树中，所有空节点到根节点的距离应该是相同的。</p><p>特性：</p><ul><li>树的左右高度差不能超过1</li><li>任何往下递归的左子树与右子树，必须符合第一条性质</li><li>没有任何节点的空树或只有根节点的树也是平衡二叉树</li></ul><p>在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–旋转。</p><p>旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。</p><p>旋转操作</p><ul><li>所谓的左旋和右旋都是以子树为原点的：如b是a的子树，那么旋转就围绕b来进行。</li><li>如果b是a的左子树，那么就围绕b将a向右旋转，看着就像是a直接掉下来了，掉成了b的右子树。</li><li>如果b是a的右子树，那么就围绕b将a向左旋转，看着就像是a直接掉下来了，掉成了b的左子树。</li></ul><p>旋转类型</p><ul><li>LL：在a的左子树根节点的左子树上插入节点而破坏平衡，旋转方式-右旋转</li><li>RR：在a的右子树根节点的右子树上插入节点而破坏平衡，旋转方式-左旋转</li><li>LR：在a的左子树根节点的右子树上插入节点而破坏平衡，旋转方式-先左后右</li><li>RL：在a的右子树根节点的左子树上插入节点而破坏平衡，旋转方式-先右后左</li></ul><h4 id="LL"><a href="#LL" class="headerlink" title="LL"></a>LL</h4><img src="/2018/10/26/DS/Tree/example-ll.png"><p>此时，节点7的左子树高度为2，右子树为0，则两边的差值超过1。</p><p>围绕节点5进行右旋转，因为节点5没有右子节点，此时可以直接把节点7设置为节点5的右子节点。需要注意的是，当调节完当前节点的平衡后，需要向上检查是否有节点出现不平衡的现象。</p><p>如果节点5已经存在右子树（节点7是节点5的父节点，肯定比节点5大，即也比节点5的右子节点大），此时节点7如何处理？请看下图</p><img src="/2018/10/26/DS/Tree/example-2-ll.png"><p>仍然针对节点5进行右旋，节点7仍然为节点5的右子树，节点6成为节点7的左子树，此时节点5已经平衡。但是当我们再看节点8的时候，节点8却失衡了。</p><h4 id="RR"><a href="#RR" class="headerlink" title="RR"></a>RR</h4><img src="/2018/10/26/DS/Tree/example-rr.png"><p>如果节点13已经有左子树，怎么办？</p><h4 id="LR"><a href="#LR" class="headerlink" title="LR"></a>LR</h4><img src="/2018/10/26/DS/Tree/example-lr.png"><p>如果节点5已经有左子树，怎么办？</p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h3 id="应用场景对比"><a href="#应用场景对比" class="headerlink" title="应用场景对比"></a>应用场景对比</h3><h4 id="红黑树与AVL树"><a href="#红黑树与AVL树" class="headerlink" title="红黑树与AVL树"></a>红黑树与AVL树</h4><ul><li>频繁的插入和删除，红黑树更加适合</li><li>低频修改和大量查询，AVL树更加适合</li></ul><h3 id="Refer-to"><a href="#Refer-to" class="headerlink" title="Refer to"></a>Refer to</h3><blockquote><p><a href="https://blog.csdn.net/qq_25806863/article/details/74755131" target="_blank" rel="noopener">https://blog.csdn.net/qq_25806863/article/details/74755131</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Tree-Feature&quot;&gt;&lt;a href=&quot;#Tree-Feature&quot; class=&quot;headerlink&quot; title=&quot;Tree Feature&quot;&gt;&lt;/a&gt;Tree Feature&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个节点，即只有根节点，也可以是一棵树&lt;/li&gt;
      
    
    </summary>
    
      <category term="DS" scheme="https://sulangsss.github.io/categories/DS/"/>
    
    
      <category term="DS" scheme="https://sulangsss.github.io/tags/DS/"/>
    
      <category term="Tree" scheme="https://sulangsss.github.io/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Java Performance JMH</title>
    <link href="https://sulangsss.github.io/2018/10/25/Java/Performance/JMH/"/>
    <id>https://sulangsss.github.io/2018/10/25/Java/Performance/JMH/</id>
    <published>2018-10-25T09:01:22.000Z</published>
    <updated>2018-10-26T02:13:31.996Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usega"><a href="#Usega" class="headerlink" title="Usega"></a>Usega</h3><ul><li>创建测试工程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate </span><br><span class="line"> -DinteractiveMode=<span class="literal">false</span> </span><br><span class="line"> -DarchetypeGroupId=org.openjdk.jmh </span><br><span class="line"> -DarchetypeArtifactId=jmh-java-benchmark-archetype </span><br><span class="line"> -DgroupId=com.afei.jmh </span><br><span class="line"> -DartifactId=jmh </span><br><span class="line"> -Dversion=1.0.0-SNAPSHOT</span><br></pre></td></tr></table></figure><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><h4 id="Unable-to-find-the-resource-META-INF-BenchmarkList"><a href="#Unable-to-find-the-resource-META-INF-BenchmarkList" class="headerlink" title="Unable to find the resource: /META-INF/BenchmarkList"></a>Unable to find the resource: /META-INF/BenchmarkList</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usega&quot;&gt;&lt;a href=&quot;#Usega&quot; class=&quot;headerlink&quot; title=&quot;Usega&quot;&gt;&lt;/a&gt;Usega&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;创建测试工程&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Performance" scheme="https://sulangsss.github.io/categories/Java/Performance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Performance" scheme="https://sulangsss.github.io/tags/Performance/"/>
    
      <category term="JMH" scheme="https://sulangsss.github.io/tags/JMH/"/>
    
  </entry>
  
  <entry>
    <title>每天一本书：提问的艺术</title>
    <link href="https://sulangsss.github.io/2018/10/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://sulangsss.github.io/2018/10/25/读书笔记/提问的艺术/</id>
    <published>2018-10-25T05:51:22.000Z</published>
    <updated>2018-10-25T06:06:15.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何提问"><a href="#如何提问" class="headerlink" title="如何提问"></a>如何提问</h3><h4 id="第一步：要从问句开始，而不是用阐述或者命令"><a href="#第一步：要从问句开始，而不是用阐述或者命令" class="headerlink" title="第一步：要从问句开始，而不是用阐述或者命令"></a>第一步：要从问句开始，而不是用阐述或者命令</h4><p>比如，你是公司的老总，对公司的客服不满意，如果你对客服们说“我们需要改进客服质量”，这个效果可能不会很好。</p><p>你可以问他们：“你怎么评价我们今天的客服表现？”这个提问会让客服人员自己琢磨一下：今天能给自己打几分？哪儿做得好？哪儿做得不好？这比你去灌输一些评价，效果要好。处理家庭关系时也能用这个办法。</p><h4 id="第二步：问一些每个人都会想到的、最基本的问题（司空见惯的问题）"><a href="#第二步：问一些每个人都会想到的、最基本的问题（司空见惯的问题）" class="headerlink" title="第二步：问一些每个人都会想到的、最基本的问题（司空见惯的问题）"></a>第二步：问一些每个人都会想到的、最基本的问题（司空见惯的问题）</h4><p>很多事看久了，就习惯了，不太去琢磨它到底是怎么回事了。但有时你仔细思考一下，才发现对一些事儿，其实我们并不太明白它们到底意味着什么。</p><p>比如现在最流行的一个词儿是“创新”。在工作里经常有人说：“我们需要创新。”但是每天听，都听疲沓了，而且搞来搞去，也创新不出什么东西。那么你再听到有人这样说的时候，可以问一问他：“你眼中的创新究竟是什么样的呢？”可能一下子就把人问住了，然后就开始琢磨：是啊，究竟什么样呢？这就不是空喊口号了，开始考虑实际了。</p><h3 id="提问方法"><a href="#提问方法" class="headerlink" title="提问方法"></a>提问方法</h3><ul><li>封闭式提问</li><li>开放性提问</li><li>追问式提问</li></ul><h4 id="封闭式提问"><a href="#封闭式提问" class="headerlink" title="封闭式提问"></a>封闭式提问</h4><p>什么叫封闭型提问呢？就是问得非常具体，对方只能正面回答，给出直接的答案。比如，关于创新、团队的提问，其实都属于封闭型的提问。</p><p>最典型的封闭型提问，是“是非题”，对方只能回答“是”或者“不是”。</p><p><strong>什么时候需要用到封闭型提问呢？</strong>一般是在发生“大猩猩式的斗殴”的时候。</p><p>这儿说的不是真的斗殴，是一种比喻。研究生物的人发现，公猩猩在打架的时候，喜欢互相示威，互相围着转，一边转着，一边在手里抓着土，往天上扬，没别的意思，就是吓唬对方，然后转了半天也打不起来。所以“大猩猩式的斗殴”指的就是兜圈子，不干实事。</p><p>当你和别人谈一件事，别人总是兜圈子时，就适合用封闭型提问，直接要求他给答案。举个例子，公司里开会，讨论的是“客户至上”的话题，一开就是很长时间，总也没有实质性的结论。那么这时候就适合提出封闭型的问题：我们今天要做什么样的决定？是提高客户保有率，还是交叉销售更多的产品？提问越具体，越容易从泛泛的讨论中跳出来。</p><h4 id="开放性提问"><a href="#开放性提问" class="headerlink" title="开放性提问"></a>开放性提问</h4><p>在人际交往中，就需要经常用到第二种提问方式，就是开放性提问。</p><p>所谓开放性，就是没有固定的答案，可以随便说。</p><p>美国著名作家梭罗独自住在波士顿附近的瓦尔登湖畔，他写了一本书叫《瓦尔登湖》，梭罗特别爱写日记，有一天他写了这么一句话：“今天，我得到的最大恭维就是有人问我，我是怎么想的，并真诚地聆听了我的答案。”梭罗写出了人的一种心理，就是希望被聆听。</p><p>这可能有点违反直觉，因为我们总是下意识地以为，和别人聊天时，说得越多，越不容易冷场，越显得尊重别人。但其实不是，绝大多数人实际上更愿意表达，如果你一直在滔滔不绝地说话，别人插不上嘴，等于剥夺了别人表达的权利，对方就会觉得不舒服。</p><p>所以会聊天的人，一定是善于倾听的人。怎么做到这一点呢？还是靠提问，而且得靠开放性的提问。有一次，本书的作者走访安利集团的创始人，他就问了对方一句话，就让这个大老板开始滔滔不绝。他是这么问的：“请告诉我，你当初是如何开始的？”然后，对方就开始讲故事，讲一个大学肄业的人最终如何打造了市值上百亿美元的集团。</p><p>“你是如何开始的”，这个问题可以衍生出很多问题，比如“你们是怎么相爱的”“你在哪里长大的”“你是和谁学的弹琴”。再比如，“你还有什么迫切想实现的愿望吗”“对你来说最高兴的一天是哪一天”“你一生中最值得骄傲的成就是什么”。开放性的问题不能用简单的“是”或“否”来回答，它需要更清楚的解读，会带来更丰富的互动。</p><p>无论是和成功人士还是普通人聊天，这种问题都会让对方发现自己不平凡的一面，愿意与你开心分享他们的故事。</p><h4 id="追问式提问"><a href="#追问式提问" class="headerlink" title="追问式提问"></a>追问式提问</h4><p>沟通不是单方面的事情，它确实需要倾听，但又不能只是倾听。有时候为了发现并且解决一些问题，就需要进行追问。</p><p>有一次，一个国际性企业发现自己的销售出现了问题，觉得需要进行改进性的培训，就找到本书的作者，托他办个培训班。作者没有一上来就答应，而是问了销售部主管五个问题。</p><p>第一个问题：为什么你们在全球销售市场中都成为领先者了，还需要销售培训呢？对方说，因为需要不断提高销售人员的能力；</p><p>他接着问了第二个问题：为什么需要提高销售能力呢？对方又说：这样销售人员在开发新客户方面会更有效率；</p><p>接着是第三个问题：为什么需要增加新客户的开发呢？对方说，因为现在的客户不足以支撑公司的增长目标；</p><p>第四个问题又来了：为什么不能让客户增长得更快呢？对方说：我们每年都20%的客户流失。</p><p>好，最后一个问题：为什么客户会流失？最终，公司的销售人员给出了答案，他们的产品质量和物流有问题，所以客户才不满意。</p><p>就这样，五个问题追问下来，没有做销售培训的必要了，解决产品质量和物流漏洞才是关键。这就是追问的效果，它会帮助你找到问题的核心所在。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>三种提问方式都说到了，我们来总结一下：</p><ul><li>封闭式的提问，适用于得到明确答案时提出；</li><li>开放性提问，适合需要深谈的人际沟通时提出；</li><li>追问，适合在复杂情况中寻找核心问题时提出。</li></ul><p>提问这件事，说起来简单，做起来难。我们经常会被一些事情困扰，想要去解决它们，但是往往找不到原因，更常见的情况是，我们连问题本身是什么都描述不清楚。</p><h3 id="企业组织"><a href="#企业组织" class="headerlink" title="企业组织"></a>企业组织</h3><p>问自己五个问题：</p><ul><li>你的愿景是什么？</li><li>什么是你愿意投入身心去打造最重要的关系？</li><li>什么能创造客户价值？</li><li>你期望得到的结果是什么？</li><li>你的计划是什么？</li></ul><p>核心指向：你为什么要这么做？你的存在是什么价值？你会对别人会产生什么样的影响？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何提问&quot;&gt;&lt;a href=&quot;#如何提问&quot; class=&quot;headerlink&quot; title=&quot;如何提问&quot;&gt;&lt;/a&gt;如何提问&lt;/h3&gt;&lt;h4 id=&quot;第一步：要从问句开始，而不是用阐述或者命令&quot;&gt;&lt;a href=&quot;#第一步：要从问句开始，而不是用阐述或者命令&quot; c
      
    
    </summary>
    
      <category term="读书" scheme="https://sulangsss.github.io/categories/%E8%AF%BB%E4%B9%A6/"/>
    
    
      <category term="读书" scheme="https://sulangsss.github.io/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="提问的艺术" scheme="https://sulangsss.github.io/tags/%E6%8F%90%E9%97%AE%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Inline</title>
    <link href="https://sulangsss.github.io/2018/10/23/Java/Kotlin/Inline/"/>
    <id>https://sulangsss.github.io/2018/10/23/Java/Kotlin/Inline/</id>
    <published>2018-10-23T09:27:22.000Z</published>
    <updated>2018-10-23T10:03:32.417Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><p>One of them is high order functions which lets you pass functions as parameters as well as return functions. But the fact that they are stored as objects may make the use disadvantageous at times because of the memory overhead. </p><p>The thing is, each object is allocated space in memory heap and the methods that call this method are also allocated space.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    var a = <span class="number">2</span></span><br><span class="line">    println(someMethod(a, &#123;println(<span class="string">"Just some dummy function"</span>)&#125;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">someMethod</span><span class="params">(a: Int, func: ()</span> -&gt; Unit):Int </span>&#123;</span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A way to get around the memory overhead issue is, by declaring the function inline. inline annotation means that function as well as function parameters will be expanded at call site that means it helps reduce call overhead. </p><p>The goal of this post is to get a basic understanding of inline in Kotlin so as to be able to identify how and when to use it in our code in future.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">inline fun <span class="title">someMethod</span><span class="params">(a: Int, func: ()</span> -&gt; Unit):Int </span>&#123;</span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Usage&quot;&gt;&lt;a href=&quot;#Usage&quot; class=&quot;headerlink&quot; title=&quot;Usage&quot;&gt;&lt;/a&gt;Usage&lt;/h3&gt;&lt;p&gt;One of them is high order functions which lets you pass fu
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/categories/Java/Kotlin/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/tags/Kotlin/"/>
    
      <category term="Inline" scheme="https://sulangsss.github.io/tags/Inline/"/>
    
  </entry>
  
  <entry>
    <title>国际 International</title>
    <link href="https://sulangsss.github.io/2018/10/23/Unpopular-Knowledge/%E5%9B%BD%E9%99%85-International/"/>
    <id>https://sulangsss.github.io/2018/10/23/Unpopular-Knowledge/国际-International/</id>
    <published>2018-10-23T02:01:22.000Z</published>
    <updated>2018-10-25T02:20:44.822Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一国际-1864-1876年"><a href="#第一国际-1864-1876年" class="headerlink" title="第一国际(1864-1876年)"></a>第一国际(1864-1876年)</h3><p>社会主义先觉者很早就主张各国工人运动有国际的联络和国际的组织之必要了。把这个必要说得最明白，最不含糊的，是马克思和恩格斯。远在1847年，即距今99年前，马克思和恩格斯在他们起草的「共产党宣言」中就断言「无产阶级无祖国」，就喊出「全世界无产者联合起来」口号。自此以后，他们的思想和斗争就浸透这种国际主义精神。</p><p>到了1864年，这种国际主义精神第一次表现为组织形式。这年，英法德意四国工人代表在伦敦开会，决议创立一个「Intelnational WorkingMen’s Association」，为诸国工人团体联络机关。这个新团体底名称直译应为「工人底国际的联合会」，这里「国际」二字是作形容词用的。即「英法德意诸国工人联合会」之意。马克思当时代表德国工人参加这个新团体工作，渐渐以科学的社会主义思想指导整个组织了。不久，会务大大开展，小国工人也来参加这个组织，遂成为世界上一种势力，为诸国政府所畏惧。会名太长，有时人们取它的第一个字，简称为「International」（「国际的」）以后成了习惯，整个团体就叫做「国际」了。这是第一次，这个形容词变成了名词。</p><p>1871年，巴黎工人暴动，「国际」底法国支部不仅参加，而且占据领导地位。可是这次有名的「巴黎公盟」失败了，「国际」受了极大打击，外面资产阶级政府底取缔，里面小资产阶级思想底进攻，遂使组织力量一天比一天衰弱，终于在1876年正式宣布解散。马克思领导的这个「工人国际会」在工人运动历史上被称为「第一国际」，以别于后来的几个工人国际组织。</p><hr><h3 id="第二国际-1889-1914年"><a href="#第二国际-1889-1914年" class="headerlink" title="第二国际(1889-1914年)"></a>第二国际(1889-1914年)</h3><h3 id="第三国际-1919-1943年"><a href="#第三国际-1919-1943年" class="headerlink" title="第三国际(1919-1943年)"></a>第三国际(1919-1943年)</h3><h3 id="第四国际"><a href="#第四国际" class="headerlink" title="第四国际"></a>第四国际</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;第一国际-1864-1876年&quot;&gt;&lt;a href=&quot;#第一国际-1864-1876年&quot; class=&quot;headerlink&quot; title=&quot;第一国际(1864-1876年)&quot;&gt;&lt;/a&gt;第一国际(1864-1876年)&lt;/h3&gt;&lt;p&gt;社会主义先觉者很早就主张各国工人
      
    
    </summary>
    
      <category term="Unpopular Knowledge" scheme="https://sulangsss.github.io/categories/Unpopular-Knowledge/"/>
    
    
      <category term="Unpopular Knowledge" scheme="https://sulangsss.github.io/tags/Unpopular-Knowledge/"/>
    
      <category term="Internaltional" scheme="https://sulangsss.github.io/tags/Internaltional/"/>
    
      <category term="国际" scheme="https://sulangsss.github.io/tags/%E5%9B%BD%E9%99%85/"/>
    
  </entry>
  
  <entry>
    <title>Java slf4j</title>
    <link href="https://sulangsss.github.io/2018/10/23/Java/Log/slf4j/"/>
    <id>https://sulangsss.github.io/2018/10/23/Java/Log/slf4j/</id>
    <published>2018-10-23T02:01:22.000Z</published>
    <updated>2018-10-24T03:00:44.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><h4 id="Failed-to-load-class-“org-slf4j-impl-StaticLoggerBinder”"><a href="#Failed-to-load-class-“org-slf4j-impl-StaticLoggerBinder”" class="headerlink" title="Failed to load class “org.slf4j.impl.StaticLoggerBinder”."></a>Failed to load class “org.slf4j.impl.StaticLoggerBinder”.</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-jdk14<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.25<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Error&quot;&gt;&lt;a href=&quot;#Error&quot; class=&quot;headerlink&quot; title=&quot;Error&quot;&gt;&lt;/a&gt;Error&lt;/h3&gt;&lt;h4 id=&quot;Failed-to-load-class-“org-slf4j-impl-StaticLoggerBind
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Log" scheme="https://sulangsss.github.io/categories/Java/Log/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Log" scheme="https://sulangsss.github.io/tags/Log/"/>
    
      <category term="slf4j" scheme="https://sulangsss.github.io/tags/slf4j/"/>
    
  </entry>
  
  <entry>
    <title>Java Calculate Overflow</title>
    <link href="https://sulangsss.github.io/2018/10/19/Java/Math/Caculate-Overflow/"/>
    <id>https://sulangsss.github.io/2018/10/19/Java/Math/Caculate-Overflow/</id>
    <published>2018-10-19T08:01:22.000Z</published>
    <updated>2018-10-19T09:01:35.493Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Long"><a href="#Long" class="headerlink" title="Long"></a>Long</h3><h4 id="Avoid-Overflow"><a href="#Avoid-Overflow" class="headerlink" title="Avoid Overflow"></a>Avoid Overflow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    val result = Math.multiplyExact(Long.MAX_VALUE, Long.MAX_VALUE)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: ArithmeticException) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">Assert.fail()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Long&quot;&gt;&lt;a href=&quot;#Long&quot; class=&quot;headerlink&quot; title=&quot;Long&quot;&gt;&lt;/a&gt;Long&lt;/h3&gt;&lt;h4 id=&quot;Avoid-Overflow&quot;&gt;&lt;a href=&quot;#Avoid-Overflow&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Math" scheme="https://sulangsss.github.io/categories/Java/Math/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Math" scheme="https://sulangsss.github.io/tags/Math/"/>
    
      <category term="Calculate" scheme="https://sulangsss.github.io/tags/Calculate/"/>
    
      <category term="Overflow" scheme="https://sulangsss.github.io/tags/Overflow/"/>
    
  </entry>
  
  <entry>
    <title>Kotlin Annotation</title>
    <link href="https://sulangsss.github.io/2018/10/19/Java/Kotlin/Annotation/"/>
    <id>https://sulangsss.github.io/2018/10/19/Java/Kotlin/Annotation/</id>
    <published>2018-10-19T02:01:22.000Z</published>
    <updated>2018-10-25T08:55:02.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>反射（Reflection）是在运行时获取类的函数（方法）、属性、父类、接口、注解元数据、泛型信息等类的内部信息的机制。这些信息我们称之为 RTTI（Run-Time Type Information，运行时类型信息) 。</p><p>注解（Annotation）是我们给代码添加的元数据。使用注解可以写出更加简洁干净的代码，同时还可以在编译期进行类型检查。Kotlin 的注解完全兼容 Java 的注解。</p><h4 id="Meta-programming"><a href="#Meta-programming" class="headerlink" title="Meta-programming"></a>Meta-programming</h4><blockquote><p><a href="https://segmentfault.com/a/1190000011975672" target="_blank" rel="noopener">https://segmentfault.com/a/1190000011975672</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Introduction&quot;&gt;&lt;a href=&quot;#Introduction&quot; class=&quot;headerlink&quot; title=&quot;Introduction&quot;&gt;&lt;/a&gt;Introduction&lt;/h3&gt;&lt;p&gt;反射（Reflection）是在运行时获取类的函数（方法）、
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/categories/Java/Kotlin/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Kotlin" scheme="https://sulangsss.github.io/tags/Kotlin/"/>
    
      <category term="Annotation" scheme="https://sulangsss.github.io/tags/Annotation/"/>
    
  </entry>
  
  <entry>
    <title>Java Aeron</title>
    <link href="https://sulangsss.github.io/2018/10/16/Java/LowLatency/Aeron/"/>
    <id>https://sulangsss.github.io/2018/10/16/Java/LowLatency/Aeron/</id>
    <published>2018-10-16T10:01:22.000Z</published>
    <updated>2018-10-18T05:22:05.982Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Design-Overview"><a href="#Design-Overview" class="headerlink" title="Design Overview"></a>Design Overview</h3><p><a href="https://github.com/real-logic/aeron/wiki/Design-Overview" target="_blank" rel="noopener">https://github.com/real-logic/aeron/wiki/Design-Overview</a></p><hr><h3 id="Media-Driver"><a href="#Media-Driver" class="headerlink" title="Media Driver"></a>Media Driver</h3><p>Media Driver instances sit on a box an send/receive UDP packets over the network, whilst ensuring that the mapped files and cleaned and rotated. </p><p>If you’ve got multiple publishers or subscribers sitting in different processes on the same box then probably your best bet is to run separate a instance of the media driver and have it manage all the processes.</p><p>If you’re going to just have a single process on a machine with the publishers and subscribers inside then its probably easiest to just keep it embedded within the process. Just my opinion of course</p><p>Aeron instances in application, commonly referred to as “clients”, communicate with Media Drivers via a set of buffers. </p><p>The location of these buffers is normally in the OS file system. By default, the java.io.tmpdir or /dev/shm/ is used to hold these files. </p><h4 id="How-to-Run-Aeron-Media-Driver"><a href="#How-to-Run-Aeron-Media-Driver" class="headerlink" title="How to Run Aeron Media Driver"></a>How to Run Aeron Media Driver</h4><p>To run the Aeron Media Driver as a foreground process, use the script provided with the driver. The script provides the appropriate configuration for the driver. You can provide your own configuration via environment variables:</p><ul><li>AERON_DIR（Method：aeronDirectoryName()）</li></ul><p>The path to the directory where the Aeron Media Driver needs to store its files. On Linux, the directory inside /dev/shm/ is recommended. If you provide your own path, make it the same for the driver and any microservice that operates with this driver.</p><p>If it is not specified then the default value provided by the Aeron is used.</p><ul><li>AERON_SO_BUFFER</li></ul><p>The size in bytes of the send and receive socket buffers. The length of the buffer must be a power of two. On Linux, it must not exceed the kernel configuration parameters:</p><p>net.core.wmem_max</p><p>net.core.rmem_max</p><p>The default value is 4194304.</p><ul><li>ERON_TERM_BUFFER</li></ul><p>The size in bytes of the Term (a section of data within a stream) buffer. The length of the buffer must be a power of two and must be the same length on both ends.The default value is 67108864.</p><ul><li>AERON_MTU<br>The length of MTU in bytes.</li></ul><p>The default value is 65504.</p><blockquote><p><a href="https://docs.genesys.com/Documentation/EZP/9.0.0/Deploy/AeronMediaDriver" target="_blank" rel="noopener">https://docs.genesys.com/Documentation/EZP/9.0.0/Deploy/AeronMediaDriver</a></p></blockquote><h4 id="shm-on-Linux-System"><a href="#shm-on-Linux-System" class="headerlink" title="shm on Linux System"></a>shm on Linux System</h4><p>在Docker中，/dev/shm 默认大小是64MB，完全不够用，因此需要调整大小。</p><p>然而，在Kubernetes中是不持支持shm-size参数的，通过启动脚来修改容器/dev/shm。</p><p>前提条件：–priviledge=true</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shm_dir=/dev/shm</span><br><span class="line">umount <span class="variable">$shm_dir</span></span><br><span class="line">mount -t tmpfs -o rw,nosuid,nodev,noexec,relatime,size=&lt;size, e.g. 500M, 1G&gt; shm <span class="variable">$shm_dir</span></span><br></pre></td></tr></table></figure><p>running docker command</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --privileged image:tag</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">docker run -it --privileged image:tag /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://tw.saowen.com/a/d4e0d2129b3fcaa1597c3860ac1f4e77753e738073b67ae599b8b4b10d0b8ee2" target="_blank" rel="noopener">https://tw.saowen.com/a/d4e0d2129b3fcaa1597c3860ac1f4e77753e738073b67ae599b8b4b10d0b8ee2</a></p></blockquote><h4 id="Media-Driver-on-Docker"><a href="#Media-Driver-on-Docker" class="headerlink" title="Media Driver on Docker"></a>Media Driver on Docker</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> java:openjdk-<span class="number">8</span>-alpine</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> init.sh /init.sh</span></span><br><span class="line"><span class="bash">COPY boot.jar /java/boot.jar</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">RUN chmod +x /init_shm.sh</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/init.sh"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"1G"</span>, <span class="string">"/java/boot.jar"</span>]</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"init shm size: <span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"args: <span class="variable">$@</span>"</span></span><br><span class="line"></span><br><span class="line">shm_dir=/dev/shm</span><br><span class="line">umount <span class="variable">$shm_dir</span></span><br><span class="line">mount -t tmpfs -o rw,nosuid,nodev,noexec,relatime,size=<span class="variable">$1</span> shm <span class="variable">$shm_dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## running java process</span></span><br><span class="line">java -jar <span class="variable">$2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Design-Overview&quot;&gt;&lt;a href=&quot;#Design-Overview&quot; class=&quot;headerlink&quot; title=&quot;Design Overview&quot;&gt;&lt;/a&gt;Design Overview&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="Aeron" scheme="https://sulangsss.github.io/tags/Aeron/"/>
    
  </entry>
  
  <entry>
    <title>What&#39;s Architecture Design</title>
    <link href="https://sulangsss.github.io/2018/10/14/Architecture/What&#39;s%20Architechture%20Design/"/>
    <id>https://sulangsss.github.io/2018/10/14/Architecture/What&#39;s Architechture Design/</id>
    <published>2018-10-14T03:01:22.000Z</published>
    <updated>2018-10-14T13:04:27.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="What’s-Architecture-Design"><a href="#What’s-Architecture-Design" class="headerlink" title="What’s Architecture Design"></a>What’s Architecture Design</h3><h4 id="Terms"><a href="#Terms" class="headerlink" title="Terms"></a>Terms</h4><ul><li><p>系统：泛指由一群有关联的个体组成，根据某种规则运作，能完成个别元件不能单独完成的工作的群体。</p></li><li><p>模块：划分的目的是职责分离。</p></li><li><p>组件：划分的目的是复用。</p></li><li><p>软件架构：软件系统的顶层结构。</p><ul><li>系统由一群关联个体组成。</li><li>明确系统包含的个体，例如子系统、模块、组件等等。</li><li>明确个体运作和协作的规则。</li></ul></li></ul><h4 id="Architecture-Design-Purpose"><a href="#Architecture-Design-Purpose" class="headerlink" title="Architecture Design Purpose"></a>Architecture Design Purpose</h4><p><strong>架构设计的目的：解决复杂度带来的问题。</strong></p><ul><li><p>复杂度的来源</p><ul><li>高性能</li><li>高可用</li><li>可扩展性</li><li>低成本</li><li>安全</li><li>规模</li></ul></li><li><p>常见误区</p><ul><li>因为架构很重要，所以要做架构设计</li><li>不是每个系统都要做架构设计吗？</li><li>为了高性能、高可用、扩展，所以要做架构设计，上来就要实现”三高“，结果会出现架构设计无比复杂。</li></ul></li></ul><h4 id="Difference-between-framework-and-architecture"><a href="#Difference-between-framework-and-architecture" class="headerlink" title="Difference between framework and architecture"></a>Difference between framework and architecture</h4><p>框架关注的是<strong>规范</strong>，架构关注的是<strong>结构</strong></p><h4 id="Design-Principle"><a href="#Design-Principle" class="headerlink" title="Design Principle"></a>Design Principle</h4><ul><li>合适原则</li><li>简单原则</li><li>演化原则</li></ul><h4 id="合适原则"><a href="#合适原则" class="headerlink" title="合适原则"></a>合适原则</h4><p><strong>宣言：合适优于业界领先。</strong></p><p>脚踏实地做事</p><ul><li>将军难打无兵之仗：没那么多人，却想干那么多活，是失败的第一个主要原因。</li><li>罗马不是一天建成的：没有那么多积累，却想一步登天，是失败的第二原因。</li><li>冰山下面才是关键：没有那么卓越的业务场景，却幻想灵光一闪成为天才，是失败的第三个主要原因。</li></ul><h4 id="简单原则"><a href="#简单原则" class="headerlink" title="简单原则"></a>简单原则</h4><p><strong>宣言：简单优于复杂</strong></p><p>”复杂“在制造领域代表先进，在建筑领域代表领先，但在软件领域，却恰恰相反，代表的是”问题“。</p><p>软件领域的复杂性体现：</p><ul><li>结构的复杂性<ul><li>组件数量多</li><li>组件之间关系复杂</li></ul></li><li>逻辑的复杂性<ul><li>遵循KISS原则（Keep It Simple, Stupid!）</li></ul></li></ul><p>带来的问题：</p><ul><li>组件越多，就越有可能其中某个组件出现故障，从而导致系统故障。</li><li>某个组件改动，会影响关联的所有组件，这些被影响的组件同样会继续递归影响更多组件。</li><li>定位一个复杂系统中的问题总是比简单系统更加困难。</li></ul><h5 id="演化原则"><a href="#演化原则" class="headerlink" title="演化原则"></a>演化原则</h5><p><strong>宣言：演化优于一步到位</strong></p><p>Windows系统的发展历史，Android系统发展历史</p><p><strong>对于软件来说，变化才是主题。</strong>软件架构需要根据业务的发展而不断变化。设计Windows和Android的人都是顶尖的天才，即便如此，他们也不可能在1985年设计出Win8，不可能在2009年设计出Android 6.0。</p><p>如果没有把握”软件架构需要根据业务发展不断变化“这个本质，在做架构设计的时候就会容易陷入一个误区：试图一步到位设计一个软件架构，期望不管业务如何变化，架构都稳如磐石。</p><p>生物演化：</p><ol><li>生物要适应当时的环境。</li><li>生物需要不断地迭代繁殖，将有利的基因传承下去，将不利的基因剔除或修复。</li><li>当环境变化时，生物要能够快速改变以适应环境变化；如果生物无法调整就被自然淘汰；新的生物会保留一部分原来被淘汰的生物的基因</li></ol><p>软件架构设计：</p><ol><li>设计出来的架构要满足当时的业务需要。</li><li>架构要不断地在实际应用过程中迭代，保留优秀的设计，修复有缺陷的设计，改正错误的设计，去掉无用的设计，使得架构逐渐完善。</li><li>当业务发生变化时，架构要扩展、重构、甚至重写；代码也许会重写，但有价值的经验、教训、逻辑、设计等却可以在新架构延续。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;What’s-Architecture-Design&quot;&gt;&lt;a href=&quot;#What’s-Architecture-Design&quot; class=&quot;headerlink&quot; title=&quot;What’s Architecture Design&quot;&gt;&lt;/a&gt;What’s A
      
    
    </summary>
    
      <category term="Architecture" scheme="https://sulangsss.github.io/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="https://sulangsss.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Java AtomicStampedReference And AtomicReference</title>
    <link href="https://sulangsss.github.io/2018/10/12/Java/LowLatency/AtomicStampeReference/"/>
    <id>https://sulangsss.github.io/2018/10/12/Java/LowLatency/AtomicStampeReference/</id>
    <published>2018-10-12T10:01:22.000Z</published>
    <updated>2018-10-12T10:32:04.113Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>解决CAS的ABA问题</p><h3 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>AtomicReference和AtomicInteger非常类似，不同之处就在于AtomicInteger是对整数的封装，而AtomicReference则对应普通的对象引用。也就是它可以保证你在修改对象引用时的线程安全性。</p><p>在介绍AtomicReference的同时，我希望同时提出一个有关原子操作的逻辑上的不足。</p><blockquote><p><a href="https://segmentfault.com/a/1190000004452926" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004452926</a></p></blockquote><h3 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>AtomicStampedReference内部不仅维护了对象值，还维护了一个类似时间戳的字段作为版本号（它可以使任何一个整数，它使用整数来表示状态值）。</p><p>当AtomicStampedReference对应的数值被修改时，除了更新数据本身外，还必须要更新版本号。</p><p>当AtomicStampedReference设置对象值时，对象值以及版本号都必须满足期望值，写入才会成功。因此，即使对象值被反复读写，写回原值，只要版本号发生变化，就能防止不恰当的写入。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;解决CAS的ABA问题&lt;/p&gt;
&lt;h3 id=&quot;AtomicReference&quot;&gt;&lt;a href=&quot;#AtomicReference&quot; cl
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="AtomicStampedReference" scheme="https://sulangsss.github.io/tags/AtomicStampedReference/"/>
    
  </entry>
  
  <entry>
    <title>Java Unsafe</title>
    <link href="https://sulangsss.github.io/2018/10/12/Java/LowLatency/Unsafe/"/>
    <id>https://sulangsss.github.io/2018/10/12/Java/LowLatency/Unsafe/</id>
    <published>2018-10-12T04:01:22.000Z</published>
    <updated>2018-10-12T10:24:16.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>sun.misc.Unsafe类</p><p>Unsafe类提供了硬件级别的原子操作，主要提供了以下功能：</p><ul><li>通过Unsafe类可以分配内存，可以释放内存；</li><li>可以定位对象某字段的内存位置，也可以修改对象的字段值，即使它是私有的；</li><li>线程挂起与恢复</li><li>CAS操作</li></ul><h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><h4 id="Compare-And-Swap-CAS"><a href="#Compare-And-Swap-CAS" class="headerlink" title="Compare And Swap(CAS)"></a>Compare And Swap(CAS)</h4><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。</p><p>如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。</p><p>无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。” </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;sun.misc.Unsafe类&lt;/p&gt;
&lt;p&gt;Unsafe类提供了硬件级别的原子操作，主要提供了以下功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="Unsafe" scheme="https://sulangsss.github.io/tags/Unsafe/"/>
    
  </entry>
  
  <entry>
    <title>Mac System Command</title>
    <link href="https://sulangsss.github.io/2018/10/11/Mac/Command/System/"/>
    <id>https://sulangsss.github.io/2018/10/11/Mac/Command/System/</id>
    <published>2018-10-11T03:01:22.000Z</published>
    <updated>2018-10-11T04:14:05.829Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a | grep machdep.cpu</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CPU&quot;&gt;&lt;a href=&quot;#CPU&quot; class=&quot;headerlink&quot; title=&quot;CPU&quot;&gt;&lt;/a&gt;CPU&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp
      
    
    </summary>
    
      <category term="Mac" scheme="https://sulangsss.github.io/categories/Mac/"/>
    
      <category term="Command" scheme="https://sulangsss.github.io/categories/Mac/Command/"/>
    
    
      <category term="Command" scheme="https://sulangsss.github.io/tags/Command/"/>
    
      <category term="System" scheme="https://sulangsss.github.io/tags/System/"/>
    
      <category term="Mac" scheme="https://sulangsss.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>Java Zero Garbage</title>
    <link href="https://sulangsss.github.io/2018/10/11/Java/LowLatency/ZeroGarbage/"/>
    <id>https://sulangsss.github.io/2018/10/11/Java/LowLatency/ZeroGarbage/</id>
    <published>2018-10-11T03:01:22.000Z</published>
    <updated>2018-10-12T04:20:47.674Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lib"><a href="#Lib" class="headerlink" title="Lib"></a>Lib</h3><h4 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h4><ul><li>Aeron</li><li>fastutil</li></ul><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><ul><li>Unsafe</li><li>AtomicReference</li></ul><h3 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h3><ul><li>Disruptor</li></ul><h3 id="Operation-System"><a href="#Operation-System" class="headerlink" title="Operation System"></a>Operation System</h3><h3 id="CPU-Cache-Performance"><a href="#CPU-Cache-Performance" class="headerlink" title="CPU Cache Performance"></a>CPU Cache Performance</h3><ul><li>L1<ul><li>4 cycles</li></ul></li><li>L2<ul><li>10 cycles</li></ul></li><li>L3<ul><li>local：40~75 cycles</li><li>remote：100~300 cycles</li></ul></li><li>Draw<ul><li>local：60ns</li><li>remote：100ns</li></ul></li></ul><h3 id="CPU-Cache-Line"><a href="#CPU-Cache-Line" class="headerlink" title="CPU Cache Line"></a>CPU Cache Line</h3><h3 id="False-Sharing"><a href="#False-Sharing" class="headerlink" title="False Sharing"></a>False Sharing</h3><blockquote><p><a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener">https://www.cnblogs.com/cyfonly/p/5800758.html</a></p></blockquote><h3 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h3><h4 id="Reference-vs-Primitives"><a href="#Reference-vs-Primitives" class="headerlink" title="Reference vs Primitives"></a>Reference vs Primitives</h4><h4 id="Caculations"><a href="#Caculations" class="headerlink" title="Caculations"></a>Caculations</h4><ul><li>long</li><li>Double</li><li>BigDecimal</li></ul><h4 id="java-util-vs-fastutil"><a href="#java-util-vs-fastutil" class="headerlink" title="java.util vs fastutil"></a>java.util vs fastutil</h4><blockquote><p><a href="http://java-performance.info/hashmap-overview-jdk-fastutil-goldman-sachs-hppc-koloboke-trove-january-2015/" target="_blank" rel="noopener">http://java-performance.info/hashmap-overview-jdk-fastutil-goldman-sachs-hppc-koloboke-trove-january-2015/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Lib&quot;&gt;&lt;a href=&quot;#Lib&quot; class=&quot;headerlink&quot; title=&quot;Lib&quot;&gt;&lt;/a&gt;Lib&lt;/h3&gt;&lt;h4 id=&quot;Network&quot;&gt;&lt;a href=&quot;#Network&quot; class=&quot;headerlink&quot; title=&quot;Network
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="Zero Garbage" scheme="https://sulangsss.github.io/tags/Zero-Garbage/"/>
    
  </entry>
  
  <entry>
    <title>Java False Sharing</title>
    <link href="https://sulangsss.github.io/2018/10/11/Java/LowLatency/FalseSharing/"/>
    <id>https://sulangsss.github.io/2018/10/11/Java/LowLatency/FalseSharing/</id>
    <published>2018-10-11T03:01:22.000Z</published>
    <updated>2018-10-11T04:31:39.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>如果CPU访问的内存数据不在Cache中（一级、二级、三级），这就产生了Cache Line miss问题，此时CPU不得不发出新的加载指令，从内存中获取数据。</p><p>Cache主要分为L1、L2 和 L3，如果出现Cache Line Missing，CPU就要从内存中访问数据，这就会产生一个较大的时延，程序性能显著降低。为此我们不得不提高Cache命中率，也就是充分发挥局部性原理。</p><ul><li>时间局部性：对于同一数据可能被多次使用，自第一次加载到Cache Line后，后面的访问就可以多次从Cache Line中命中，从而提高读取速度（而不是从下层缓存读取）。</li><li>空间局部性：一个Cache Line有64字节块，我们可以充分利用一次加载64字节的空间，把程序后续会访问的数据，一次性全部加载进来，从而提高Cache Line命中率（而不是重新去寻址读取）。</li></ul><p>举例，长度为16的row和column数组，在Cache Line 64字节数据块上内存地址是连续的，能被一次加载到Cache Line中，所以在访问数组时，Cache Line命中率高，性能发挥到极致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span>[] row, <span class="keyword">int</span>[] column)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++ ) &#123;</span><br><span class="line">        sum += row[i] * column[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量i则体现了时间局部性，i作为计数器被频繁操作，一直存放在寄存器中，每次从寄存器访问，而不是从主存甚至磁盘访问。虽然连续紧凑的内存分配带来高性能，但并不代表它一直都能带来高性能。</p><blockquote><p><a href="https://blog.csdn.net/qq_27680317/article/details/78486220" target="_blank" rel="noopener">https://blog.csdn.net/qq_27680317/article/details/78486220</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Background&quot;&gt;&lt;a href=&quot;#Background&quot; class=&quot;headerlink&quot; title=&quot;Background&quot;&gt;&lt;/a&gt;Background&lt;/h3&gt;&lt;p&gt;如果CPU访问的内存数据不在Cache中（一级、二级、三级），这就产生了Ca
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/categories/Java/Low-Latency/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="Low Latency" scheme="https://sulangsss.github.io/tags/Low-Latency/"/>
    
      <category term="False Shring" scheme="https://sulangsss.github.io/tags/False-Shring/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 Java volatile</title>
    <link href="https://sulangsss.github.io/2018/10/10/Java/Advance/volatile/"/>
    <id>https://sulangsss.github.io/2018/10/10/Java/Advance/volatile/</id>
    <published>2018-10-10T14:35:06.000Z</published>
    <updated>2018-10-25T08:55:05.664Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><strong>volatile</strong>这个关键字，不仅仅在Java语言中有，在很多语言中都有的，而且其用法和语义也都是不尽相同的。尤其在C语言、C++以及Java中，都有volatile关键字。都可以用来声明变量或者对象。</p><p>volatile通常被比喻成”轻量级的<strong>synchronized</strong>“，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p><strong>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</strong></p><p>一个比较典型的使用双重锁校验的形式实现单例的，其中使用volatile关键字修饰可能被多个线程同时访问到的singleton。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。而volatile就可以解决读写数据不一致的问题。</p><p>对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性协议</strong>。</p><p>如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p><blockquote><p>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p></blockquote><hr><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>线程是CPU调度的基本单位。CPU有时间片的概念，会根据不同的调度算法进行线程调度。当一个线程获得时间片之后开始执行，在时间片耗尽之后，就会失去CPU使用权。所以在多线程场景下，由于时间片在线程间轮换，就会发生原子性问题。</p><p><strong>原子性是指一个操作是不可中断的，要全部执行完成，要不就都不执行。</strong></p><p><strong>volatile是不能保证原子性的。</strong></p><p>volatile应用场景：</p><ul><li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</li><li>变量不需要与其他状态变量共同参与不变约束。</li></ul><p>除以上场景外，都需要使用其他方式来保证原子性，如synchronized或者concurrent包。</p><p>举例说明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较简单，就是创建10个线程，然后分别执行1000次i++操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是volatile无法满足原子性的原因。</p><p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证inc在多个线程之间的可见性。但是无法inc++的原子性。</p><p>为什么volatile不能保证原子性呢？因为他不是锁，他没做任何可以保证原子性的处理。当然就不能保证原子性了。</p><blockquote><p>synchronized 为了保证原子性，需要通过字节码指令monitorenter和monitorexit，但是volatile和这两个指令之间是没有任何关系的。volatile是不能保证原子性的。</p></blockquote><hr><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>Java内存模型规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程中是用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存。</p><p>不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量的传递均需要自己的工作内存和主存之间进行数据同步进行。所以就可能出现线程1改了某个变量的值，但是线程2不可见的情况。</p><p><strong>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</strong>即，被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次在用之前都从主内存刷新。</p><p>因此，可以使用volatile来保证多线程操作时变量的可见性。</p><p>volatile对于可见性的实现，内存屏障也起着至关重要的作用。</p><p>因为内存屏障相当于一个数据同步点，他要保证在这个同步点之后的读写操作必须在这个点之前的读写操作都执行完之后才可以执行。并且在遇到内存屏障的时候，缓存数据会和主存进行同步，或者把缓存数据写入主存、或者从主存把数据读取到缓存。</p><h4 id="问题来了：已经有了缓存一致性协议，为什么还需要volatile？"><a href="#问题来了：已经有了缓存一致性协议，为什么还需要volatile？" class="headerlink" title="问题来了：已经有了缓存一致性协议，为什么还需要volatile？"></a>问题来了：已经有了缓存一致性协议，为什么还需要volatile？</h4><ol><li><p>并不是所有的硬件架构都提供了相同的一致性保证，Java作为一门跨平台语言，JVM需要提供一个统一的语义。</p></li><li><p>操作系统中的缓存和JVM中线程的本地内存并不是一回事，通常我们可以认为：MESI（Cache一致性协议）可以解决缓存层面的可见性问题。使用volatile关键字，可以解决JVM层面的可见性问题。</p></li><li><p>缓存可见性问题的延伸：由于传统的MESI协议的执行成本比较大。所以CPU通过Store Buffer和Invalidate Queue组件来解决，但是由于这两个组件的引入，也导致缓存和主存之间的通信并不是实时的。也就是说，缓存一致性模型只能保证缓存变更可以保证其他缓存也跟着改变，但是不能保证立刻、马上执行。</p></li></ol><p>在计算机内存模型中，也是使用内存屏障来解决缓存的可见性问题的（再次强调：缓存可见性和并发编程中的可见性可以互相类比，但是他们并不是一回事儿）。</p><p>写内存屏障（Store Memory Barrier）可以促使处理器将当前store buffer（存储缓存）的值写回主存。读内存屏障（Load Memory Barrier）可以促使处理器处理invalidate queue（失效队列）。进而避免由于Store Buffer和Invalidate Queue的非实时性带来的问题。</p><p>所以，内存屏障也是保证可见性的重要手段，操作系统通过内存屏障保证缓存间的可见性，JVM通过给volatile变量加入内存屏障保证线程之间的可见性。</p><blockquote><p>内存屏障：用于控制特定条件下的重排序和内存可见性问题。Java编译器也会根据内存屏障的规则禁止重排序。</p></blockquote><hr><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是可能存在有序性问题。</p><p><strong>有序性即程序执行的顺序按照代码的先后顺序执行。</strong></p><p>关键功能：禁止指令重排优化等。</p><p>普通的变量仅仅会保证在该方法的执行过程中所依赖的赋值结果的地方都能获得正确的结果，而不能保证变量的赋值操作的顺序与程序代码中的执行顺序一致。</p><p>volatile禁止指令重排，保证了代码的程序会严格按照代码的先后顺序执行。这就保证了有序性。被volatile修饰的变量的操作，会严格按照代码顺序执行，load-&gt;add-&gt;save 的执行顺序就是：load、add、save。</p><p><strong>volatile是通过内存屏障来来禁止指令重排的。</strong></p><p><strong>内存屏障（Memory Barrier）</strong>是一类同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。</p><p>具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的JMM内存屏障插入策略：</p><ul><li><p>在每个volatile写操作的前面插入一个StoreStore屏障</p><ul><li>对于这样的语句Store1; <strong>StoreStore</strong>; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。</li></ul></li><li><p>在每个volatile写操作的后面插入一个StoreLoad屏障</p><ul><li>对于这样的语句Store1; <strong>StoreLoad</strong>; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。</li></ul></li><li><p>在每个volatile读操作的后面插入一个LoadLoad屏障</p><ul><li>对于这样的语句Load1; <strong>LoadLoad</strong>; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。</li></ul></li><li><p>在每个volatile读操作的后面插入一个LoadStore屏障</p><ul><li>对于这样的语句Load1; <strong>LoadStore</strong>; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。</li></ul></li></ul><p>所以，volatile通过在volatile变量的操作前后插入内存屏障的方式，来禁止指令重排，进而保证多线程情况下对共享变量的有序性。</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>synchronized可以保证原子性、有序性和可见性。而volatile却只能保证有序性和可见性。</p><hr><h3 id="Refer-to"><a href="#Refer-to" class="headerlink" title="Refer to"></a>Refer to</h3><p><a href="http://www.hollischuang.com/archives/2648" target="_blank" rel="noopener">http://www.hollischuang.com/archives/2648</a></p><p>如何正确写单例模式：<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</a></p><p>Cache一致性协议之MESI：<a href="https://blog.csdn.net/muxiqingyang/article/details/6615199" target="_blank" rel="noopener">https://blog.csdn.net/muxiqingyang/article/details/6615199</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot; class=&quot;headerlink&quot; title=&quot;用法&quot;&gt;&lt;/a&gt;用法&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;这个关键字，不仅仅在Java语言中有，在很多语言中都有的，而且其用法和语义也都是不尽相同的
      
    
    </summary>
    
      <category term="Java" scheme="https://sulangsss.github.io/categories/Java/"/>
    
      <category term="Advance" scheme="https://sulangsss.github.io/categories/Java/Advance/"/>
    
    
      <category term="Java" scheme="https://sulangsss.github.io/tags/Java/"/>
    
      <category term="volatile" scheme="https://sulangsss.github.io/tags/volatile/"/>
    
  </entry>
  
</feed>
